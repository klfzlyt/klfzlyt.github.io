[{"title":"2个字符串的编辑距离","date":"2017-06-04T13:20:52.000Z","path":"2017/06/04/diff的o(m*n)/","text":"在react中，在render后的diff阶段，对一个列表进行了diff比较，react的实现比较高效，是o(n)量级，一种通用的diff是类似于求两个字符串的编辑距离(o(m*n))： https://en.wikipedia.org/wiki/Levenshtein_distance 比如要计算cafe和coffee的编辑距离。cafe→caffe→coffe→coffee 动态规划解决思路：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* Utils*/function replareStr(word1, pos, char) &#123; let newWord = ''; for (let i = 0; i &lt; word1.length; i++) &#123; if (i == pos) &#123; newWord += char; &#125; else &#123; newWord += word1[i]; &#125; &#125; return newWord;&#125;function deleteStr(word1, pos) &#123; let newWord = ''; for (let i = 0; i &lt; word1.length; i++) &#123; if (i == pos) &#123; // ddnewWord+=char; &#125; else &#123; newWord += word1[i]; &#125; &#125; return newWord;&#125;function insterStr(word1, pos, char) &#123; let newWord = ''; if (pos &lt; 0) newWord += char; for (let i = 0; i &lt; word1.length; i++) &#123; newWord += word1[i]; if (i == pos) &#123; newWord += char; &#125; &#125; return newWord;&#125;/* * 需要把word1 变到 word2 * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;array&#125; 表示从word1 改变到 word2 中间要过渡的字符串组 */var minDistance = function(word1, word2) &#123; let rowNumber = word1.length + 1; let columnNumber = word2.length + 1; let DP = []; /* init dp */ for (let i = 0; i &lt; rowNumber; i++) &#123; let temp = Array(columnNumber); if (i == 0) &#123; for (let j = 0; j &lt; columnNumber; j++) &#123; temp[j] = j; &#125; &#125; else &#123; temp[0] = i; &#125; DP.push(temp); &#125; for (let i = 1; i &lt; rowNumber; i++) &#123; for (let j = 1; j &lt; columnNumber; j++) &#123; let first, second, third; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; first = DP[i - 1][j - 1]; &#125; else &#123; first = DP[i - 1][j - 1] + 1; &#125; second = DP[i][j - 1] + 1; third = DP[i - 1][j] + 1; DP[i][j] = Math.min(first, second, third); &#125; &#125; let internalwords = []; let endRow = rowNumber - 1; let endColumn = columnNumber - 1; let numberOperation = DP[endRow][endColumn]; while (numberOperation) &#123; let isOperated = false; let duijiao = Infinity; let above = Infinity; let left = Infinity; if (endRow - 1 &lt; 0) &#123; duijiao = Infinity; above = Infinity; &#125; else &#123; if (endColumn - 1 &gt;= 0) &#123; duijiao = DP[endRow - 1][endColumn - 1]; &#125; else &#123; duijiao = Infinity; &#125; above = DP[endRow - 1][endColumn]; &#125; if (endColumn - 1 &lt; 0) &#123; left = Infinity; &#125; else &#123; left = DP[endRow][endColumn - 1]; &#125; let min = Math.min(duijiao, above, left); if (min == duijiao) &#123; isOperated = true; endRow = endRow - 1; endColumn = endColumn - 1; if (duijiao &lt; numberOperation) &#123; //如果小于则替换，不小于不做操作 let newword1 = word1; let tobechar = word2.charAt(endColumn); internalwords.push((word1 = replareStr(newword1, endRow, tobechar))); &#125; &#125; else if (min == above &amp;&amp; !isOperated) &#123; //删除above isOperated = true; endRow = endRow - 1; internalwords.push((word1 = deleteStr(word1, endRow))); &#125; else if (min == left &amp;&amp; !isOperated) &#123; //向左添加 isOperated = true; endColumn = endColumn - 1; let tobeinsertChar = word2.charAt(endColumn); internalwords.push((word1 = insterStr(word1, endRow - 1, tobeinsertChar))); &#125; numberOperation = DP[endRow][endColumn]; &#125; return internalwords;&#125;;//let interwords = minDistance('sunday', 'saturday');//let interwords = minDistance('sitting', 'kitten');let interwords = minDistance('a12234', '1234');console.log('interwords', interwords);/* 2步 interwords (2) [\"a1234\", \"1234\"]*/ 从sunday——&gt;saturday,需要3步[“surday”, “sturday”, “saturday”]从sitting——&gt;kitten，需要3步[“sittin”, “sitten”, “kitten”]从a12234——&gt;1234，需要2步[“a1234”, “1234”]","tags":[{"name":"算法 动态规划","slug":"算法-动态规划","permalink":"http://07lyt.com/tags/算法-动态规划/"}]},{"title":"react-redux源码分析","date":"2017-05-28T13:20:52.000Z","path":"2017/05/28/react-redux/","text":"react-redux(4.4.5)react-reudx 5.0+的版本已经进行了比较大的重构，这里主要介绍v4的版本 providerprovider主要做了传递store的事情，通过在parent组件内，使用getChildContext方法，这个方法可以把相应的属性隐式往下传，子组件及子组件的子组件都可以获得此属性 1234567891011121314export default class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.store &#125; &#125; constructor(props, context) &#123; super(props, context) this.store = props.store &#125; render() &#123; return Children.only(this.props.children) &#125;&#125; 从Provider的代码中可以看到在构造函数初始化的时候将store赋了值，之后通过getChildContext将值往下传递还要注意childContextTypes需要声明出用到的属性12345678/*Index.childContextTypes=&#123; name: React.PropTypes.string.isRequired&#125;*/Provider.childContextTypes = &#123; store: storeShape.isRequired&#125; 如同在connect中也要声明用到的context,如下12345678/*ScrollBar.contextTypes=&#123; name:React.PropTypes.string&#125;*/ Connect.contextTypes = &#123; store: storeShape &#125; connect干了什么？1connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;&#125; 首先connect接受4个参数，第一个参数是要把对应的state映射到组件props的函数，第二个是把dipatch过程映射到props上的函数或者对象，第三个参数是把state映射到的props和dispatch映射到的props合成到一个props并最终注入到组件component中的方法，他们都有对应的默认实现，如下注意在源码中Returning object literals的写法1234567const defaultMapStateToProps = state =&gt; (&#123;&#125;) // eslint-disable-line no-unused-varsconst defaultMapDispatchToProps = dispatch =&gt; (&#123; dispatch &#125;)const defaultMergeProps = (stateProps, dispatchProps, parentProps) =&gt; (&#123; ...parentProps, ...stateProps, ...dispatchProps&#125;) mapStateToProps默认返回一个空对象，不做任何state转换，mapDispatchToProps默认注入dispatch方法，mergeProps默认合并state映射到的props，dispatch映射到的props以及自身的props。 12345678910111213141516171819202122export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123; const shouldSubscribe = Boolean(mapStateToProps) const mapState = mapStateToProps || defaultMapStateToProps //dispatch let mapDispatch if (typeof mapDispatchToProps === 'function') &#123; //函数执行，得到一个object注入到组件的props中 mapDispatch = mapDispatchToProps &#125; else if (!mapDispatchToProps) &#123; mapDispatch = defaultMapDispatchToProps &#125; else &#123; //对象传入，包装为一个function，执行完成后得到一个object，这个object就将注入到组件的props中 mapDispatch = wrapActionCreators(mapDispatchToProps) &#125; //[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 官方要求是一个function const finalMergeProps = mergeProps || defaultMergeProps const &#123; pure = true, withRef = false &#125; = options //如果不传第三个参数，checkMergedEquals为false,这个flag将会影响最后的mergedProps的计算，使得每次都要重新render一个新的component const checkMergedEquals = pure &amp;&amp; finalMergeProps !== defaultMergeProps // Helps track hot reloading. const version = nextVersion++ 对不同类型的mapDispatchToProps进行包装，包括对象，与函数形式，使得得到的mapDispatch是一个function connnect组件作为一个Component的wrapper,或者称为HOC（high order component），其负责处理store状态的变化，并选择渲染组件,在构造时拿到全局的store12345678constructor(props, context) &#123; super(props, context) this.version = version this.store = props.store || context.store const storeState = this.store.getState() this.state = &#123; storeState &#125; this.clearCache() &#125; 先初始connnect的状态为全局状态 有几个问题 1.组件如何知道store的变化？2.组件如何处理自身props的变化？3.mapStateToProps是如何注入到props中的呢4.mapDispatchToProps是如何注入到props中的呢 首先connect组件render的时候会去读一些状态1234567const &#123; haveOwnPropsChanged, hasStoreStateChanged, haveStatePropsBeenPrecalculated, statePropsPrecalculationError, renderedElement &#125; = this 由于在construct的时候进行了clear123456789101112clearCache() &#123; this.dispatchProps = null this.stateProps = null this.mergedProps = null this.haveOwnPropsChanged = true this.hasStoreStateChanged = true this.haveStatePropsBeenPrecalculated = false this.statePropsPrecalculationError = null this.renderedElement = null this.finalMapDispatchToProps = null this.finalMapStateToProps = null &#125; 读到的值将为true,true,false,null,null connect中提供了三个重要的对象this.stateProps,this.dispatchProps,this.mergedPropsthis.stateProps用来保存mapStateToProps的转换结果，这里类似于一个小reducerthis.dispatchProps用来保存mapDispatchToProps的转换结果this.mergedProps 用于最后挂载到component上的props这三个对象this.stateProps,this.dispatchProps,this.mergedProps 分别于updateStatePropsIfNeededupdateDispatchPropsIfNeededupdateMergedPropsIfNeeded得到更新只要这3个函数中的某一个执行一次，对应的mapStateToProps, mapDispatchToProps, mergeProps都会相应执行一次 1234567891011121314151617181920212223242526272829/* 步骤： 1.判断是否应该更新this.stateProps this.dispatchProps 2.this.stateProps this.dispatchProps是否变更*/ //先声明变量默认值 let shouldUpdateStateProps = true let shouldUpdateDispatchProps = true //如果之前render过，则计算一下是否需要更新this.stateProps this.dispatchProps if (pure &amp;&amp; renderedElement) &#123; shouldUpdateStateProps = hasStoreStateChanged || ( haveOwnPropsChanged &amp;&amp; this.doStatePropsDependOnOwnProps ) shouldUpdateDispatchProps = haveOwnPropsChanged &amp;&amp; this.doDispatchPropsDependOnOwnProps &#125; let haveStatePropsChanged = false let haveDispatchPropsChanged = false //haveStatePropsBeenPrecalculated在这里是一个保存是否先前计算过的flag if (haveStatePropsBeenPrecalculated) &#123; haveStatePropsChanged = true &#125; else if (shouldUpdateStateProps) &#123; haveStatePropsChanged = this.updateStatePropsIfNeeded() &#125; if (shouldUpdateDispatchProps) &#123; haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded() &#125; 一个简化的render流程，判断this.stateProps，this.dispatchProps是否应该更新的主要逻辑是经过mapStateToProps select后的props有变更过或者是当componentWillReceiveProps判断自身props变更后（浅比较），如果mapDispatchToProps的入参有2个，也将判断this.stateProps应该更新。同理this.dispatchProps的更新也是依赖于自身props变更后,且mapDispatchToProps的入参有2个。 从初始路径开始，看看当store变化后connent如何处理,首先看到组件在初始的时候就使用store注册了store的变更回调，这个回调会在dispatch任何type的情况下得到执行，所以初始时需要判断之前的store状态和当前的store是否一致，123if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; 1.因为有些情况下dispatch出来的一个action不会引起reducer结果的任何变化，之后如果mapStateToProps的入参只有一个，会进行一次select操作，如果selector得到的结果没有任何变化（浅拷贝）,则直接返回，这个时候效率是最高的，没有组件的rerender(表现在connnect组件的setState),相当于组件不知道store改变了，react组件保持原状 2.如果mapStateToProps得到的结果有变化（浅拷贝），handleChange会做几个动作，一个是置2个标志位为true,12this.haveStatePropsBeenPrecalculated = truethis.hasStoreStateChanged = true this.haveStatePropsBeenPrecalculated用来表达updateStatePropsIfNeeded已经执行过，即mapStateToProps进行过select，this.hasStoreStateChanged用来表达store的state已经变化，需要重新计算this.stateProps这个状态位在shouldComponentUpdate，以及判断this.stateProps是否更新时用的上另一个重要的动作是： this.setState({ storeState }) 这个时候将会触发 123shouldComponentUpdate() &#123; return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged &#125; 由于this.hasStoreStateChanged已经被置位，所以会进行render的操作每次进入render都会进行一系列的判断值得注意的是，如果在之前检测到store变化后，mapStateToProps得到新的结果，updateStatePropsIfNeeded执行过， 则this.haveStatePropsBeenPrecalculated = true那么下面的代码就进入第一个分支，updateStatePropsIfNeeded不需要再重新计算了。12345if (haveStatePropsBeenPrecalculated) &#123; haveStatePropsChanged = true&#125; else if (shouldUpdateStateProps) &#123; haveStatePropsChanged = this.updateStatePropsIfNeeded()&#125; 对于mapStateToProps mapDispatchToProps第二个ownprops参数的认识：这个2个函数的第二个参数主要是为了处理自身props变动的情形，如果这2个函数带了第二个参数ownprops，那么每次props变动的时候，这2个函数都会得到执行，即为重新select,如果不带这2个参数，那么自身props有变动的时候，这2个函数不会得到执行，对于这2个函数，带不带第二个参数ownprops，props变更的行为都跟裸用react组件时的行为一致。 updateMergedPropsIfNeeded是最后的过滤器12345678910111213141516171819202122232425262728293031323334componentDidMount() &#123; this.trySubscribe() &#125; trySubscribe() &#123; if (shouldSubscribe &amp;&amp; !this.unsubscribe) &#123; this.unsubscribe = this.store.subscribe(this.handleChange.bind(this)) this.handleChange() &#125; &#125;handleChange() &#123; if (!this.unsubscribe) &#123; return &#125; const storeState = this.store.getState() const prevStoreState = this.state.storeState if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; if (pure &amp;&amp; !this.doStatePropsDependOnOwnProps) &#123; const haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this) if (!haveStatePropsChanged) &#123; return &#125; if (haveStatePropsChanged === errorObject) &#123; this.statePropsPrecalculationError = errorObject.value &#125; this.haveStatePropsBeenPrecalculated = true &#125; this.hasStoreStateChanged = true this.setState(&#123; storeState &#125;) &#125;","tags":[{"name":"redux","slug":"redux","permalink":"http://07lyt.com/tags/redux/"}]},{"title":"动手实现一个简易HTML解析器","date":"2017-04-19T13:20:52.000Z","path":"2017/04/19/动手实现一个简易HTML解析器/","text":"在动手之前，先说说动机，之前看过浏览器工作原理的一系列文章，如： chrome dom树构建源码解析 浏览器的工作原理：新式网络浏览器幕后揭秘 以及一些规范 html解析构建规范 css 规范 在了解了原理与一些规范之后就想要自己试试造个轮子，加深对浏览器的理解。在大致梳理好流程之后，有以下目录： 目录 概述 HTML解析篇 CSS解析篇 应用CSS样式到DOM中 事件系统 一.概述在浏览器中，我们的类有以下的继承关系，如一个div dom 继承自HTMLElemnt,HTMLElemnt继承自Element等。为了方便起见，将一些重要的如dispatchEvent等方法，children，parent，attributes等属性都纳入HTMLElement中。并且依照css object model，构造cssom对象。 因而实现下面的类，并实现manager来管理，即可实现一个简易的解析器。 二.HTML解析篇解析html标签，最先想到的是正则，但是用正则可以解析，但是有几个问题： 如何建立dom树的父子关系 如何建立dom树的兄弟关系 如何实现getElementById方法 纯文本节点怎么解析 innerHTML该怎么做 innerText该怎么做 addEventListener该怎么做 怎么构造attributeNode 其中1,2是构建dom树的关键，对于7将在事件篇中实现。 1. 如何建立dom树的父子关系chrome dom树构建源码解析参考这篇文章，我们需要做的是一个临时栈，以一个例子来说明如图所示，有一段HTML文本，我们的解析是从文本的第一个字符到最后一个字符，从上到下，从左到右进行解析，按照chrome的做法，chrome是先解析文本，得到一系列token，再进行树的构建(参考文章)。而利用正则的步进过程，我们可以把2个阶段合成一个进行实现，绿色的部分是我们的临时栈，我们的解析策略是:正则匹配到一个开始标签时，就new一个Node，然后推入绿色临时栈中，对于或纯文本的node，也进行new操作，但是不入栈，因为这个node已经算是闭合了图中，有一段HTML文本，先解析到，之后new一个HTMLElement入栈，又解析到，也new一个Element入栈，在遇到闭合之后，便可以pop出，同时把栈顶的元素作为被pop出元素的父元素，进行parent属性与children属性的操作，如图右侧代码所示。 在遇到id为f1的div之后，遇到一个文本dp，临时栈如图绿色部分所示这个时候new完一个文本节点即可进行父子赋值操作了，如图右侧所示。 同理，类似操作如下：因此dom树便可以在解析完文本之后构建出来 整个流程简化如下代码，每次解析到一个正则匹配的tag，便进行操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849generatorHtmlNode(html)&#123; html = html.replace(/[\\r\\n]+/g, \"\"); html = html.trim(); //&lt;&gt; &lt;/&gt;等的正则匹配 let tagRegex = /&lt;(\\/)?([^\\/&lt;&gt;]+)(\\/)?&gt;/g; //保存root let root; //记录tag解析位置，用以得到纯文本 let cursor = 0; //用以记录前一个解析到的node let preslibingNode; //解析dom树过程中的临时栈 let htmlstack = []; //保存正则匹配临时结果 let regexResult while ((regexResult = tagRegex.exec(html))) &#123; let holeMatch = regexResult[0]; let isEnd = !!regexResult[1]; let matchGroup = regexResult[2]; let isEndOfOneTag = !!regexResult[3]; //是单闭合标签 let tagName = findTheHtmlTag(regexResult[2]); //解析纯文本 let planText = html.slice(cursor, regexResult.index); let parentNode = getTop(htmlstack); if (!flag) &#123; let node = new HTMLElement( tagName, parentNode, holeMatch, findAttributeKeyPair(matchGroup) ); //临时栈 htmlstack.push(node); &#125; else&#123; //遇到结束标识 popStack(htmlstack); &#125; /* 省略 ………………………………………… ………………………………………… ………………………………………… */ //更新文本游标 cursor = regexResult.index + holeMatch.length; &#125; return root;&#125; 2. 如何建立dom树的兄弟关系同dom树的构建过程，我们可以开辟一些临时空间来保存之前创建的Element.我们用一个变量preslibingNode来存储之前创建的Element.我们重要的是preslibingNode的更新时机，我们应该选择在遇到所有开闭标签以及文本的时候进行更新变量，并要注意赋值判断。以下图的例子来说明。左侧有一串html文本，我们的preslibingNode变量在解析过程中的变化过程如右侧所示。preslibingNode初始为undefined，在遇到第一个并new 它时，preslibingNode为undefined，因而对的previousSibling属性不作操作，并将preslibingNode更新为，之后解析遇到,preslibingNode为其parent,因而不对的previousSibling属性进行操作，同理更新preslibingNode变量，要注意在遇到如闭合标签的情况下，也要更新preslibingNode变量，但不必更新span节点的preslibingNode信息，如右图。之后遇到dp2的文本的时候，由于preslibingNode有值且不是其父亲节点，因而可以应用previousSibling属性，如代码所示：12345678if ( preslibingNode &amp;&amp; preslibingNode != parentNode ) &#123; //构建双向链表 node.previousSibling = preslibingNode; preslibingNode.nextSibling = node; &#125; 之后的过程如图所示，直到所有的文本解析完毕。 3. 如何实现getElementById方法实现getElementById方法，可以在解析的时候，每次解析到一个含有id的dom，就保存到一个全局hashMap中（key为id,value为dom），这样要要想获取，可以直接从hashmap中获取，减少遍历耗时，以空间换时间 4. 纯文本节点怎么解析利用正则的index特性，再借用一个当前游标，便可以将当前的匹配的html标签与上一个html标签之间的内容保存下来，即为文本的内容12345678910111213141516171819generatorHtmlNode(html)&#123; //&lt;&gt; &lt;/&gt;等的正则匹配 let tagRegex = /&lt;(\\/)?([^\\/&lt;&gt;]+)(\\/)?&gt;/g; let regexResult while ((regexResult = tagRegex.exec(html))) &#123; let holeMatch = regexResult[0]; //解析纯文本 let planText = html.slice(cursor, regexResult.index); /* 省略 ………………………………………… ………………………………………… ………………………………………… */ //更新文本游标 cursor = regexResult.index + holeMatch.length; &#125; return root;&#125; 5. innerHTML该如何操作可以在解析到某个标签时，将这个标签字符串左边的内容都暂时砍去，然后往右找第一个对应的闭合标签，找到了，截取出来即为innerHTML，具体做法是把正则匹配到的结果result传入一个函数，如下所示：123456789101112131415function getInnerHtml(regexResult, node) &#123; //整个HTMLstring,每次都相同 let holeHtml = regexResult.input; let tag = node.name; //切割到当前tag的children位置 获得innerHTML的右边部分 let rightHtml = holeHtml.slice( regexResult.index + regexResult[0].length, holeHtml.length ); //构造第一个匹配到的相应tag的闭合标签 let re = new RegExp(\"&lt;\\\\/(\" + tag + \")&gt;\", \"i\"); // re为/&lt;\\/(div)&gt;/i 没有/g标志，可以用match，效果和exec一样 let regMatched = rightHtml.match(re); //进行切割返回 return rightHtml.substring(0, regMatched.index);&#125; 6. innerText该如何操作innerText也应该很容易，利用innerHTML得到的文本，再利用replace(regex)方法，将标签替换为空即可,这个时候对正则不要分组，会影响性能利用得到的innerHTML，进行正则替换即可，1innerHTML.replace(/&lt;\\/?[^\\/&lt;&gt;]+\\/?&gt;/ig, \"\"); 7. addEventListener该怎么做应该维护一个全局的hashMap，在调用addEventListener时，用以保存对应事件的listen,hashMap的key应为dom,value也应该为一个hashMap(x)查看Event部分 8. 怎么构造attributeNode对于每一个开始标签，利用正则匹配出标签里面的id=’xxx’ class=’xxx1 xx2’等，既可以构造相应的attributeNode每个HTMLElement有一个attributeCollection，按正则匹配进行构造：1234567891011121314151617function findAttributeKeyPair(str) &#123; let attributeRegex = /(([\\w]+)=(('|\")[\\s\\w-]+('|\")))/g; let result; let pairs = []; let attributeCollection = []; while ((result = attributeRegex.exec(str))) &#123; pairs.push(result[1]); &#125; for (let i = 0; i &lt; pairs.length; i++) &#123; let pair = pairs[i]; let keyValue = pair.split(\"=\"); let key = keyValue[0]; let value = keyValue[1].replace(/['\"]+/g, \"\"); attributeCollection.push(new attributeNode(key, value)); &#125; return attributeCollection;&#125; 三.CSS解析篇DOM-CSS / CSSOM浏览器css object model对象，通过document.styleSheets可以得到当前文档的所有样式集，每一个标签可以对应解析出一个CSSStyleSheet对象，本文支持解析出CSSStyleSheet对象CSSStyleSheet对象有一个cssRules属性，其为一CSSRuleList集合，保存有style内含的所有规则，每一个规则为CSSStyleRule。如下：因而我们可以按照上图构造对象，构造selector，property等属性。按照文章开头的介绍，我们构造了下面的css object model。这个规则对应到我们具体些的css样式，即为每一个大括号，每一个CSSStyleRule有cssText属性保存整个css文本，selectorText用来保存css选择器文本，此外我们还引入innerStyleRule到这个规则中，innerStyleRule用以递归css的每一个选择器，以匹配dom是否满足样式规则，并引入_weight对象来保存CSSStyleRule的权重。综上所述，所以我们的目的是解析一段样式文本，得到一个数组，这个数组中保存有多个CSSStyleRule，每一个CSSStyleRule对应一个样式规则所以有几个问题？1.如何解析得到每一个css block块？2.如何得到选择文本？3.如何得到每个具体样式对于上述三个问题，都可以用正则来解析得到12345678910111213141516171819202122232425262728cssRuleGenerator(cssSnippet) &#123; //选择器 及 cssbody 匹配 let cssRegex = /([^\\&#123;\\&#125;]+?)&#123;([^\\&#123;\\&#125;]+)&#125;/ig; let result; let stylesheet = []; while ((result = cssRegex.exec(cssSnippet))) &#123; console.log(\"regex: \", result); let holeMatch = result[0]; //分组拿到选择器 let selector = result[1]; //分组拿到cssBody let cssRuleBody = result[2]; let selectorList = selector; selectorList = selectorList.trim(); let groups = selectorList.split(\",\"); for (let i = 0; i &lt; groups.length; i++) &#123; let seletorTex = groups[i].trim(); stylesheet.push( new CSSStyleRule( holeMatch.trim(), seletorTex.trim(), cssRuleBody.trim() ) ); &#125; &#125; return stylesheet; &#125; 成熟的方案是postcss,postcss有方法能解析cssstr 四.应用CSS样式到DOM中先不考虑css属性和伪类伪元素的情形，只考虑类，id,后代，兄弟等常用选择器，那么问题是：如何把样式应用到对应的node节点中？对于这个问题，可以拆分成以下的小问题1.如何匹配css规则到dom 特别是像有后代选择器，兄弟选择器的情形，如何正确匹配？2.如何保证迭代效率 试想遇到嵌套层级很深的css样式，如果不匹配，又要重新选择路径，大大浪费了性能3.如何处理css优先级问题4.css的应用顺序是从左往右还是从右往左在回答这些问题之前，先介绍cssom的几个类实现，如下： 1.CSSStyleRule对于CSSStyleRule，有一个属性是selectorArray，css中，selector的概念，按MDN，有： basic selector:Type selectors elementnameClass selectors .classnameID selectors #idnameUniversal selectors ns| |Attribute selectors [attr=value] combine selector:basic selector[basic selector] combinator:Adjacent sibling selectors A + BGeneral sibling selectors A ~ BChild selectors A &gt; BDescendant selectors A B 这些都是selector，而CSS的选择器是由selectorlist组成的123selectorlist &#123; property: value; [more property:value; pairs] &#125;...where selectorlist is: selector[:pseudo-class] [::pseudo-element] [, more selectorlists] 所以我们可以把selectorlist切开为一个数组，如对于1div.class1 + span &gt;div 选择器，可以解析出5个selectors1[&apos;div.class1&apos;,&apos;+&apos;,&apos;span&apos;,&apos;&gt;&apos;,&apos;div&apos;] 第一个为combine selector，第二个为combinator，第三个为basic selector，后续类似。 1.1 innerStyleRule根据上一步中的selectorArray，我们可以构造出innerStyleRule。一个innerStyleRule的内部属性如下：每个innerStyleRule包括一个matchTypes和values数组，matchType数组中目前只会有tag,id,class三种enum类型，values数组保存tag,id,calss对应的tagName，idName，className。innerStyleRule最重要的一个属性为relation，即combinator，combinator即为关系，包括父子，兄弟等。innerStyleRule对象示意：12345&#123; matchTypes:Array(enum):MATCHTYPE, values:Array Of String(tagName,className,idName) relation:enum:RELATIONTYPE,&#125; 1234567891011121314//enum of mathTypesexport const MATCHTYPE=&#123; TAG:&apos;Tag&apos;, ID:&apos;id&apos;, CLASS:&apos;CLASS&apos;&#125;//enum of relationTypeexport const RELATIONTYPE=&#123; SUBSELECTOR:&apos;SubSelector&apos;,//NO COMBINATOR DESCENDANT:&apos;Descendant&apos;, // &quot;Space&quot; combinator CHILD: &apos;Child&apos;, // &gt; combinator DIRECTADJACENT:&apos;DirectAdjacent&apos;, // + combinator INDIRECTADJACENT:&apos;IndirectAdjacent&apos; // ~ combinator&#125; 以 [&#39;div.class1&#39;,&#39;+&#39;,&#39;span&#39;,&#39;&gt;&#39;,&#39;div&#39;]这个selectorArray为例，可以得到一个有3个innerStyleRule元素的数组1234567891011121314151617[ &#123; matchType:[&apos;TAG&apos;], relation:&quot;CHILD&quot;,//&gt; values:[&quot;div&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;], relation:&quot;DIRECTADJACENT&quot;,//+ values:[&quot;span&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;SUBSELECTOR&quot;,//NO COMBINATOR values:[&quot;div&quot;,&quot;class1&quot;] &#125;,] 这个数组会在dom匹配css的过程中起到作用，在计算权重的时候也能起到作用。 2.选择器权重实现css选择器优先级是按照下图的关系构造的，每位可以是一个16进制数（那最多只有16个，不过超过16个元素的css选择器也不建议实现）如一个例子，权重值为0x0113:详细参考这篇文章(https://css-tricks.com/specifics-on-css-specificity/)在1.1中得到的innerStyleRule得到了tag,class,id信息，根据其数据结构可以方便的计算样式的weight。 3.按样式类别归类得到的innerStyleRule数组的第0个元素为选择器最右边的元素，根据这个元素可以做一些归类操作，目的是利用hashMap，加速css的匹配过程，这部分的缓存操作能大大提升性能。如图所示，左上方是有html及对应的css，css按从上到下从1到6编号，右侧是按weight进行排过序的css样式，在样式解析过程中，我们会根据selectorlist最右侧的选择器将 CSS 规则添加到某个哈希表中，如图下侧。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，如图所示。实现为：12345678910111213141516 //在创建CSSStyleRule时 //对内部序列选择器中最右的进行判断，存入全局样式缓存中，主要用于应用样式时的加速 //CSSRULEHASHMAP为缓存HashMap let rightRule = this.innerStyles[0]; if (rightRule.matchType.indexOf(MATCHTYPE.ID) &gt;= 0) &#123; CSSRULEHASHMAP.ID.push(this); &#125; if (rightRule.matchType.indexOf(MATCHTYPE.CLASS) &gt;= 0) &#123; CSSRULEHASHMAP.CLASS.push(this); &#125; if (rightRule.matchType.indexOf(MATCHTYPE.TAG) &gt;= 0) &#123; CSSRULEHASHMAP.TAG.push(this); &#125; else &#123; CSSRULEHASHMAP.UNKNOW.push(this); &#125;//这部操作为了解析时候的快速命中，试想在创建一个node，如果一个没有id,class属性的html标签node被创建，那么对它应用的样式应该忽略含有id,class的样式 之后这个缓存Map会在匹配过程中用到。 4.2 应用CSS样式到DOM中以解析下图html与css为例： 我们在构建每一个HTMLElement的时候,去看看这个Node符不符合这6个样式，如果符合，即应用这些样式到HTMLElement上。这个时候可以回答之前提到的问题，如何处理CSS优先级。我们可以把所有相关的样式按权重从小到大排序，按图右侧。在应用样式时，我们先从小到大将低权重样式应用到HTMLElement上，然后用数组后面的高权重的样式去覆盖之前的样式（如果有相同的就覆盖，如果没有相同的就新获得了一个样式）这样依次将整个符合的样式组应用到HTMLElement中。如下图，当解析到节点时，1，2号样式符合，之后从后往前应用样式，依次覆盖，margin被覆盖掉。观察这个节点，发现其没有id属性，所以在遍历6个样式的时候，4号样式是可以不用关心的，因为4号样式为#id选择样式，必定跟当前的节点不会匹配，所以之前的HashMap就派上用场，我们从hashMap中取出classMap和tagMap就好，这样，遍历的时候只需要遍历5个样式。这样能节约很大一部分的匹配过程，按官方介绍，能提升95%的性能。这就回答了一开始的如何提升性能的问题。之后解析到，需要取出5个样式(没有id)，之后符合一个样式，应用其在dom上。 如下图，解析到，需要取出4个样式(没有class)，之后符合两个样式，依次应用其在dom上。 同理，遇到只需要取出3个tagHashMap，之后6匹配成功。 然后回到第一个小问题，css样式如何匹配dom？先考虑下面的例子先看图中的最右测的innerStyleRule数据结构，对于6号样式，为123.div1 div.div2 .div3 ~ span&#123; font-size:20px;&#125; 其对应的innerStyleRules表达为：12345678910111213141516171819202122[ &#123; matchType:[&apos;TAG&apos;], relation:&quot;INDIRECTADJACENT&quot;,//~ values:[&quot;span&quot;] &#125;, &#123; matchType:[&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div3&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div&quot;,&quot;div2&quot;] &#125;, &#123; matchType:[&apos;CLASS&apos;], relation:&quot;SUBSELECTOR&quot;,//nothing values:[&quot;div1&quot;] &#125;] 接下来看看如图HTML部分解析到的是如何匹配成功的。首先在解析HTML文本之前，我们先把CSS的文本解析为了CSSOM，之后开始解析HTML文本，现在解析器解析到了，首先看innerStyleRules数组第一个元素（即为最右侧selector），type为[‘TAG’]，值为[‘span’]，当前HTMLElement为，符合要求，接下来看relation，为INDIRECTADJACENT（~之后选择器）表示选择之后的兄弟节点，那么我们可以反过来看，如果找到一个满足条件的前面的兄弟节点，那么这一级的~是成功的，由于前面的dom已经构建好，因此找到第一个满足条件的前面的兄弟节点，即~这个选择器关系成立，我们可以观察的previousSibling，以及的previousSibling的previousSibling，逐次判断，如果某个previousSibling（HTMLElement）满足innerStyleRules[1]的条件，即为：12345&#123; matchType:[&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div3&quot;] &#125; 有class,且className为div3，则INDIRECTADJACENT（~）匹配成功，这里匹配到。之后以为匹配HTMLElement，其 relation为DESCENDANT，那么我们找到第一个祖先满足条件（div且有class为div2）：12345&#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div&quot;,&quot;div2&quot;] &#125; 找到了是其祖先且满足条件，之后其relation也是DESCENDANT祖先选择器，同理找到了。找祖先的过程可以不断的拿parent属性进行匹配，如.parent，.parent.parent，.parent.parent.parent，这样一直下去，直到根节点为止。 在解析HTML过程中，我们每次new 一个HTMLElement，便执行一次embedCsstoHtmlNode，使得样式嵌入到HTMLElement中。12345678910111213141516171819202122232425262728293031function embedCsstoHtmlNode(node) &#123; //从样式hashMap中获得能用上的样式 let wantedStyles = _constructTheWantedStyleSheets(node); //按照权重对sheet进行排序 quickSort(wantedStyles); //根据node有没有id,有没有class 去拿HASHMAP的值 TAG，UNKNOW一定要拿，ID,CLASS如果NODE没有，可以不拿 for (let i = 0; i &lt; wantedStyles.length; i++) &#123; wantedStyles[i]._resetCursor(); if (matchTheCssStyle(wantedStyles[i], node)) &#123; if (!node.style) node.style = &#123;&#125;; _overrideNodeStyle(node, wantedStyles[i].style); &#125; &#125;&#125;//如果node有id,class才会并入需要的样式//CSSRULEHASHMAP是styleRule的hashMap，分ID,CLASS,TAG,UNKNOW 4个维度function _constructTheWantedStyleSheets(node) &#123; let styleSheets = []; if (node.getAttribute(&quot;id&quot;)) &#123; styleSheets = styleSheets.concat(CSSRULEHASHMAP.ID); &#125; if (node.getAttribute(&quot;class&quot;)) &#123; styleSheets = styleSheets.concat(CSSRULEHASHMAP.CLASS); &#125; //TAG是一定要得，需要过滤的是没有class 和 id的情况 styleSheets = styleSheets.concat(CSSRULEHASHMAP.TAG); styleSheets = styleSheets.concat(CSSRULEHASHMAP.UNKNOW); return styleSheets;&#125; 先从样式hashMap中选择出一部分能匹配中的，之后对这些样式按权重进行排序，然后从第0个开始迭代，这里排序使用了快速排序，之后按照权重从低到高依次调用matchTheCssStyle方法，对node与style匹配成功的即可以进行样式写入，注意在每次样式匹配前调用了 wantedStyles[i]._resetCursor()重置游标方法，这个目的是为了清理在判断style是否与node匹配的过程中产生的内部状态。matchTheCssStyle方法用以判断HTMLElement是否与一个CSSStyleRule匹配，matchTheCssStyle需要判断CSSStyleRule.innerstyleRules中所有的innerstyleRule都匹配。因而在matchTheCssStyle方法中我们需要一个判断单个innerstyleRule是否匹配某个HTMLElement的方法:_isMatchNodeIndex(cssRule, node, index)按游标进行匹配，如果innerStyleRules中某个游标下的innerStyle与HTMLElement及其属性匹配（主要idName,tagName,className对应到HTMLElement中的idName,tagName,className是否对应匹配，这个方法只是比较tagName，idName等，与关系无关）则返回true。matchTheCssStyle的匹配过程为获得当前innerStyleRules游标对应关系，游标初始为0，由于innerStyleRules按从右到左保存，0对应选择器列表中最右的selector，对应上例中选择的是：12345&#123; matchType:[&apos;TAG&apos;], relation:&quot;INDIRECTADJACENT&quot;,//~ values:[&quot;span&quot;]&#125; 如果HTMLElement为span标签，则匹配成功，更新游标信息，之后又去找其第一个匹配兄弟（如果是DESCENDANT，则为找第一个祖先），看是否匹配，如果匹配，则以这个匹配的HTMLElement递归下去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function matchTheCssStyle(cssStyleRule, node) &#123; //获得当前innerStyles游标对应关系，游标初始为0 //由于innerStyles按从右到左保存，0对应选择器列表中最右的selector let RuleCombinator = cssStyleRule.innerStyles[cssStyleRule.cursor].relation; switch (RuleCombinator) &#123; case RELATIONTYPE.DESCENDANT: //后代 /* 如innerStyle为 &#123; matchType:[&apos;TAG&apos;], relation:&quot;CHILD&quot;,//&gt; values:[&quot;div&quot;] &#125;, 则当前node为div就算匹配成功 从右往左开始，如果当前游标对应innerStyles 与 node信息不匹配，返回false */ if (!_isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor)) return; //进到上一级游标 cssStyleRule.cursor++; //对父元素进行匹配 let parent = node.parent; if (!parent) return; //游标已更新 while (!_isMatchNodeIndex(cssStyleRule, parent, cssStyleRule.cursor)) &#123; //由于是后代选择器，找到第一个满足条件的父亲或祖先 parent = parent.parent; //如果找到root根了还没找到，返回false if (!parent) return; &#125; //到这里则最近的祖先找到了 if (cssStyleRule._isCursorEnd()) &#123; return true; &#125; //祖先匹配到了,并且游标没结束 递归这个找到的祖先元素 return matchTheCssStyle(cssStyleRule, parent); case RELATIONTYPE.SUBSELECTOR: //最左 //已经是最左，只要返回是否匹配 return _isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor); case RELATIONTYPE.CHILD: //儿子 //&gt; if (!_isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor)) return; cssStyleRule.cursor++; let parentC = node.parent; if (!parentC) return; if (!_isMatchNodeIndex(cssStyleRule, parentC, cssStyleRule.cursor)) return; if (cssStyleRule._isCursorEnd()) &#123; return true; &#125; return matchTheCssStyle(cssStyleRule, parentC); case RELATIONTYPE.DIRECTADJACENT: //同胞 //+ …………………… case RELATIONTYPE.INDIRECTADJACENT: //兄弟 //~ find all pre …………………… &#125;&#125; 到这里就可以回答之前的问题，为什么要从右往左开始？因为从右往左开始不需要依赖没解析到的node,当stylesheets已经生成好了之后，再进行dom树的解析过程中，每遇到一个node,不论是后代关系，还是兄弟关系，在创建这个node的时候，这个关系就已经确立了的，根本原因是dom树的解析过程是从上到下，从左到右的，或是以解析&lt;&gt;开标签为首要任务的，解析的这个node如果是某个node的后代，那么只要看这个node的parent，往上看，如果是某个node的兄弟，也只需要看previousSibling，这些node在构造这个node的时候已经生成试想如果是从左往右的话，比如#id1 div，那么如果在构造#id1这个node的时候，就要等其后代们都构造完了，才能把样式用于这些后代，所以要等后代构造完，即是先要构造dom树，再把style，应用上去，这样做会造成屏幕白屏，而且有不必要的树遍历过程构造dom树，算是一次遍历，应用样式到dom树又有一次遍历，性能会有影响而从右到左只有一次遍历过程，即为边构建dom树边应用样式，同步进行。 五.事件系统在事件系统中，主要有几个问题？1.dom的addEventListener API怎么实现？2.e.stopPropagation/e.stopImmediatePropagation怎么实现？3.dom的dispatchEvent API怎么实现？ 按mdn描述：事件响应会有一个Event对象，用于保存事件属性，包括事件冒泡及捕获过程中的状态 先来看看事件对象的mdn定义，我们实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export const EVENTPHASE = &#123; BUBBLE: 1, CAPTURE: 2, TARGET: 3&#125;;export default class Event &#123; // event = new Event(typeArg, eventInit); /* typeArg Is a DOMString representing the name of the event. eventInit Optional Is an EventInit dictionary, having the following fields: &quot;bubbles&quot;: (Optional) A Boolean indicating whether the event bubbles. The default is false. &quot;cancelable&quot;: (Optional) A Boolean indicating whether the event can be canceled. The default is false. &quot;scoped&quot;: (Optional) A Boolean indicating whether the given event bubbles. If this value is true, deepPath will only contain a target node. &quot;composed&quot;: (Optional) A Boolean indicating whether the event will trigger listeners outside of a shadow root. The default is false. */ /* var event = new MouseEvent(&apos;click&apos;, &#123; &apos;view&apos;: window, &apos;bubbles&apos;: true, &apos;cancelable&apos;: true &#125;); */ constructor(typeArg, eventInit) &#123; //this.eventPhase enum this._isStopPropagation = false; this._isStopImmediatePropagation = false; this.type = typeArg; //todo default config this.option = eventInit || &#123; bubbles: true, cancelable: true &#125;; this.bubbles = this.option.bubbles; this.timeStamp = +new Date(); //该属性总是指向被绑定事件句柄（event handler）的元素 this.currentTarget; this.target; this.eventPhase; &#125; preventDefault() &#123; //not stop bubbling &#125; stopPropagation() &#123; if (this.option.cancelable) &#123; this._isStopPropagation = true; &#125; &#125; stopImmediatePropagation() &#123; //停止冒泡 且停止队列 if (this.option.cancelable) &#123; this._isStopImmediatePropagation = true; &#125; &#125; //event.initEvent(type, bubbles, cancelable); /* type Is a DOMString defining the type of event. bubbles Is a Boolean deciding whether the event should bubble up through the event chain or not. Once set, the read-only property Event.bubbles will give its value. cancelable Is a Boolean defining whether the event can be canceled. Once set, the read-only property Event.cancelable will give its value. */ initEvent(type, bubbles, cancelable) &#123; //old style this.type = type; &#125;&#125; 对于旧标准var event = Document.createEvent(),event.initEvent()的事件创建方式，我们先不实现，我们使用新的事件创建形式，即为通过构造函数形式创建事件关于事件流程： 创建事件与触发事件参考关于事件系统中target 与 currentTarget 的区别 首先我们来实现addEventListener， 基于chrome的实现思路，我们将事件监听函数存入一个全局hashMap中，并把每个node作为key,value为这个节点对应的事件集合。如图所示：这个实现与V8的实现有一些区别，V8是每个Key对应一个vector,这边是每个key对应一个hashMap 不过都能实现，不影响理解。我们实现如下:1234567891011addEventListener(eventName, fn, useCaputrue) &#123; let domKey = MD5(this); //在V8是用指针即内存地址来作为KEY，这样能保证KEY的唯一 if (!EVENTMAP[domKey]) EVENTMAP[domKey] = &#123;&#125;; let listenersQueue = EVENTMAP[domKey] &amp;&amp; EVENTMAP[domKey][eventName]; if (!listenersQueue) EVENTMAP[domKey][eventName] = []; EVENTMAP[domKey][eventName].push(&#123; fn: fn, useCaputrue: useCaputrue &#125;);&#125; 这就回答了第一个问题。 现在来实现dispatchEvent，按照定义dispatchEvent，应该有以下的方法接口1var cancelled = !elem.dispatchEvent(event); 值得一提的是，我们只实现W3C事件，原生事件是通过层层封装的，如下图考虑dispatchEvent事件之后，事件要进行捕获和冒泡，因而要得到冒泡捕获路径，路径可以不断遍历parent属性来得到。如上图，我们先进行事件捕获，到达target之后，再进行事件冒泡，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//分发事件 dispatchEvent(event) &#123; event.target = this; let nodeChain = _getNodeChain(this); //先捕获 let captureNotCancel = _eventCaptrueTraverse( event, nodeChain); // event 这两个event不是要分开成2个单独的，因为如果第一个stopProgation之后，第二个也用的这个event //后冒泡 let bubbleNotCancel = _eventBubbleTraverse(event, nodeChain); // return NotCancel return captureNotCancel &amp;&amp; bubbleNotCancel; &#125;//获得路径function _getNodeChain(node) &#123; let nodeChain = []; nodeChain.push(node); let parent = node.parent; while (parent) &#123; nodeChain.push(parent); parent = parent.parent; &#125; return nodeChain;&#125;//冒泡流程function _eventBubbleTraverse( event, nodeChain) &#123; if(!event.bubbles)return true; for (let i = 0; nodeChain &amp;&amp; i &lt; nodeChain.length; i++) &#123; //如果stopPropagation之后，flag为true，停止传播 if (event._isStopPropagation) return false; if (i == 0) &#123; event.eventPhase = EVENTPHASE.TARGET; &#125; else &#123; event.eventPhase = EVENTPHASE.BUBBLE; &#125; let nodec = nodeChain[i]; let nodeKey = MD5(nodec); let queues = EVENTMAP[nodeKey] &amp;&amp; EVENTMAP[nodeKey][event.type]; for (let j = 0; queues &amp;&amp; j &lt; queues.length; j++) &#123; let fn = queues[j].fn; let useCaputrue = queues[j].useCaputrue; event.currentTarget = nodec; //如果stopImmediatePropagation之后，立即停止传播 if (event._isStopImmediatePropagation) return false; if (!useCaputrue) &#123; fn.call(nodec, event); &#125; &#125; &#125; return true;&#125; 我们通过parent属性得到链路数组，之后，从前到后，并从后到前循环这个数组，完成捕获与冒泡过程，如果中途有stopPropagation/stopImmediatePropagation则置位flag，停止事件流程，这样就回答了后面2个问题。 六.总结到此基本实现了一遍html的简单解析器，但是还有好多没做，比如removeNode API， 并如何处理removeNode之后的内存空间，其事件响应函数还没有被remove，DOM Level 0事件，属于属性事件，需要特殊处理，需要getter，setter等，相关的代码地址后续会贴出来。参考资料：从Chrome源码看浏览器如何构建DOM树从Chrome源码看浏览器如何计算CSS从Chrome源码看浏览器的事件机制浏览器的工作原理：新式网络浏览器幕后揭秘 dom深度尽量浅。不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。不要给类选择器指定标签，类，代表具有一类属性的标签，不仅是一个，虽然可以实现，但是降低了效率。避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp&gt;p{}避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）；","tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://07lyt.com/tags/前端基础/"}]},{"title":"一个模板引擎的简单实现","date":"2017-03-11T13:20:52.000Z","path":"2017/03/11/一个模板引擎的简单实现/","text":"模板引擎在后端直出，前端渲染都应用广泛，知道其原理对于理解渲染会很有帮助，比如ejs,dot,react的jsx解析到creatElement等，下面是一个简易的实现， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788export function template(templateStr, varialObj) &#123; //变量占位符 let placeHolder = /&lt;%([^%&gt;]+)?%&gt;/g; //non sense let scriptHolder = /&#123;=([\\s\\S]+?)=&#125;/g; //js 正则 let javaScriptReg = /^(\\s)?(if|for|else|switch|case|break|\\&#123;|\\&#125;)(.*)/g; let code = 'let r = [];'; let result = void 0; let cursor = 0; while ((result = placeHolder.exec(templateStr))) &#123; console.log('result: ', result); let matched = result[0]; let varialbelKey = result[1]; //htmlTag 打上引号 if (templateStr.slice(cursor, result.index).trim()) &#123; code += 'r.push(\"' + templateStr.slice(cursor, result.index).replace(/['\"]/g, '\\\\\"').replace(/[\\s]/mg, '') + '\");\\n'; &#125; //更新游标 cursor = result.index + matched.length; console.log('varialbelKey', varialbelKey); if (varialbelKey.match(javaScriptReg)) &#123; //是js let keys = Object.keys(varialObj); for (let j = 0; j &lt; keys.length; j++) &#123; if (varialbelKey.indexOf(keys[j]) &gt;= 0) &#123; //注意 这里ob是入参 varialbelKey = varialbelKey.replace(keys[j], 'ob.' + keys[j]); &#125; &#125; code += varialbelKey + '\\n'; &#125; else &#123; //是变量 code += 'r.push(ob.' + varialbelKey.replace(/\\s/g, '') + '||' + varialbelKey.replace(/\\s/g, '') + ');\\n'; &#125; &#125; code += 'r.push(\"' + templateStr.slice(cursor, templateStr.length).replace(/['\"]/g, '\\\\\"').replace(/[\\s]/mg, '') + '\");\\n'; code += 'return r.join(\"\")'; console.log('code is : ', code); // 利用Function /* example: code: let r = [];r.push(\"&lt;html&gt;\"); for(var i =0;i&lt;ob.arrylist.length;i++) &#123; r.push(\"&lt;li&gt;\"); r.push(ob.arrylist[i]||arrylist[i]); r.push(\"&lt;/li&gt;\"); if(ob.non)&#123; r.push(\"&lt;p&gt;prar&lt;/p&gt;\"); r.push(ob.ss||ss); &#125; &#125; r.push(\"&lt;div&gt;\"); r.push(ob.ss||ss); r.push(\"&lt;/div&gt;&lt;/html&gt;\"); return r.join(\"\") */ return new Function('ob', code.replace(/\\n\\r\\t/g, '')).apply(varialObj, [varialObj]);&#125;let templateStr = `&lt;html&gt; &lt;% for(var i =0;i&lt;arrylist.length;i++) &#123; %&gt; &lt;li&gt;&lt;% arrylist[i] %&gt;&lt;/li&gt; &lt;% if(non)&#123;%&gt; &lt;p&gt;prar&lt;/p&gt; &lt;% ss %&gt; &lt;%&#125;%&gt; &lt;% &#125; %&gt; &lt;div&gt; &lt;% ss %&gt; &lt;/div&gt;&lt;/html&gt;`;var outStr = template(templateStr, &#123; ss: 2, arrylist: [1, 2, 3, 4], non: 1 &#125;);console.log('out_str_is', outStr);/* out_str_is &lt;html&gt;&lt;li&gt;1&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;2&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;3&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;4&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;div&gt;2&lt;/div&gt;&lt;/html&gt;*/ 梳理一下： 利用强大的正则 利用Function的动态构造函数能力，使得if else等语句得以执行 参考文献：http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"webpack v1 概览","date":"2016-11-28T13:20:52.000Z","path":"2016/11/28/webpack1/","text":"目录 Webpack简介 Webpack常用概念 Webpack运行时 Webpack使用 Webpack进阶 通灵塔webpack编译优化（Dll/DllReference） 1. Webpack 简介Webpack 是德国开发者 Tobias Koppers 开发的模块加载器。核心的理念是，视各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块，来使用和处理。 webpack.config.js 配置1.entry2.output 123456789101112131415161718var path = require(\"path\");var webpack = require(\"../../\");module.exports = &#123; entry: &#123; main: \"./example\", common: [\"./vendor\"] // optional &#125;, output: &#123; path: path.join(__dirname, \"js\"), filename: \"[name].chunkhash.js\", chunkFilename: \"[chunkhash].js\" &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: [\"common\"] &#125;) ] &#125;; 2. Webpack 常用概念 模块(module) chunk 资源(assets) loader(资源加载) plugin 代码分割 2.1 模块模块间依赖关系网(js,css,png,node_module) 模块使用CommonJs管理，每个模块有一个模块id,一般情况下id为数字，但可以使用插件换成文件具体路径，以下为id为184的模块 /* 184 */ /***/ function(module, exports, __webpack_require__) { var Core = __webpack_require__(185); var NativeCore = __webpack_require__(194); var Network = __webpack_require__(196); var Promise = __webpack_require__(188); Core.prototype._mixin(Core.prototype, NativeCore); Core.prototype._mixin(Core.prototype, Network); Core.prototype.all = function(list){ return Promise.all(list); }; module.exports = Core; /***/ }, 2.2 chunk 上图打包成chunk之后得到3个chunk chunk是一个或多个源文件的集合，可以是js,css,png等，表现为一个数组，装载这些文件.chunk有父子概念， 多个chunk也可以包含同一个module模块. 一般来说每个entry产生一个chunk,但可以借助插件来改变chunk的依赖情况（后续commonplugin会涉及），父子chunk的表现为chunk执行前置后置的关系 网状的modules最后经过webpack整理最后会表现为一个chunk有一个modules数组，这个数组全是module,且由webpack理清了网状依赖关系一个chunk有多个\bmodule,平行的module 每个chunk也有一个唯一的id,并且有对应的flag entry:runtime initial:优化chunk render:normal chunk 没有runtime 2.3 assets即为最终项目中引用的文件，一个资源文件中可能含有一个或多个chunk，并且有一个或多个module，表现如下 window[&quot;webpackJsonp&quot;] = function webpackJsonpCallback(chunkIds, moreModules) {} 2.4 loaderwebpack中所有文件即模块，用loader将所有文件转换为模块，loader为资源加载器，对于每一类文件都需要设置loader。loader是一个函数，可以传递参数进行loader设置常用loader有： babel-loader css-loader style-loader url-loader file-loader ………… 2.5 pluginplugin用处广泛，是webpack的重要组成部分，利用plugin可以侵入编译过程，改变chunk的依赖关系常用plugin: CortexRecombinerPlugin CommonsChunkPlugin ExtractTextPlugin WebpackShellPlugin ………… 2.6 代码分割代码分割得到的结果类似于RequireJS，可以异步加载模块分割点： CommonJs：require.ensure(dependencies, callback) AMD：require(dependencies, callback) 对于被分割后的chunk,其依赖也在被分割后的chunk里面 3. Webpack运行时常用的有有3个方法： __webpack_require__ __webpack_require__.e= function requireEnsure(chunkId, callback) {} webpackJsonp= function webpackJsonpCallback(chunkIds, moreModules) 1. __webpack_require____webpack_require__方法用来同步加载已经安装过的模块，即执行一个模块中的代码，得到module.exports的值， 要运行的模块在打包的时候就已经打包进assets中，属于同步加载，影响文件体积 2. requireEnsure__webpack_require__.e=requireEnsure 用以支持code spliting，通过挂载script标签来异步加载模块，不影响文件体积。 3. webpackJsonp= function webpackJsonpCallback(chunkIds, moreModules) webpackJsonp方法用来安装模块，方法中chunkIds表示本assets中包含的chunk，为一个数组，可以有1个或多个id，列出的chunkid标志即将安装的chunkid，安装过的chunk在异步加载时可以直接调用，不再需要加载script标签，第二个参数为包含的模块，可以为对象或者数组，其中对象标志有模块对应的模块id，在执行后这些模块将被加载进内存，可以通过__webpack_require__(模块id)的方式调用 4. Webpack使用4.1 webpack.config.js配置 entry output module resolve externals target devServer plugin 4.2 loader test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 链式调用:css!postcss!less 传参数：css?modules!postcss!less require指定：require(“style-loader!css-loader!less-loader!./my-styles.less”); 编写loader 4.3 plugin插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: &quot;common&quot;, filename: &quot;common.js&quot;, minChunks: Infinity//当项目中引用次数超过2次的包自动打入commons.js中,可自行根据需要进行调整优化 }), new ExtractTextPlugin(&quot;[name].css&quot;, { // disable: env == &quot;dev&quot;, allChunks: true }), new CortexRecombinerPlugin({ base: path.resolve(__dirname, relativeToRootPath), noBeta:env==&apos;product&apos; }), new webpack.WatchIgnorePlugin([path.resolve(__dirname, relativeToRootPath, &quot;./node_modules/@cortex&quot;)]), new WebpackShellPlugin({onBuildStart: [&apos;gulp&apos;]}) ] 1.CommonsChunkPlugin （4种使用情形 改变chunk依赖） 打包多个入口的共同文件(多页或者是多个执行环境)从不同入口抽出多个公共的模块，考虑如下简单情形有2个没有引入该插件的entry,得到2个分立的chunk,查看module发现有些模块是重用的因此可以将这些公共模块抽出，引入CommonsChunkPlugin，得到：抽出了公共模块出来共享模块分配到一个新的chunk中了: 打包工具库文件(现有项目使用)zepto,react,………… 移动共同依赖模块(code spliting增加页面初始化时间) 针对code spliting产生多个chunk的情形，移动一部分共同的chunk到common中，减少异步请求次数，针对代码分割点比较多又小的情况 异步加载共有common chunk针对code spliting，移动一部分公共的代码块形成一个异步common chunk,没有增加页面初始时间，但会在某个分割点加载分割common代码 2.DedupePlugin 去冗余 3.OccurrenceOrderPlugin 重设模块id,使得高使用率的模块获得数字较小的id,表现为内存优先加载 4.UglifyJsPlugin js压缩 5.DllPlugin 用来生成动态链接库 6.DllReferencePlugin 用来引入动态链接库 7.CortexRecombinerPlugin cortex代码转换，移动 8.DefinePlugin 给代码中引入变量 9.ProvidePlugin 提供全局变量，而不用在每个入口require(‘zepto’)等 new webpack.ProviderPlugin({ $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;window.jQuery&quot;:&quot;jquery&quot;})] 10.HotModuleReplacementPlugin 热更新插件，需要配合webpack-dev-server 11.ExtractTextPlugin 抽取文本，文本不一定是css,除了有module.exports的js和json文件都可以算是文本 12.……………… 4.4 externals假如我们需要通过标签来引入jquery，并且要写一个jquery插件，并且写的这个插件要用webpack打包，可以使用下面的配置 module.exports = { output: { //target也可以为UMD libraryTarget: &quot;window&quot;, library:[&apos;jquery&apos;,&apos;custom&apos;] }, externals: [&quot;$&quot;, &apos;jquery&apos;] } 以上的output表示给window的jquery.custom对象挂上我们的插件模块 window[&quot;jquery&quot;] = window[&quot;jquery&quot;] || {}; window[&quot;jquery&quot;][&quot;custom&quot;] =XXX externals表示代码中遇到require(‘jquery’)或者require(‘$’)不进行依赖判断，直接输出 module.exports = window[&quot;jquery&quot;]; externals也可以写为对象的形式 externals: { &quot;jquery&quot;: &quot;jQuery&quot; } require(‘jquery’)等价为：window.jQuery，所有的jquery都会被解析为jQuery，在UMD模式下，如果有CommonJs模块，require(‘jquery’)会被解析为require(‘jQuery’)， require(&apos;jquery&apos;)=&gt;require(&apos;jQuery&apos;) 要注意此时的2个不同的require，第一个require为webpack中使用的require，第二个为CommonJs的require 4.5 非标准模块引入 shimming-modules imports-loader require(&quot;imports?xConfig=&gt;{value:123}!./file.js&quot;) 引入全局变量xConfig={value：123}给到file.js exports-loader暴露到变量中 require(&quot;imports?variable=&gt;{}!exports?variable.XModule!./file.js&quot;) 先引入变量variable={}给到file.js再暴露XModule在variable对象中 expose-loader暴露到全局 require(&quot;expose?XModule!./file.js&quot;) 4.6 热更新 热更新依赖2个模块，一个是webpack-dev-server，是一个npm包，提供socket，类似静态资源服务器，第二个为HotModuleReplacement，可以通过提供插件或者命令行的形式启动HMR，要启动HMR需要在每个entry中加入，webpack/hot/dev-server或者webpack/hot/only-dev-server,前者在热更新失败的时候会刷新整个页面，后者不刷新，如果更新失败，需要手动刷新 热更新原理： webpack-dev-server为通过webpack打包生成的资源文件提供Web服务。通过Socket.IO连接着webpack-dev-server服务器的HMR runtime。webpack-dev-server发送关于编译状态的消息到客户端，客户端根据消息作出响应。 可视化工具webpack analyse 官方工具模块详情：chunk详情： webpack visualizer 分析模块占比 Webpack Chart 5. Webpack进阶/总结5.1 调试 使用react-transform-hmr热更新react 选择性热更新 if (module.hot) { module.hot.accept(&apos;./components/App&apos;, render); } 服务端集成，koa结合webpack-middleware 5.2 代码编写 某些模块只加载一部分（lodash,zepto） 代码分割（按行为/按环境(微信，DPApp)） 整合css-sprite（sprity） 分析打包报告（stats.json 可视化工具） 6. 通灵塔编译打包速度优化随着通灵塔功能越来越强大，其背后引用到的第三方库也越来越多，文件也变得越来越大，如图所示，编译后的模块有1835个，公共库加index.js接近7MB，现在一次编译打包的时间要5-15秒不等，每次启动通灵塔项目都要花一些时间，虽然CommonsChunkPlugin解决了公共库的问题，但是每次webpack编译都要生成一遍公共库common.js，由于common.js里都是相对稳定的三方库，如react,react-dom等，这些三方库应该不需要每次都编译打包，因而可以使用DllPlugin + DllReferencePlugin来解决，通过DllPlugin生成稳定的DLL模块，并让webpack不对这些模块每次都编译打包 先在项目路径下引入webpack.dll.js，内容如下所示，通过webpack.DllPlugin引入DLL插件，DllPlugin不执行模块代码，只提供了模块的实现，具体的调用还得其他模块来进行，其他模块利用DLL插件生成的映射关系.json文件来进行模块调用，之后利用OccurenceOrderPlugin来重排模块id,增加模块命中概率，利用UglifyJsPlugin来压缩JS，因为这个dll最后还是要写在HTML中以script标签的形式引用12345678910111213141516171819202122232425var path = require(\"path\");var webpack = require(\"webpack\");module.exports = &#123; entry: &#123; vendor: ['./vendors.js'] &#125;, output: &#123; path: path.join(__dirname, \"dll\"), filename: \"dll.[name].js\", library: \"[name]\" &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, \"dll\", \"[name]-manifest.json\"), name: \"[name]\" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin() ], resolve: &#123; root: path.resolve(__dirname, \"\"), modulesDirectories: [\"node_modules\"] &#125;&#125;; 项目入口设置一个vendors.js文件，将稳定的模块都可以放入这个js中，最后执行webpack --config webpack.dll.js生成DLL dll.vendor.js，如下所示得到了一个压缩后1.75MB的dll文件，并且一共有1083个模块，之后在原有项目中再引入DllReferencePlugin插件,由webpack根据manifest.json映射文件生成调用关系1234new webpack.DllReferencePlugin(&#123; manifest: require(\"../dll/vendor-manifest.json\"), context: path.join(__dirname, '..') &#125;), manifest.json片段：123\"./node_modules/react/react.js\": 1, \"./node_modules/process/browser.js\": 2, \"./node_modules/moment/moment.js\": 3 再执行webpack命令，打包得到如下结果common.js+index.js不到3M，一次编译打包也只有857个模块，少了1000多个模块的编译打包，实测打包速度快了2秒左右，根据机器差异和机器资源使用情况webpack编译打包的时间应该能快上1-5秒不等。最后消失的模块都跑到dll.vendor.js中了，为了让页面正常运行需要在页面中引入这个dll之后页面正常运行~总结：使用DLL+DllReferencePlugin能在开发阶段节省每次编译打包的等待，在beta或者线上也可以节省脚本执行webpack命令从开始到结束的时间，但是需要再引入一个script标签，需要视情况使用DLL。 DLL相关代码已push到通灵塔app-yy-ziggurat-dashboard的dll分支 参考资料： http://webpack.github.io/docs/ http://engineering.invisionapp.com/post/optimizing-webpack/ https://github.com/petehunt/webpack-howto http://gaearon.github.io/react-hot-loader/ https://github.com/petehunt/webpack-howto#8-optimizing-common-code","tags":[{"name":"基础工具","slug":"基础工具","permalink":"http://07lyt.com/tags/基础工具/"}]},{"title":"koa-generator解析","date":"2016-08-28T13:20:52.000Z","path":"2016/08/28/koa-generator解析/","text":"目录 引言 解析 讨论 1.引言 在koa中，存在着大量的中间件，koa并不绑定任何中间件，许多功能都要靠中间件来进行实现， @dp/node-server基于koa，koa-router作为koa的一个基础中间件，在很多web应用都有用到。在node-server中用到的==action==本质也是用到了koa-router，因此koa-router与我们的关系还是很紧密的，理解其原理对于我们写action有一定帮助。 1.1 回顾co+generator koa通过co来组合不同的generator,使得我们的中间件可以串行化执行，并提供downstrem，upstream回溯的能力。 co这个库，将我们的异步操作都串行化，koa中间件执行核心，即是先把所有generator fuction反复包装，然后调用co.wrap同步化 在图1中，橙色的箭头表示yield一个generator function或者是yield一个generator的点，通过co，我们得以递归的执行generator或者generator function。虚线的箭头表示控制权的交出与交回，绿色表示控制权在不在本函数内部，一个请求的经过所有中间件的时间等于图1中最下面的长条的时间。在最后一个中间件之后不存在我们注册的中间件，yield会将控制权交给一个noop空的generator function。如果之前还有yield非generator的点，co会将相关array,object,thunkfunction转为promise,统一对promise进行处理，并等待promise的resolve，期间控制权在node中，直到resolve之后控制权才交回我们的函数。图1·co+generator 过程 相关代码片段每app.use一次加入一个中间件generator function到this.middleware这个数组中12345678910app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are not allowed, // so we have to make sure that `fn` is a generator function assert(fn &amp;&amp; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function'); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn);///////////加入一个中间件 return this;&#125;; 反复包装的过程，不断的将得到的generator作为参赛传递到==下一个 generator==中:12345678910111213function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next);//反复包装 &#125; return yield *next; &#125;&#125; 123456789101112131415app.callback = function()&#123; var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); var self = this; if (!this.listeners('error').length) this.on('error', this.onerror); return function(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).then(function () &#123; respond.call(ctx);//通过co执行中间件,执行完成在respond中处理this.body &#125;).catch(ctx.onerror); &#125;&#125;; 2.koa-router解析 中间件一般都分为注册和执行2个阶段，一般我们只用关心注册的阶段，在执行阶段，执行的控制流完全交给了co，我们只提供了执行的实现，执行的时机由co把控。 2.2 koa-router用法 router.get(&#39;/&#39;, function *(next) {…}) HTTP动词注册 router.use(&#39;/&#39;, function *(next) {…}) 路径匹配注册 router.register(&#39;/&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…}) 多HTTP方法注册 router.param(&#39;param&#39;,function *(next){…}) 命名参数注册对于1，2两种注册方法，其本质是调用了3这个注册方法，对于4注册方法，是与其它注册方法不同的另外一种注册方法。 2.3 koa-router数据结构图2展示了koa-router 的内部数据结构，Router作为我们直接使用的对象，暴露register等方法，图2中Router对象的stack属性作为一个集合保存了多个Layer,每个Layer保存了本层的注册路径，并引用了多个中间件generator function，在我们的应用中，即为Action。在图3中，展示了一个Router拥有4个Layer的情况。 图2·koa-router中间件类图图3·Router进行了4次注册的情况 2.4 koa-router注册中间件流程一开始的GET,POST,PUT等HTTP动词都是调用了register方法，包括@dp/node-server里面的注册，也是直接调用了register进行路由注册,以register为例，图4中用户一开始调用register,会在Router中创建一个Layer对象，之后再使用layer的param进行命名参数注册，最后将得到的layer加入队列。 图4·koa-router注册顺序图 koa-router注册中间件相关片段1234567891011121314151617181920212223242526272829303132333435Router.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var stack = this.stack; //-------------&gt; create route var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || \"\", &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; //-------------&gt; add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); /* …………………… */ //-------------&gt; 加入stack中，增加了一个Layer stack.some(function (m, i) &#123; if (!m.methods.length &amp;&amp; i === stack.length - 1) &#123; return stack.push(route); &#125; else if (m.methods.length) &#123; if (stack[i - 1]) &#123; return stack.splice(i, 0, route); &#125; else &#123; return stack.unshift(route); &#125; &#125;); &#125; return route;&#125;; 2.4.1 koa-router注册过程分解1.router.register(&#39;/dp/ac4&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…})在这一步，我们注册’/dp/ac4’这个路径，注册get,post方法，router的数据结构会如图5红色部分所示变化。 图5·注册一个非命名参数情形 2.router.param(&#39;user&#39;,function *(next){…})在这一步注册了一个命名参数中间件，这时koa-router会在所有layer中检查是否有对应命名参数的layer已经注册，如图6，在第三个layer中，注册了user命名参数，其会新增一个action的引用,指向新增加的命名参数中间件，即为图中的红色部分。在执行阶段，如果路径匹配，这个action就会得到执行。 图6·注册一个命名参数的情形 3.router.register(&#39;/dp/:user&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…})在这一步注册了一个带命名参数和路径的Layer，这时koa-router会在所有命名参数中检查是否有对应命名参数中间件已经注册，如图7中的==user==命名参数，如果已经有过注册，即会执行红色部分的注册过程，将引用指向已经注册过的命名参数中间件。 图7·注册一个带命名参数和路径的情形 2.5 koa-router中间件执行流程在注册完成以后，每来一个请求，就会进行中间件的执行，在请求到达我们的中间件之前，koa-router会依赖Path-to-RegExp进行路由路径的正则匹配，如图8所示，我们之前注册的路径通过红色部分的Path-to-RegExp组件将会转换为相应的正则表达式保存在各个Layer中，之后对于请求的路径，即会进行如图8所示的正则匹配，并获得相应的匹配结果。 图8·中间件执行前的处理在请求实际得到处理之前，会将所有符合请求路径与方法都匹配的路径筛选出，并进行中间件包装，包装过程与app.callback中的包装过程类似，每次传递generator到下一个中间件中，当所有Layer包装完成后，koa-router会交出控制权，由co来执行中间件函数。 图9·中间件执行前的处理图10中，如果HTTP的请求路径为’dp/ac1’，koa-router会将所有layer的路径进行正则匹配，如图，第一，二个匹配成功，在匹配完成之后，进行中间的包装过程，这个过程还会产生命名参数，包装过程从最后一个layer的最后一个action开始包装，依次传递generator，最后在包装完第一个layer的第一个action后得到一个generator，之后便可以将这个generator交于co来控制执行。 图10·中间件执行前的包装过程图11中，展示了有2个action（图中红色）匹配路径与方法的情况，在最下面的执行过程的白色部分，koa-router进行了中间件的包装，在包装完成之后，即橙色部分yield交出控制权，控制权交到了第一个action中，第一个action在执行完成或者执行中途，同样yield next在橙色部分将控制权交出到下一个action中，下一个action同样yield next将控制权交于相对于koa-router下一个中间件，之后控制权返回可以执行action剩余的动作。 图11·注册中间件执行过程 相关代码片段每次执行koa-router中间件的过程即是执行dispatch这个generator function的过程123456789101112131415161718192021222324252627282930313233343536373839 var dispatch = function *dispatch(next) &#123; var path = router.opts.routerPath || this.routerPath || this.path;//获得请求路径 var matched = router.match(path, this.method);//对本router中的layer进行匹配，得到匹配结果 var layer, i, ii;//加入上下文matched属性 if (this.matched) &#123; this.matched.push.apply(this.matched, matched.path); &#125; else &#123; this.matched = matched.path; &#125;//pathAndMethod为路径和HTTP方法都匹配的所有layer if (matched.pathAndMethod.length) &#123; i = matched.pathAndMethod.length; var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path this._matchedRoute = mostSpecificPath while (matched.route &amp;&amp; i--) &#123; layer = matched.pathAndMethod[i];//从最后一个layer开始压缩 ii = layer.stack.length; this.captures = layer.captures(path, this.captures);//构造上下文captures属性 this.params = layer.params(path, this.captures, this.params);//构造上下文命名参数 while (ii--) &#123;//对当前layer中所有的中间件进行压缩，从最后一个开始，压缩过程类似app.callback中compose的压缩过程，即不断的将generator传递 if (layer.stack[ii].constructor.name === 'GeneratorFunction') &#123; next = layer.stack[ii].call(this, next); &#125; else &#123; next = Promise.resolve(layer.stack[ii].call(this, next)); &#125; &#125; &#125; &#125;//交出控制权 if (typeof next.next === 'function') &#123; yield *next; &#125; else &#123; yield next; &#125; &#125;; 3.讨论我们的项目中的action，通常是一个generator function，==有一些接口没有写yield next==，由于我们的koa-router在@dp/node-server中是最后一个注册的中间件，所以不进行yield next影响也不大，但个人建议还是写yield next，如果今后在路由之后有进行this.body的处理，即koa-router不是最后一个中间件的情况，如果不写yield next，之后的中间件将会得不到执行；对于现在koa-router是最后一个中间件，即便写了yield next，控制流也会进入到一个内容为空的==noop==函数中，之后立即返回，对于执行逻辑不造成影响，所以建议还是在每一个action中写yield next~~。 参考资料：co: https://github.com/tj/cokoa: http://koa.bootcss.com/koa-router: https://github.com/alexmingoia/koa-routerpath-to-regexp: https://github.com/pillarjs/path-to-regexp","tags":[{"name":"node","slug":"node","permalink":"http://07lyt.com/tags/node/"}]},{"title":"domAPI/css","date":"2016-06-12T13:20:52.000Z","path":"2016/06/12/getBoundingClientRect/","text":"getBoundingClientRect的top的是盒模型上边缘与视口顶端的距离其bottom为盒模型下边缘与视口顶端的距离 text-shadow: h-shadow v-shadow blur color;水平方向，垂直方向","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"不一样的前端手指操","date":"2016-06-12T13:20:52.000Z","path":"2016/06/12/不一样的前端手指操/","text":"看见题目可能有点好奇，不过看下去你就知道什么叫手指操了~ 目录 引言 原理 核心库 实现 关键帧/图片调整 spritesheet progressbar 可能会遇到的问题 相关工具 访问地址 写在前面（特别注意）在移动端上做动画，一定不能用top,bottom,background-position等元素做动画,不管是JS动画还是CSS动画。主要是浏览器重排，重绘，合成等，只能用4个(需要加translateZ(0)开启GPU加速)：translate,scale,opacity,rotate。详细资料参考： 高性能动画 各CSS元素渲染情况 高性能 Mobile Web 开发 Rendering: repaint, reflow/relayout, restyle 引言毕业季没事做，一直都对视差滚动感兴趣，感觉很新鲜（虽然现在已经不火了）不过还是决定试试看，先看看效果。 片段演示（完整版访问地址在最后）片段演示 原理用了一点视差滚动的效果，可能不明显，关于视差滚动，与很多资料，本质是不同层的移动速度不同，比如坐火车时，远处的物体移动得慢，近处的物体移动的很快，我们就人为的实现这种速度的差异参考demo。 参考资料： 视差滚动原理介绍 Parallax Scrolling 视差滚动相关 视差滚动 如果再结合一些动画，就可以得到如下的比较cool的页面： 参考demo: http://tedxguc.com/ http://everylastdrop.co.uk/ http://nasaprospect.com/ 核心库为了实现上述的效果，选择了skrollr这个库，使用这个库，懂CSS就可以玩出这个效果了，用关键帧加CSS就可以了123456&lt;section class=\"scene1 fullpage\" data-6300=\"transform:translate3d(0,0%,0);display:block\" data-10000=\"transform:translate3d(0,-100%,0);display:block\" data-30000=\"transform:translate3d(0,-100%,0);display:block\" data-33000=\"transform:translate3d(0,-130%,0);display:none\"&gt;&lt;/section&gt; 总的来说，共使用了 skrollr 多用于桌面端，用在了移动端效果也不错，用起来很方便 zepto 不用多说 imagesloaded 图片预加载 相当简单nice 实现 关键帧/图片调整在skrollr初始化之前，需要对图片进行一些调整，首先选好了图片之 后，得保证显示在手机上不变形，因而需要根据不同的手机屏幕大小调整 图片的大小，然后再根据所得的图片设置一下结束的关键帧。 background是设置结束关键帧ratio是设置背景图片的比例 123456789101112$.plug.background(true,\".scene1-1\",6700,$.plug.ratio(true,1080,1920,\".scene1-1\"));$.plug.background(false,\".scene2-1\",18000,$.plug.ratio(false,4500,1667,\".scene2-1\"));$.plug.background(false,\".scene2-2\",22000,$.plug.ratio(false,4500,1667,\".scene2-2\"));$.plug.background(false,\".scene3-1\",42000,$.plug.ratio(false,3840,2160,\".scene3-1\"));$.plug.background(false,\".scene3-2\",48000,$.plug.ratio(false,3840,2160,\".scene3-2\"));$.plug.background(false,\".scene4-1\",58000,$.plug.ratio(false,2560,1496,\".scene4-1\"));$.plug.background(false,\".scene4-2\",62000,$.plug.ratio(false,2560,1496,\".scene4-2\"));$.plug.background(false,\".scene5-1\",76000,$.plug.ratio(false,2857,1216,\".scene5-1\"));$.plug.background(false,\".scene6-1\",112000,$.plug.ratio(false,800,800,\".scene6-1\"));$.plug.background(true,\".scenev-1-1\",94000,$.plug.ratio(true,600,1200,\".scenev-1-1\"));$.plug.background(true,\".scenev-1-2\",98000,$.plug.ratio(true,600,1200,\".scenev-1-2\"));$.plug.background(true,\".scenev-1-3\",102000,$.plug.ratio(true,600,1200,\".scenev-1-3\")); 如下所示，对于横向图片，以手机高度为准，先根据手机高度设置图片高 度，再根据图片比例设置图片的长度，对于纵向显示的图片，以屏幕宽度为准，手法类似，代码非常简单。 12345678910111213141516171819202122 (function($)&#123; function ratio(iswidth,width,height,dom,scale,isback)&#123; var ratioo=scale||1; var ratio=width/height; if(iswidth)&#123; var wi=window.innerWidth*ratioo; var numb=Math.round(wi/ratio); var _pxheight=numb+\"px\"; document.querySelector(dom).style.height=_pxheight; return numb; &#125; else&#123; var he=window.innerHeight*ratioo; var numb=Math.round(he*ratio); var _pxwidth=numb+\"px\"; document.querySelector(dom).style.width=_pxwidth; return numb; &#125; &#125; if(!$.plug)$.plug=&#123;&#125;; $.plug.ratio=ratio; &#125;)($) 一开始确定好容器大小，初始化一些白色的小型div,再通过CSS3动画让他们不停旋转，即是星星的感觉。再根据前景和背景的运动速度不同，造成视差滚动。对于动画，大多使用transform:translate3d，且以百分比做动画，以百分比做动画意味着是以自身元素为参照，不是父级元素，因而为了避免有些小型元素移动100%的距离只相当于移动了它自身大小的问题，将所有的元素都套在一个fullpage的div中: 1234567.fullpage&#123; width: 100%; height: 100%; position: absolute; left: 0; top:0&#125; 对这个嵌套元素进行移动，下面是各背景与前景，使他们以不同速度移动，可以通过设置不同的data-number值实现。 spritesheet对游戏制作的同学不会肯定不会陌生这样的代码一大堆，我贴个自己实现的，简单再说一下对于这个5793*158的spritesheet，如果在手机上显示高度为100px，则宽度为5793/1.58=3666px，则每次spritesheet移动的距离为3666px/36(动画一共有36帧）=102px，对应下面的JS代码中的interval参数，同时为了停止有个缓冲，加了个停止帧stopframe参数。123456789101112131415161718192021222324252627282930313233343536373839404142434445(function($)&#123; function animate(totaltime,dom,parts,interval,stopframe)&#123; var temp=0; var stop_flag=false; var timer=null; var num=temp*(interval); $(dom).css(&#123;\"background-position-x\":num+\"px\"&#125;); temp++; if(stop_flag&amp;&amp;temp===stopframe)&#123; clearInterval(timer),timer=null stop_flag=false; &#125; if(temp===parts)temp=0; return &#123; animating:function()&#123;return timer!==null?true:false&#125;, stop:function(va)&#123; stop_flag=true; //clearInterval(timer),timer=null &#125;, resume:function()&#123; if(timer!==null)return var str=$(dom).css(\"background-position-x\"); var matched=str.match(/-?[0-9]+/); var num=parseInt(matched[0]); temp=num/interval; timer=setInterval(function()&#123; var num=temp*(interval); $(dom).css(&#123;\"background-position-x\":num+\"px\"&#125;); temp++; if(stop_flag&amp;&amp;temp===stopframe)&#123; clearInterval(timer),timer=null stop_flag=false; &#125; if(temp===parts)temp=0 &#125;,totaltime/parts); &#125; &#125; //$(dom) &#125; if(!$.plug)$.plug=&#123;&#125;; $.plug.animate=animate; &#125;)($) progressbarprogressbar的实现使用了2个半圆的形式 利用border-radius：50%做一个圆，再利用clip: rect(0,auto,auto,50px)裁切为半圆。 之后再从垂直正中开始裁切clip: rect(0,auto,auto,50px);左半圆类似:将2个区域合并：加一个背景色相同的mask覆盖在中间，这样的好处是圆环宽度可以方便调整： 之后就可以通过代码设置其百分比： 12345678910111213141516171819202122 (function($)&#123; function circleprogress(dom,value)&#123; $(dom).each(function(index, el) &#123; var num = value * 3.6; num=Math.round(num); if (num&lt;=180) &#123; $(this).find('.right').css('-webkit-transform', \"rotate(\" + num + \"deg) translateZ(0px)\"); $(this).find('.right').css('transform', \"rotate(\" + num + \"deg) translateZ(0px)\"); $(this).find('.left').css('-webkit-transform', \"rotate(\"+0+ \"deg) translateZ(0px)\"); $(this).find('.left').css('transform', \"rotate(\"+0+ \"deg) translateZ(0px)\"); &#125; else &#123; $(this).find('.right').css('-webkit-transform', \"rotate(180deg) translateZ(0px)\"); $(this).find('.left').css('-webkit-transform', \"rotate(\" + (num - 180) + \"deg) translateZ(0px)\"); $(this).find('.right').css('transform', \"rotate(180deg) translateZ(0px)\"); $(this).find('.left').css('transform', \"rotate(\" + (num - 180) + \"deg) translateZ(0px)\"); &#125;; &#125;);&#125; if(!$.plug)$.plug=&#123;&#125;;$.plug.circleprogress=circleprogress; &#125;)($) 在滑动的过程中，配置好滑动的区间即可： 12345 if(data.curTop&gt;=20000 &amp;&amp; data.curTop&lt;25000)&#123; var num=Math.round((data.curTop-20000)/55); $('.circle-1').find('span.value').text(num); $.plug.circleprogress('.circle-1',num);&#125; 可能会遇到的问题 对于配置稍低的手机，比如我的4S，在场景越来越多，图片越来越多的情况下，不管是在微信中打开还是原生浏览器中打开，都会把微信和浏览器弄崩溃。。期间尝试了各种优化，把所有关于layout和paint的动画部分都替换，情况稍微好一些，但是还是有崩溃的现象。最后发现网页加载时要对所有的场景进行渲染，即便这些场景一开始并不需要出现。所以根据动画情况，将需要出现的场景动态显示，且在css中加入下面的语句,让所有场景及信息一开始都不渲染。123 .scene1,.scene2,.scene3,.scene4,.scene5,.scene6,.infomation&#123;display: none; &#125; 最后根据skrollr的值来选择显示的场景。 通过这样的做，我的4s终于再也不崩溃了，即便在有些低配手机还是有点卡。 相关工具 图片压缩 图像处理：不管是jpg还是 gif都能去除背景，强烈推荐，特别是gif功能，相当好用 字体 webfont/icon 图片处理：国内工具 再贴几个图像处理工具，都是在线的，相当不错 http://animizer.net/en/gif-apng-converter 很强大，有自动根据 gif生成spritesheet的功能，不过有时候生成的效果不大好 http://www190.lunapic.com/editor/?action=transparent http://ezgif.com/ 这些图像处理网站后台可能用的的是imagemagick（瞎猜的） 作为一个程序员如何找图片及配色 图片:都是免费无水印，但是还是自己用就好了 设计导航 wallhaven: 高分辨率大图 dribbble：不用多说 很多素材都来自这，也有很多gif freepik gif: gif集合 vectorhq Pinterest 站酷 freevectors icon freevec 配色:本人喜欢flat扁平化的风格，所以都是相关的颜色 flat ui colors coolors flatuicolorpick material design flatcolors 先在上面的网站找些喜欢的颜色 然后再去下面的网站生成相关的互补色等colorhexa：颜色分析，输入一个颜 色，分析其各属性paletton：相当 好用的选色工具，还可以看效果 访问地址 用手机看直接点这里访问（也可以打开调试器看看效果）","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]}]