[{"title":"Route路由端口","date":"2019-07-04T02:20:52.000Z","path":"2019/07/04/Route(第4章)/","text":"第Route\b路由端口 正文：本节将系统介绍React-Router的路由器端口Route，Route是React-Router体系中极为重要的一个模块，在React-Router中起到“引路”的作用，本章就将系统阐释React-Router中的Route。 4.1.Route是什么？一般可认为Route定义了路由路径匹配成功后的一系列动作。Route是一个react组件，定义了路由匹配成功后，该渲染的组件，其本质为一个高阶组件。 什么是高阶组件？如果一个函数操作其他函数，即将其他函数作为参数或将函数作为返回值，将其称为高阶函数。高阶组件(high-order component)类似于高阶函数，接收 React 组件作为输入，输出一个新的 React 组件。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对 render 方法作劫持，也可以控制 props 与 state。所以我们的Route只是做了一些路由的逻辑处理，他将严格渲染我们传入的组件。在React-Router第4版本以后，route的底层设计已经从静态配置的方式演化到动态渲染的方式，也就是在React-Router第4版后，一切都是组件，这带来的是动态化的好处，现在是运行时进行路由匹配，我们可以在运行时改变路由属性，适配复杂场景，如media query动态改变路由，或者运行时移除路由，注入路由等。 4.2.Route的两个基本要素路由器端口Route有2个最基本的要素，分别是 1.path2.组件渲染方式在之前的章节中我们知道Route写好path和component这2个属性之后，Route的定义就结束了，其中path我们用来定义应该匹配哪个浏览器路径，component用来定义匹配路径成功后应该渲染的组件。以上2个组件属性就构成了一个路由Route最基本的要素。我们总结其本质为: 匹配进而渲染。 4.3 Route的第一个要素：path路径React-Router的path匹配按书写格式可有3三种方式，分别为 1.符合Express路径格式的字符串2.带参形式3.综合形式 Express 是什么？Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 对于第一种基本的路径path，即为我们常用的location.pathname，浏览器的path部分，我们只需要定义好我们自己需要的path即可，并可适当加入一些正则表达式规则对于第二种路径写法，React-Router为我们规定好了在路由中带参的方式，只需要遵循一定的格式即可对于第三种路径写法，可以在第二种的基础上带上一定的正则表达式约定，得到约束性强的path路径 4.3.1 path-to-regexRoute自身没有实现路径匹配的逻辑，而是使用了一个成熟的三方库path-to-regex用来做路径匹配，这个库在node框架如Express，nuxt中被广泛使用。我们写的path能被path-to-regex识别为一个合法path即可。本质上path-to-regex做的是路径的正则表达式匹配，但是其提供了方便的路径定义规则，其在内部帮我们做了路径到正则表达式的转换，使得我们不用关心复杂的正则表达式表达式就能写出一个灵活性高的匹配路径，我们以react-route使用的path-to-regex1.7版本为例：其typescript定义的path为1export type Path = string | RegExp | Array&lt;string | RegExp&gt;; 即为字符串与正则表达式表达式或者两者的混合数组官方将path的类型限定为了string|string[],不可传正则表达式，减去了正则表达式的部分，并且对于数组类型的path，我们得到的是”或”的关系，所以数组中任意一个路径path匹配成功都将使得整个数组path匹配成功，如：1&lt;Route path=&#123;[\"/users/info\", \"/profile/info\"]&#125; component=&#123;User&#125; /&gt; 只要任一/users/info或者/profile/info命中就可以。所以我们介绍单个string类型的path即可 4.3.2 三种合法的path:4.3.2.1 符合Express路径格式的字符串1.基本匹配：123&lt;Route path=\"/user/info\" component=&#123;ReadMe&#125; /&gt;&lt;Route path=\"/a/b/c\" component=&#123;ReadMe&#125; /&gt;&lt;Route path=\"/readme.md\" component=&#123;ReadMe&#125; /&gt; 在这里path中的”.”字符不会认为是正则表达式中的”.”号规则，也就是能匹配浏览器的/readme.md路径 对于 “-“ 和 “.”字符，这将作为常规路径字符，不作为正则表达式字符，不计入path-to-regex库的路由匹配的规则中。 如果一个Route的没有传入path参数，这个Route将会永远匹配成功，如下：1&lt;Route component=&#123;About&#125; /&gt; About组件将永远得到渲染，正在某些场景下会很有用，我们之后有章节会进行介绍。 2.正则表达式匹配：Express路径格式除了常用的路径完全匹配以外，还有正则表达式字符 ?, +, *, ()等作为路径的附属匹配，也就是说我们可用这些字符辅助我们的path匹配。 对于正则表达式字符 “*”，“(”，“)”， 如果我们也想对这些字符串进行匹配，需要进行转义，否则这将被视为正则表达式规则的一部分，不转义将与我们期望的结果相悖。 对于正则表达式匹配场景，我们可以在path中写上正则表达式字符所对应的规则，在需要正则表达式匹配成功的路径部分需要加上圆括号，如：1&lt;Route path=\"/a(b)?cd\" component=&#123;ReadMe&#125; /&gt; 这将对b这个字符作正则表达式处理，匹配0个和1个b字符，即为能匹配到/acd和/abcd，同理：/a(b)+cd能匹配1个和多个b字符，如/abcd,/abbcd,/abbbbcd等/a(b)*cd能匹配0个和多个b字符，如/acd,/abcd,/abbbbcd等在没有圆括号的情况下，*将匹配0个或者多个任意字符，注意也包括路径分割符“/”，如以下路由路径：1&lt;Route path=\"/ab*cd\" component=&#123;ReadMe&#125; /&gt; 将匹配/abcd,/abbcd,/abccd,/ab/acd等 4.3.2.2 参数匹配1.命名参数匹配：我们通过可以提供一个冒号加参数的形似，如/:foo/:bar，来进行参数化路径匹配，这样我们可以在路径中获得相关的路径信息，这种路径的设计方式在restful比较常用，如当我们路由到/abc/1时，/:foo/:bar会成功匹配并且得到如下的一个对象：1234&#123; foo:'abc', bar:'1'&#125; 在后面的章节我们会介绍，在props.match.params可以拿到我们最后匹配到的路由对象2.非命名参数匹配：如果我们在path中加入中括号“(”，“)”，里面写上我们需要的正则表达式，如我们想要匹配/a后面是数字的情况：1&lt;Route path=\"/a/(\\d+)\" component=&#123;ReadMe&#125; /&gt; 这时我们的正则表达式匹配会生效，会匹配诸如/a/123,/a/456的路由路径，同时我们的得到的匹配变量会用下标代替：1234// /a/(\\d+) 匹配 /a/123&#123; 0:'123'&#125; 如果我们使用之前所述过的*号，由于*将匹配0个或者多个任意字符，这里也会得到非命名参数，如：1&lt;Route path=\"/a/*\" component=&#123;ReadMe&#125; /&gt; 那么对于路径/a/123,也会得到开始同样的匹配变量，但要注意，*号匹配会匹配任意的字符，包括路径分割“/”，如果我们有路径/a/b/c，那么对于/a/*的匹配，得到的非参数化对象将会是：1234// /a/b/c 路径 匹配 /a/*&#123; 0:'b/c'&#125; 这种情况需要注意。 4.3.2.3 综合匹配此外在参数化路径匹配时，我们也可以结合正则表达式符号*，+，?做正则表达式扩展，如:1./:foo/:bar?，表示bar参数为0个或者1个，即/abc或者/abc/1都将命中2./:foo/:bar+，表示bar参数为1个或者多个，即/abc/1或者/abc/1/2都将命中这个参数路径，他们各自的命中产生的变量分别是:1234&#123; foo:'abc', bar:'1',&#125; 1234&#123; foo:'abc', bar:'1/2',&#125; 3./:foo/:bar*，表示bar参数为0个或者多个，与+类似，但是它还能匹配命中/abc的情形，即为不匹配bar,4.如我们需要限定/:foo/:bar中的bar为数字，可以将/:foo/:bar写为/:foo/:bar(\\d+),这样/abc/efg将会匹配失败，只有/abc/1，第二个参数是数字时才能匹配成功，即为我们进行变量匹配规则限制。 在Express的路径风格中，如果我们需要类似正则表达式关键字的字符串作为路由，需要加上转义符号\\，不然这个这个字符串的正则表达式化将会报错，如/user 需写为 /\\user 任何合法的path路径我们也可以在路由路径测试匹配页面进行测试http://forbeslindesay.github.io/express-route-tester/ 4.4 Route的第二个要素：渲染方式从我们能掌控的路由控制范围从小到大排序，分别是通过component属性渲染，通过render属性渲染，通过children属性渲染。通过component属性渲染我们获得路由渲染的控制力度较小，通过render属性渲染能获得一定自由度，通过children属性渲染能获得完全开放的自由度 4.4.1 通过component属性渲染每一次路径变化，都会进行一次渲染，如果路径匹配成功，就将传入的组件通过React.createElement方式进行创建，并且注入match,location,history变量，进行Route的渲染工作，如果路径匹配失败，高阶组件Route则会返回null,销毁我们传入的component组件，这时页面dom会消失。1&lt;Route path=\"/acd\" component=&#123;ReadMe&#125; /&gt; 当我们的路径如/abcc时，我们通过component渲染的组件将不会被渲染，例如我们有一个从路径/acb跳转到/abcc，那么们通过component渲染的组件将会执行componentWillUnmount生命周期，进而销毁，这在一些情况下可能是我们所期望的，因为再次回到这个页面的时候，组件会重新渲染，进行componentDidMount，这样我们得以再次进行初始化的操作。但是在一些情况，我们有可能不希望组件销毁，不希望dom消失，比如用户上传过大量图片已经通过createUrl展示了出来，如果销毁dom,我们需要在内存中保存这些url以便恢复的时候重新渲染,或着一些编辑程度很强的页面，如果我们让dom消失，比起保留dom,恢复dom的代价要远远大得多。这就需要我们考虑其他办法 4.4.2 通过render属性渲染通过render属性渲染我们能自行接管React.createElement的行为，在匹配成功后,我们可以通过函数组件的形式，渲染对应的组件。相对于1中的通过component进行渲染，我们能控制注入进组件中的props参数。123456&lt;Route path=\"/a/b/c\" render=&#123;(props)=&gt;&#123; &lt;Component &#123;...props&#125;/&gt; &#125;&#125;/&gt; 如果某些情况我们需要更改传入进组件中的props参数的话，我们可以使用此种方式。比如我们此刻能拿到路由中的location，我们可以包装history.push，history.replace等方法，使得业务侧无感知，但是我们可以在跳转过程中加入hook等。Hook示例：1234567891011121314151617// 利用render渲染方式改变传入的history&lt;Route path=\"/a/b/c\" render=&#123;(&#123;history,...rest&#125;)=&gt;&#123; const newHistoryPush = (...args) =&gt; &#123; if(typeof args[0] === 'string' &amp;&amp; args[0] !== '/a/b/c')&#123; //这个时候就是我们离开/a/b/c的时候 &#125; history.push(...args) &#125; const newHistory = &#123; push: newHistoryPush, ...history &#125; return &lt;Component &#123;...props&#125; history=&#123;newHistory&#125;/&gt; &#125;&#125; /&gt; 这样当我们调用history.push()离开当前路由的时候，就会执行newHistoryPush，我们可以在函数中插入想要的逻辑。或者某些情况下需要屏蔽一些路由细节，我们可以修改this.props.location后再传入对应的业务组件中，这时对应的业务只能感知到我们修改之后的匹配信息，也可以套入统一的高阶组件，比如，权限等，比如：12// 高阶组件Permission控制组件&lt;Route path=\"/home\" render=&#123;(props) =&gt; &lt;Permission code=&#123;123&#125;&gt;&lt;Component &#123;...props&#125;/&gt;&lt;/Permission&gt;&#125;/&gt; 这个时候我们的组件可以受到高阶组件Permission的控制 4.4.3 通过children属性渲染通过children属性渲染拥有最高的控制权，我们的组件将无条件被渲染，如下所示：1234// 无条件渲染Component&lt;Route children=&#123;(&#123; match,location,history &#125;) =&gt; ( &lt;Component/&gt;)&#125;/&gt; 或者123456// 无条件渲染Component&lt;Route&gt;&#123;(&#123; match,location,history &#125;) =&gt; ( &lt;Component/&gt;)&#125;&lt;/Route&gt; 当我们返回Component组件，Component就会被渲染，Route只是给我们注入了三个参数match,location,history，渲染的工具交给我们，而不是有条件的渲染。同时由于React-Router把该注入的三个参数交给我们，这给了我们很大的发挥空间，我们可以用注入的三个参数做一些其他渲染方式没法做到的逻辑。笔者一开始遇到一个业务逻辑，完全没有路由跳转，但是后面要加上路由跳转，怎么加？就可以使用children属性，假如我们已经写了一个通过visible属性来控制弹窗可见的组件，我们的一个父组件通过state来控制其弹出关闭，如果产品希望用户一打开就能弹窗，并且不改变原有url结构，只是新增如果要改成通过路由控制弹出关闭的话，非常简单，使用children进行渲染我们的这个组件，如下，我们为这个组件设置一个匹配path1&lt;Modal visible=&#123;this.state.visible&#125;/&gt; 通过改成路由形式，我们可以通过改变url进行弹窗控制1234567// 用match来做Modal弹窗控制&lt;Route path=&#123;`&#123;props.match.params.path&#125;/modal-A`&#125; children=&#123;(&#123;match&#125;)=&gt;&#123; &lt;Modal visible=&#123;match&#125;/&gt; &#125;&#125;/&gt; 这样也是动态路由，路由path不是静态配置好的通过children渲染，我们可以有更多的控制，在一些页面间过渡方面，我们可以使用children。假设我们当前的组件注入了路由传入的props,能获取到match参数，那么假如当前匹配渲染的路径path是/a/b，那么只需要把路径改成/a/b/modal-A，我们的弹窗便会弹出，且/a/b对应的原页面也存在并且不受路由变化影响。后面我们可以使用这个属性做一些有趣的事，比如把switch改造为保留dom的switch 4.5 路由的三个props4.5.1 match4.5.1.1 match的4个属性match一般从props.match获得，在render和children渲染方式上也可获得match对象，match对象具有如下4个属性： params isExact path url1.其中match中的一个属性params是一个对象，记录了参数化配置时，路由匹配出的键值对，如：1&lt;Route path=\"/user/:name\" component=&#123;User&#125; /&gt; 如果路由路径为/user/tom,则我们能从User的props中得到，props.match.params:123&#123; name:'tom'&#125; 如果我们加上得有限制，比如：1&lt;Route path=\"/ages/:age(\\\\d+)\" component=&#123;Age&#125; /&gt; 那么只有第二个参数是数字才能匹配上，如/ages/18，注意如果是非数字，如/ages/jim，则match为null,匹配视为失败。2.match中的第二个属性为isExact，表示为是否是完全匹配中，如果我们路由注册的path是/a/b，那么在Route的exact是false的情况下，我们的路由在路径为/a/b/c的情况下也能匹配中，但是isExact为true的话，只能进行精确匹配了，路由path为/a/b将无法匹配中/a/b/c。3.match中的第三个属性为path，即为路由的匹配path，不是真实的url，通常用于嵌套路由中，作为父子路由予以使用，如我们需要在某个子页面中使用子路由，但由于React-Router从第4版开始，Route的path规则就需要完全路径形式，不能再像第3版一样，只要写子路由，如/a/b/c，只用写子路由/c部分，那么要满足这种场景我们可以使用父路由传入的match中的path字段，这个字段记录了父路由配置命中后，父路由的path部分，此刻我们可以使用props.match.path作为子路由完全路径中的父路由部分，如：12345678// 利用匹配中的path做二次匹配 &lt;&gt; &#123; props.match &amp;&amp; &lt;Route path=&#123;`&#123;props.match.params.path&#125;/c`&#125; component=&#123;SubComponent&#125; /&gt; &#125; &lt;/&gt; 注意：props.match可能为null，即为父路由没有匹配中的情况，我们可视情况判断 由于Route是动态渲染，所以对应的Route组件也会得到渲染并进行一次路由匹配，当路由匹配命中后，对应的SubComponent就会进行实例化，作为组件进行渲染。4.match中的第四个属性为url，为真实的url匹配中的部分. 在嵌套导航中 我们可以使用一方面这个url可以用来确认history.location.pathname有什么不同，另一个方面也可以用来作为二级Link导航的父导航部分，如果我们希望浏览器路由在当前路径下增加一级路径，但是我们不知道当前路径具体是如何的时候，可以使用match.params中的url，如：12// 利用匹配中的params&lt;Link to=`$&#123;props.match.params.url&#125;/c` /&gt; 如果当前路径为/a/b，这将会使浏览器导航到/a/b/c下 4.5.1.2 没有命中路由时match的情况考虑一种情况，利用children进行无条件渲染，同时子组件传入一个无path的Route组件，我们看看子Route的渲染情况：1234567// when location.pathname is /matches&lt;Route path='/does-not-match' children=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;Route render=&#123;(&#123; match:pathlessMatch &#125;) =&gt; &#123; // can not render return &lt;div&gt;123&lt;/div&gt; &#125;&#125;/&gt;&#125;&#125;/&gt; 我们之前说过没有写path的情况下，Route将会视为匹配成功，即为Pathless的Route，将会渲染对应组件而不关心路由路径。但是在上述情况，我们嵌套的Route事实上是无法成功匹配的，即为在路由路径为/matches的情况下，我们并不会得到渲染得到123。这是因为对于无路径的Route，如果嵌套使用在一个父Route中，其match对象将会继承父Route的match对象，所以上述例子中父match对象为null，我们继承得到的pathlessMatch也是null，由于我们使用的是render渲染，是match不为空的时候才得到调用，所以我们的组件自然无法渲染出来，想要这种情况得到渲染，我们需要写明path，而不能写一个没有path属性的Route，或者这个时候我们使用children属性进行无条件渲染。 4.5.2 location:location一共有5个参数，如下对象所示:12345678910&#123; key: 'ac3df4', pathname: '/somewhere' search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 其中key在hash路由下不存在，为null，在浏览器路由中为一个hash值，我们在后面的原理部分会描述key的作用及产生原理。location顾名思义即为位置，pathname为浏览器路由的path部分，如https://www.github.com/a/b/c中的/a/b/c部分。参数中search为路径的query部分，注意这里包括”?”号，hash为路由的hash部分，注意包括了”#“号，还有一个state，是作为pushState api中可以push的状态，在浏览器路由中，我们可以使用这个字段作为信息传递，如果当前的路由模式为hash路由，情况稍有不同，我们的路由部分将从”#”号后开始计算，也就是忽略了location.pathname，只使用浏览器hash部分计算路由，如：https://www.github.com/a/b/c?d=1#/user,React-Router中的location.pathname为/user,从“#”号后开始计算路由。对于浏览器query,React-Router并没有帮我们解析成一个对象，我们只能从路由中得到’?some=search-string’这样的字符串，不过我们可以借用URLSearchParams对象轻松实现，如：1let params = new URLSearchParams(location.search); 对于Route我们可以自行传递location给Route，那么什么情况下传递location下去呢？有些场景可能在某些情况我们把Route置于某个父容器中，而这个父容器希望缓存我们Route的状态的时候，我们可以把当前拿到的location传入Route，父容器接管了Route后，由于父容器可以控制子容器的渲染，父容器可以先缓存location状态一段时间，再变化，如果不传入location进Route的话，那么Route将从context中取到最新的location,我们的状态也就无法缓存了，这个场景在实战部分路由动画中会有介绍 4.5.3 history:history，即为我们在之前章节Router中介绍过的history，注意history为可变mutable的，在官方文档中，如果有以下匹配：1234567891011class Comp extends React.Component &#123; componentDidUpdate(prevProps) &#123; // 推荐使用 will be true 将会永远为true，表明每次得到的location是不同的，location是一个immutable对象 const locationChanged = this.props.location !== prevProps.location; // 不推荐这样使用，history是可变的，每次都是传递同一个history下来，而这个history是可变的，可能在某处这个history的某些属性会某些原因人为变化，所以不推荐这样使用，INCORRECT, will *always* be false because history is mutable. const locationChanged = this.props.history.location !== prevProps.history.location; &#125;&#125;&lt;Route component=&#123;Comp&#125;/&gt; 由于history对象不由React-Router维护，也即为创建后便交给开发者使用，开发者可以改变history对象，对象是可变的，所以这个对象是mutable的。自history对象创建完毕，React-Router就将其透传到业务中，所以每次得到的history都是相同的，而不像props.location，是不可变immutable的，这确保了每次得到的都不同，由于React建议的状态管理都是immutable不可变的，因而建议在React-Router中获取location时可以使用Route的props的方式来替代history.location的方式。这样的方式会确保我们的流程处于React的生命周期中。 什么是mutable对象?一个在创建后可以改变的对象是mutable对象，反之在创建后不可改变的对象是immutable对象。 这里的history为browser-history，hash-history，memory-history中的一种，我们在Router章节有介绍。这里的history即为Router中history透传下来的history，api接口与之前介绍的一致。","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"可视化项目依赖分析工具pylon","date":"2018-05-02T13:20:52.000Z","path":"2018/05/02/pylon/","text":"做了一个工具，用于可视化形式分析项目依赖关系，分析文件结构，分析循环引用，查看指定依赖规则等pylon名称取自星际争霸神族水晶塔，意在为项目提供支持https://github.com/PylonFE/Pylon demo(gif): 主要用到d3画图与typescript的api useage: 12345npm install pylonnoryarn add pylonnthendependence -p ./src","tags":[{"name":"工具 d3","slug":"工具-d3","permalink":"http://07lyt.com/tags/工具-d3/"}]},{"title":"用js实现一门简单语言","date":"2018-02-27T13:20:52.000Z","path":"2018/02/27/用js实现一门简单语言/","text":"1.前言假如我们要来实现一门语言，语言有int,string,char,bool等类型，写其他类型会报错用~表示字符串，支持常见表达式，for循环，条件语句，注释等，每个语句需要;结束且函数定义用关键字def,类似于js的function,函数调用利用invoke关键字，如下面的声明了一个函数logParam,接收一个参数，函数体调用函数log，入参是a123def logParam(int a)&#123; invoke(log,a); &#125; 示例代码parse_compiler\b 2.目标给入下面一段程序片段，我们希望用js写出编译器，得到对应的结果123456789101112131415161718192021222324//定义log def logParam(int a)&#123; invoke(log,a); &#125; //定义累加 def accu(int begin,int end,int skip)&#123; int accu= 0,a; for(a=begin;a&lt;=end;a=a+1)&#123; if(a == skip )&#123; &#125; else&#123; accu = accu+a; &#125; &#125; return accu; &#125; // 空格需要 string a = ~iAmString~ ; int b = invoke(accu,0,50,0); invoke(log,a,b); invoke(logParam,123421212,a); //从0加到100，跳过10 invoke(log,invoke(accu,0,100,10)); 3.词法分析这一步主要是分析出程序片段的token，即单词片段，意为最细粒度单词单元对于上面的语言，我们需要定义一些概念，哪些是关键字，哪些是类型定义我们定义一些静态tag，除开符号; ) (等以外，所有的有意义token都有对应的tag12345678910111213141516171819202122232425262728293031323334353637export default class Tag &#123; static BASIC = 'BASIC'; static IF = 'IF'; static FOR = 'FOR'; static ELSE = 'ELSE'; static WHILE = 'WHILE'; static AND = 'AND'; static OR = 'OR'; static LE = 'LE'; static LEE = 'LEE'; static GEE = 'GEE'; static NOT = 'NOT'; static GE = 'GE'; static MINUS = 'MINUS'; static DO = 'DO'; static ID = 'ID'; static NUM = 'NUM'; static SWITCH = 'SWITCH'; static CASE = 'CASE'; static ASSIGN = 'ASSIGN'; static BREAK = 'BREAK'; static REAL = 'REAL'; static EQUAL = 'EQUAL'; static NE = 'NE'; static TRUE = 'TRUE'; static FALSE = 'FALSE'; static NOTE = 'NOTE'; static COMMENT = 'COMMENT'; static DIVIDE = 'DIVIDE'; static DIVIDEE = 'DIVIDEE'; static ADD = 'ADD'; static SUB = 'SUB'; static MUTIPLE = 'MUTIPLE'; static RETURN = 'RETURN'; static DEF = 'DEF'; static INVOKE = 'INVOKE';&#125; 再来定义单词下面定义了部分单词，有意义的token都可以作为word123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import Token from './token.js';import TAG from './tag.js';import Tag from './tag.js';export default class Word extends Token &#123; constructor(value, tag) &#123; super(tag); this.value = value; &#125; static and = new Word('&amp;&amp;', TAG.AND); static or = new Word('||', TAG.OR); static less = new Word('&lt;', TAG.LE); static greater = new Word('&gt;', TAG.GE); static greater_equal = new Word('&gt;=', TAG.GEE); static less_equal = new Word('&lt;=', TAG.LEE); static equal = new Word('==', TAG.EQUAL); static assign = new Word('=', TAG.ASSIGN); static not = new Word('!', TAG.NOT); static not_equal = new Word('!=', TAG.NOTE); static divide = new Word('/', TAG.DIVIDE); static divide_equal = new Word('/=', TAG.DIVIDEE); //保留字 static if = new Word('if', TAG.IF); static for = new Word('for',Tag.FOR); static else = new Word('else', TAG.ELSE); static while = new Word('while', TAG.WHILE); static do = new Word('do', TAG.DO); static switch = new Word('switch', TAG.SWITCH); static true = new Word('true', TAG.TRUE); static false = new Word('false', TAG.FALSE); static def = new Word('def', TAG.DEF); static invoke = new Word('invoke',TAG.INVOKE); static return = new Word('return', TAG.RETURN); toString() &#123; return this.value; &#125;&#125;export const RESERVEDWORDS = [ Word.if, Word.else, Word.while, Word.do, Word.switch, Word.true, Word.false, Word.def, Word.invoke, Word.for, Word.return].map(ele =&gt; &#123; return ele.toString();&#125;); 再来定义类型,类型作为单词的子类，也是单词的一种我们定义int，bool等类型123456789101112131415161718import Word from './word.js';import Tag from './tag.js';export default class Type extends Word &#123; constructor(value, length) &#123; super(value, Tag.BASIC); this.value = value; this.length = length; &#125; static int = new Type('int', 1); static bool = new Type('bool', 1); static float = new Type('float', 8); static char = new Type('char', 1); static string = new Type('string', 8); toString() &#123; return this.value; &#125;&#125;export const TYPEWORDS = [Type.string , Type.int, Type.bool, Type.float, Type.char].map(ele =&gt; ele.toString()); 分析分析token比较简单，我们从程序的第一个字符开始，按照从左至右，从上到下的顺序，依次输入进词法分析器1.遇到字母，即保存，遇到第一个非标识符组成字符就停止，如果得到的一串是保留字，就new一个保留字的token,如果不是保留字，那么作为标识符保存，遇到, ; ） （ {等就作为一个普通的token保存2.如果遇到数字，如果遇到.或者数字都可以进行下去，如果数字后遇到.,说明是小数，可以保留下来用parseFloat处理3.如果遇到/,那么后续有可能是/= // /*所以要根据后一个字符来判断是什么token如果是// /*前者需要正则匹配到换行，更改游标，后者需要匹配第一个*/，再更改游标4.类似的还有&gt;= &lt;= != == || &amp;&amp;都要匹配到&gt; &lt; ! = | &amp;再向后看一个字符5.遇到空格，换行 我们可以不做处理，直接绕过 之后我们可以得到一系列token串 12345 function addA(d) &#123;return a + d;&#125; 以分析下面的函数定义为例运行我们的词法分析，得到123def logParam(int a)&#123; invoke(log,a);&#125; 能得到下面的一些token 3.语法分析123function addA(d) &#123; return a + d;&#125; 一个函数声明的语法树 每一个语句，都有具体的组成部分我们先把语言拆开 可以得到下面的parse有些是parse一个表达式，有些是parse一个标识符，有些是parse一个类型等，还需要知道ast节点，如函数调用是，有callee和arguments两部分12345678910export class CallExpression &#123; // readonly type: string; // readonly callee: Expression | Import; // readonly arguments: ArgumentListElement[]; constructor(callee, args) &#123; this.type = Syntax.CallExpression; this.callee = callee; this.arguments = args; &#125;&#125; 我们还要定义一些移动函数，用以移动token，输入进入语法解析器我们在移动过程中跳过注释1234567891011121314151617181920212223242526272829move() &#123; // debugger do &#123; this.index++; this.lookahead = this.tokens[this.index] || &#123;&#125;; // 我们在移动过程中跳过注释 &#125; while (this.lookahead.tag === Tag.COMMENT); &#125; error(s) &#123; throw new Error( 'near line : ' + s + ' ' + this.lookahead.value || this.lookahead.tag ); &#125; match(t) &#123; if (this.lookahead.tag == t) &#123; // 匹配成功 移动 this.move(); return true; &#125; else &#123; this.error( 'syntax error at ' + this.lookahead.value || this.lookahead.tag ); &#125; &#125; next() &#123; return this.tokens[this.index + 1] || &#123;&#125;; &#125; 把这些基础parse模块结合起来，就可以得到ast的解析单元函数： parseFactorExpression parseFunctionDeclaration parseReturnStatement parseForStatement parseStatement parseCallExpression parseScript parseBlock parseStatementListItem parseUnaryExpression parseMutilOrdivideExpression parseAssignmentExpression parseArithExpression parseRelationExpression parseEqulityExpression parseAndExpression parseOrExpressgion parseBinaryExpression parseConditionalExpression parseType parseVariableDeclaration parseIfStatement 关于表达式的解析，我们这样来：我们规定三元运算符的优先级最低，因此假如出现一个三元表达式，那么所处的位置应该位于ast树的根附近，我们采用深度优先遍历 depth-first三元表达式在表达式中的优先级最低。关于二元表达式parseBinaryExpression可以由 || &amp;&amp; == != 等，定义一个优先级，即为谁先该进行计算，由于是深度优先，越远离根节点的节点，其优先级越高， 因为他们将得到优先计算。因此对于()中的部分，优先级最高，也应该放到叶子节点中对于 a||b&amp;&amp;c，我们规定优先级从低到高： || &amp;&amp; != == &lt; &lt;= &gt; &gt;= 减号 + / * ! - (单目) 数字 标识符 保留字 函数调用 字符串 括号中部分因此我们在解析过程中，遇到||，就解析左右部分，因为其优先级最低，如果解析完毕，又遇到||，就把开始解析得到的表达式作为||的左操作符，继续去解析右边我们按照优先级从低到高，写作12345678910111213141516171819202122parseOrExpressgion() &#123; //Or的优先级最低，先去解析它的下一个优先级And let left = this.parseAndExpression(); while (this.lookahead.tag == Tag.OR) &#123; this.move(); left = new Nodes.BinaryExpression('||', left, this.parseAndExpression()); &#125; return left; &#125; parseAndExpression() &#123; //And的优先级比==，!=低，先去解析它的下一个优先级==，!= let left = this.parseEqulityExpression(); while (this.lookahead.tag == Tag.AND) &#123; this.move(); left = new Nodes.BinaryExpression( '&amp;&amp;', left, this.parseEqulityExpression() ); &#125; return left; &#125; 就可以按照优先级依次往下写对于单目运算 要注意，由于单目可以反复出现，如!!!!!!a，这样的话要一直递归解析单目，直到非单目出现为止最后到了优先级最高的部分数字 标识符 保留字 函数调用 字符串 括号中部分(还是表达式)1234567891011parseUnaryExpression() &#123; if (this.lookahead.tag == '-') &#123; this.move(); //递归解析单目 return new Nodes.UnaryExpression('-', this.parseUnaryExpression()); &#125; else if (this.lookahead.tag == '!') &#123; this.move(); //递归解析单目 return new Nodes.UnaryExpression('!', this.parseUnaryExpression()); &#125; else return this.parseFactorExpression(); &#125; 对于()，里面的还是表达式，我们就可以从parseConditionalExpression最低优先级的开始最后的最高优先级到了树的叶子节点部分12345678910111213141516171819202122232425262728293031323334353637parseFactorExpression() &#123; let expr; switch (this.lookahead.tag) &#123; case '(': this.move(); expr = this.parseConditionalExpression(); this.match(')'); return expr; case Tag.NUM: case Tag.REAL: case Tag.TRUE: case Tag.FALSE: expr = new Nodes.Literal(this.lookahead.value, this.lookahead.value); this.move(); return expr; case '~': this.match('~'); expr = new Nodes.Literal( this.lookahead.value.toString(), this.lookahead.value ); this.match(Tag.ID); this.match('~'); return expr; case Tag.ID: let id = new Nodes.Identifier( this.lookahead.value || this.lookahead.tag ); this.move(); return id; case Tag.INVOKE: return this.parseCallExpression(); default: this.error('syntax error'); return expr; &#125;&#125; 表达式树1'lyt+2323&amp;&amp;(33223-22||(ff)||fe&lt;---3332-3&amp;&amp;few==21&amp;&amp;feww==3223||ffffff==3232||!f&amp;&amp;f&gt;=21)'; 程序的stmt一般由表达式，或者只有表达式组成(这种情况叫表达式语句 ExpressionStatement)，除了循环(forStatement)，条件(ifStatement)，声明(variableDeclaration)，一般的语句都是ExpressionStatement所以解析了表达式，工作就完成了一大半在解析完表达式后就可以处理，一些Statement，只要按照固定的格式走就可以了如：parseForStatement123456789101112parseForStatement() &#123; this.match(Tag.FOR); this.match('('); let init = this.parseAssignmentExpression(); this.match(';'); let test = this.parseConditionalExpression(); this.match(';'); let update = this.parseAssignmentExpression(); this.match(')'); let body = this.parseBlock(); return new Nodes.ForStatement(init, test, update, body);&#125; 如parseBlock,Block中有statement列表，用个数组保存123456789101112131415parseBlock() &#123; //const node = this.createNode(); this.match('&#123;'); const block = []; while (true) &#123; if (this.lookahead.tag == '&#125;') &#123; break; &#125; let stmt = this.parseStatementListItem(); stmt &amp;&amp; block.push(stmt); &#125; this.match('&#125;'); return new Nodes.BlockStatement(block); &#125; 声明一般有变量声明，函数声明； 4.遍历一般的parse都有一个traverser，用来遍历ast树，并在特定节点做操作，如用户想在遍历到CallExpression时进行一些操作，把log变成console.log，可以如下操作1234567891011traverser(ast, &#123; CallExpression: &#123; enter: function(node, parent) &#123; // 改变ast if (node.callee == 'log') &#123; // 把log变为console.log node.callee = `console.log`; &#125; &#125;, &#125;,&#125;); enter表示进入到ast这个节点的时刻，这个时刻traverser还不知道这个节点的children的信息，只是到这个节点，它的后续节点信息不知道，只有当exit方法,也就是再次回到这个节点，traverser知道了这个节点的所有字节点信息 5.代码生成codeGenerator根据ast来生成代码，我们对每一个ast节点，写一个对应的代码生成即可比如递归的调用codeGenerator就好123456789101112case 'CallExpression': return ( node.callee + '(' + node.arguments.map(codeGenerator).join(', ') + ')' );case 'ReturnStatement': return `return $&#123;codeGenerator(node.argument)&#125;;`;case 'ConditionalExpression': return `$&#123;codeGenerator(node.test)&#125; ? $&#123;codeGenerator( node.consequent )&#125;:$&#123;codeGenerator(node.alternate)&#125; `;case 'AssignmentExpression': return `$&#123;node.left.name&#125;$&#123;node.operator&#125;$&#123;codeGenerator(node.right)&#125;`; 6.参考资料http://resources.jointjs.com/demos/javascript-asthttps://astexplorer.net/#https://the-super-tiny-compiler.glitch.me/traverser","tags":[{"name":"编译 前端","slug":"编译-前端","permalink":"http://07lyt.com/tags/编译-前端/"}]},{"title":"实现简易MVVM","date":"2017-09-07T13:20:52.000Z","path":"2017/09/07/mvvm/","text":"前言mvvm双向绑定要解决的二个问题 数据到ui的映射问题 ui到数据的映射问题 对于ui到数据的映射，比较简单，先天的的dom事件及其相关的响应函数即可以把相关交互映射到数据上，为了实现数据到ui的问题，要使得ob.a = 1能真实反映在UI上，在实现上可以使用劫持数据属性的做法，即为Object.defineProperty接口，这样能劫持ob.a的赋值过程，类似于C#属性，我们代理一个对象的方式如下：123456789101112131415161718192021function proxys(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; Object.keys(data).forEach((key, index) =&gt; &#123; let val = data[key]; proxys(val); Object.defineProperty(data, key, &#123; configurable: true, enumerable: true, get: function() &#123; console.log('get~~~!'); return val; &#125;, set: function(newValue) &#123; console.log('set~~~!'); val = newValue; &#125;, &#125;); &#125;);&#125; 我们\b代理一个对象的属性获取过程，proxys递归调用以处理嵌套对象的情形,需要注意我们要通过闭包进行赋值，不能\b直接进行，如:1234 get: function() &#123; console.log('get~~~!'); return data[key];&#125;, 这样由于闭包内\b引入了data,会不断调用get，形成死循环。在我们代理了一个对象的属性获取行为后，我们便可以在对象\b属性设置或者获取过程做一些事情，运用常用的观察者模式，我们可以代理设置过程，\b在赋值的时候利用通知，将新值通知到具体的被观察者。我们实现一个观察者和一个被观察者： 我们在proxys中加入一个observebal被观察者，并利用get，在get中加入观察者，而观察者，\b挂载在类Observebal的静态属性上，并在我们实例化一个Observer时，进行调用get，这样，当我们执行以下代码时，一个Observebal的实例就会\b\b得到他们对应的观察者（例子中为2个）,因而我们\b\b执行model.a = 22222;时，console.log(&#39;observer1&#39;, value);便会通过notify得到触发.1234567891011let model = &#123; a: 1, b: 2 &#125;;let observal = new Observebal(model);//监听a属性变化Observebal.observer = new Observer(model, 'a', value =&gt; &#123; console.log('observer1', value);&#125;);//监听b属性变化Observebal.observer = new Observer(model, 'b', value =&gt; &#123; console.log('observer2', value);&#125;);model.a = 22222; 这里的get写法很妙，\b不断的覆盖不断的取值，感觉_.get\b似乎应该也是类似实现12345678910getter(vm, expr) &#123; var exps = expr.split('.'); //只要不进行ob.xxx的修改就可以了，指针重新覆盖 let obj = vm; for (var i = 0, len = exps.length; i &lt; len; i++) &#123; if (!obj) return; obj = obj[exps[i]]; &#125; return obj;&#125; 指令编辑器接下来只需要\b实现一个\b指令编辑器就可以，我们的思路是实现数据到ui的通知我们的思路是:数据变化—–&gt;回调函数（引用有真实dom的闭包）—–&gt;利用dom \bapi改变dom指令编辑器的作用就是执行后面两步，我们可以利用这个思路，先拿到dom的引用，这里拿取dom引用的办法有很多，要不是利用模板字符串转换成dom,从而可以进行遍历，要不是直接写在页面中，让html初始化了dom,然后我们再进行更改。我们最关键的\b一步就是我们遍历dom树，拿到了每个dom结点的引用，之后解析dom结点上的指令，之后做一个闭包函数，函数内引用这个dom节点，把这个函数作为相应指令对应观察者的回调函数，并在这个函数内部进行dom的更新（由于已经有dom的引用）,就可以完成最关键的一步：数据到ui的更新 对于ob.a.b.c的赋值，可以有以下过程，对于get，反复执行getter,且更新指针，对于setter,取到最后一个.\b后,再执行真正的赋值。1234567891011121314151617181920212223getVmVal(vm, exp) &#123; var val = vm; exp = exp.split('.'); exp.forEach(function(k) &#123; //反复更新指针，反复执行getter，不执行setter val = val[k]; &#125;); return val;&#125;setVmVal(vm, exp, newValue) &#123; var val = vm; exp = exp.split('.'); exp.forEach(function(k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; //反复执行getter val = val[k]; &#125; else &#123; //最后再执行setter val[k] = newValue; &#125; &#125;);&#125; 还有一个是mvvm对象的设置，对于以下代码，我们mvvm中的model部分是data属性字段，vm作为承接v和m的部分，也起到一定逻辑处理的角色123456789101112131415161718192021222324252627var vm = new MVVM(&#123; ele: document.getElementById('mvvm-app'), data: &#123; someStr: 'hello ', className: 'btn', htmlStr: '&lt;span style=\"color: #f00;\"&gt;red&lt;/span&gt;', child: &#123; htmlStr: 'few', someStr: 'World !' &#125; &#125;, computed: &#123; getHelloWord: function() &#123; return this.someStr + this.child.someStr; &#125; &#125;, methods: &#123; clickBtn: function(e) &#123; var randomStrArr = ['childOne', 'childTwo', 'childThree']; this.child.someStr = randomStrArr[parseInt(Math.random() * 3)]; this.child.htmlStr = randomStrArr[parseInt(Math.random() * 3)]; &#125; &#125; &#125;); MVVM通过一定的代理手段，将data字段映射到vm实例之上，\b目的是在\u001cmethods,computed函数中，通过this(vm实例)能访问model的值,对于computed，用defineProperty，将computed中的所有字段也映射到vm实例中，最后有个非常重要的点:12//命令数据为可以观察的new Observebal(data); 需要对model部分的数据进行观察，这样，通过代理model的key到实例的key后，每次vm.xx都会进行getter,每次vm.xx = xxx都会进行setter，要注意defineProperty的getter,和setter都需要用引用，以防止\b循环调用最终代码如下： 感谢文章，部分代码参考以下文章： https://github.com/DMQ/mvvmhttps://zhuanlan.zhihu.com/p/24475845","tags":[{"name":"模式 mvvm","slug":"模式-mvvm","permalink":"http://07lyt.com/tags/模式-mvvm/"}]},{"title":"React简单实现之Feact---探寻React内部机制","date":"2017-08-14T09:20:52.000Z","path":"2017/08/14/Feact/","text":"下面的文章介绍了\bReact的内部机制，\b本文的一部分参考了文章中的实现。 嫌麻烦可以点开跳到最后实现部分 原文地址： http://www.mattgreer.org/articles/react-internals-part-three-basic-updating/ 在读过上述文章后，对react的机制有了个大致的了解，感谢作者，但是其实现有一些局限在于没有\b实现creatElement接受多个children的情形，只能接受单个字符串文本，因而少了diff,patch这一环节,且缺少了事件系统，在发\b邮件咨询了作者后，下面的\b代码基于其实现进行了扩展。此外在实现简易react的过程中还参考了react 16的源码，以及下面的文章： react 官方实现介绍 https://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_two// https://zhuanlan.zhihu.com/p/20346379 在实现react过程中，有一些简单术语： \b内部实例—指不对用户暴露的virtual Dom实例我们的虚拟dom对应的具体对象，有FeactDOMTextComponent,FeactDOMComponent,FeactCompositeComponentWrapper,FeactEmptyComponent 指的是虚拟dom的面向对象实现，存在于内存中这些用户无感知，仅在内部使用 外部实例：我们常用的React.Component的实例，有render componentDidMount方法等生命周期（这一部分对我们也是可见的） element—指React.creatElemnt得到的vitual dom（这一部分是对我们可以见到的,就是jsx） 本文基于上述文章思路分几个步骤实现react一. 初始挂载 递归挂载二. setState状态变更 异步 diff patch三. 事件\b实现 代理 \b一. 初始挂载初始挂载\b有一系列问题：1 React.creatElement创建了什么？1 ReactDom.render做了什么？1 初始生命周期是怎么实现的？2 \b组件是怎么挂载的？3 虚拟dom是怎么实现的？6 怎么挂载一个列表或者是\b一个有多个children的\b元素？ 先来看一个\b例子： 首先jsx经过babel转换为React.creatElement 我们先看React.creatElement创建了什么？12345678910111213141516createElement(type, props, ...children) &#123; const element = &#123; type, props: props || &#123;&#125;, &#125;; if (props &amp;&amp; props.key) &#123; element.key = props.key; &#125; if (children) &#123; element.props.children = children; &#125; //返回一个对象 //返回一个element，代表虚拟Object return element; &#125;, 我们这里都是接受了一个\btype，props,children,用es\b6的语法接受\bchildren数组,我们后续会根据type的不同实例化不同的虚拟dom再来看render，render了什么？12345678910111213//React.render render(element, container) &#123; //获得保存过的实例 const prevComponent = getTopLevelComponentInContainer(container); if (prevComponent) &#123; //container挂载过 return updateRootComponent(prevComponent, element); &#125; else &#123; //render 返回真实dom return renderNewRootComponent(element, container); &#125; &#125;, 先忽略updateRootComponent,在renderNewRootComponent这个方法中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function renderNewRootComponent(element, container) &#123; //新建dom 挂载在container //type是一个function const wrapperElement = Feact.createElement(TopLevelWrapper, element); //new了 一个 vCompositeNode const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); const markUp = FeactReconciler.mountComponent(componentInstance, null); // container.__feactComponentInstance 挂了 vCompositeNode 的render返回的vCompositeNode container.__feactComponentInstance = componentInstance._renderedComponent; container.appendChild(markUp); return markUp;&#125;const TopLevelWrapper = function(props) &#123; this.props = props;&#125;;TopLevelWrapper.prototype.render = function() &#123; return this.props;&#125;;//根据不同的type进行初始化function instantiateFeactComponent(element) &#123; //virtuan node 工厂 if (element == null || element == undefined) &#123; return new FeactEmptyComponent(element); &#125; else if (typeof element === 'string') &#123; return new FeactDOMTextComponent(element); &#125; else if (typeof element.type === 'string') &#123; return new FeactDOMComponent(element); &#125; else if (typeof element.type === 'function') &#123; return new FeactCompositeComponentWrapper(element); &#125;&#125;const FeactReconciler = &#123; mountComponent(internalInstance, parentNode, hostContainerInfo) &#123; return internalInstance.mountComponent(parentNode, hostContainerInfo); &#125;, receiveComponent(internalInstance, nextElement) &#123; internalInstance.receiveComponent(nextElement); &#125;, performUpdateIfNecessary(internalInstance) &#123; internalInstance.performUpdateIfNecessary(); &#125;, instantiateChildren(internalInstance, propschildren) &#123; internalInstance.instantiateChildren(propschildren); &#125;,&#125;; 我们创建了一个顶层Wrapper,这个顶层Wrapper是个内部自定义组件实例，用这个顶层实例包装了一层我们的render的element，其render就返回自己的props,然后new了一个FeactCompositeComponentWrapper内部虚拟dom组件实例（自定义组件对应的虚拟dom的内部实例），再调用mountComponent获得对应的dom节点，并挂载在container中，可以看到，有个Reconciler，在react官方文档中，Reconcilers指不与平台相关联的那部分，由于react的render不止在浏览器中，还可能在服务端，React Native中，参考react codebase，由Reconcilers执行渲染，生命周期，自定义组件等公共部分。我们简单提供FeactReconciler,在虚拟dom方面，我们简单提供4种实例 FeactEmptyComponent(对render里，返回null，undefined进行处理) FeactDOMTextComponent(对纯文本的虚拟dom) FeactCompositeComponentWrapper(对自定义组件的虚拟dom) FeactDOMComponent(对html tag的虚拟dom) 我们根据传入的不同type进行不同的初始化,接下来我们看看mountComponent方法，首先这个方法的意义是：生成该虚拟dom对应的真实dom这个方法中，我们还设置当前虚拟节点的父虚拟节点 对于FeactEmptyComponent内部组件(return null的情形)我们可以返回一个注释节点，以便让虚拟dom有个真实节点可以对应123456mountComponent(hostParent, hostContainerInfo) &#123; this._hostParent = hostParent; this._hostContainerInfo = hostContainerInfo; this._domNode = document.createComment('feact --- empty --- component'); return this._domNode; &#125; 对于FeactDOMTextComponent文本节点，返回一个文本dom对象123456mountComponent(hostParent, hostContainerInfo) &#123; this._hostParent = hostParent; this._hostContainerInfo = hostContainerInfo; this._domNode = document.createTextNode(this._currentElement); return this._domNode; &#125; FeactCompositeComponentWrapper是自定义组件的内部实例类，我们在写的时候用render方法提供单个Element,注意我们在render不能提供一个list,也不能提供多个平级的html tag。这样的设计使得FeactCompositeComponentWrapper有一个好处，就是只用render出来的element只有一个，不会有children的存在，即便有children，也是render的第一个html tag对应的element的children,再如果是自定义组件，那么children即为this.props.children将全权交给组件来处理，这个设计使得我们的自定义组件不需要关心children的问题，在挂载和更新时可以方便的将要挂载的组件或者要更新的组件传递下去。在挂载过程中，我们可以实现相应的生命周期方法：1234567891011121314151617181920212223mountComponent(hostParent, hostContainerInfo) &#123; //保存父虚拟dom实例 this._hostParent = hostParent; this._hostContainerInfo = hostContainerInfo; //type是个函数的时候，我们认为是个自定义组件，因而要实例化这个组件（外部组件 //有render,componentDidMount等生命周期钩子方法 //） const Component = this._currentElement.type; //这个type拿到一个函数 这个函数有那些对应的 react 方法 const componentInstance = new Component(this._currentElement.props); //componentInstance 这个实例不是react vnode 的实例 是React.component的实例 因而可以调用render方法 this._instance = componentInstance; //我们还可以保存内部实例到外部实例的映射 FeactInstanceMap.set(componentInstance, this); if (componentInstance.componentWillMount) &#123; componentInstance.componentWillMount(); &#125; const markup = this.performInitialMount(); if (componentInstance.componentDidMount) &#123; componentInstance.componentDidMount(); &#125; return markup; &#125; performInitialMount这个方法获得真正的dom,在这个方法前既可以执行生命周期方法我们在performInitialMount中调用组件的生命周期方法render，之后将render返回的element实例化成虚拟dom内部实例对象，在返回这个对象的mountComponent方法即可，这个过程就可以递归的下去进行了。1234567891011performInitialMount() &#123; //调用自定义组件的render方法，其实就是调用creactElement 出来的 const renderedElement = this._instance.render(); //virtual node 工厂得到child 可能会多个不同的实例 公用一组接口 const child = instantiateFeactComponent(renderedElement); this._renderedComponent = child; //在这里抹平了mountComponent的过程 //child.mountComponent 可能是FeactDOMComponent.mountComponent //也可能是FeactCompositeComponentWrapper.mountComponent return FeactReconciler.mountComponent(child, this);&#125; FeactDOMComponent：重要是的FeactDOMComponent的挂载，由于一个html tag对应的虚拟dom，可以带多个children，类似1Feact.createElement('div', &#123;&#125;, 'child 1',null,'child 3'……………………) 所以FeactDOMComponent的挂载需要考虑children问题，之所以自定义组件不需要考虑，是因为，this.props.children全权交给了组件来处理FeactDOMComponent的虚拟dom的挂载分几个步骤来处理：1 创建对应的真实dom(document.createElement)2 设置style等属性3 创建所有一级children真实dom4 将第三步得到的所有真实dom挂载到第一步得到的dom中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function flatten(list, depth) &#123; depth = typeof depth == 'number' ? depth : Infinity; if (!depth) &#123; if (Array.isArray(list)) &#123; return list.map(function(i) &#123; return i; &#125;); &#125; return list; &#125; return _flatten(list, 1); function _flatten(list, d) &#123; return list.reduce(function(acc, item) &#123; //if(d&gt;1)item if (Array.isArray(item) &amp;&amp; d &lt; depth) &#123; return acc.concat(_flatten(item, d + 1)); &#125; else &#123; return acc.concat(item); &#125; &#125;, []); &#125;&#125;function flattenChildren(children, init_value) &#123; let childrenMap = &#123;&#125;; init_value = init_value || ''; for (let i = 0; i &lt; children.length; i++) &#123; let child = children[i]; let name = `.$&#123;i&#125;`; if (Array.isArray(child)) &#123; let flattendObject = flattenChildren(child, `.$&#123;i&#125;`); Object.assign(childrenMap, flattendObject); continue; &#125; if (child &amp;&amp; child._currentElement &amp;&amp; child._currentElement.key) &#123; //实例 name = `.$$&#123;child._currentElement.key&#125;`; &#125; if (child &amp;&amp; child.key) &#123; name = `.$$&#123;child.key&#125;`; &#125; name = init_value + name; childrenMap[name] = child; &#125; return childrenMap;&#125;function instantiateFeactComponentArrayItem(ele) &#123; if (Array.isArray(ele)) &#123; return ele.map((item, index) =&gt; &#123; return instantiateFeactComponent(item); &#125;); &#125; else return instantiateFeactComponent(ele);&#125; mountChildren(propschildren, el) &#123; //得到propschildren 对应的实例 一级children todo // var children = FeactReconciler.instantiateChildren(this, propschildren); var mountImages = []; var index = 0; var children = []; let flattenpropschildren = propschildren; for (let i = 0; i &lt; flattenpropschildren.length; i++) &#123; let child = flattenpropschildren[i]; let vInstance = instantiateFeactComponentArrayItem(child); children.push(vInstance); &#125; let flattenddChildrenInst = flatten(children); for (let j = 0; j &lt; flattenddChildrenInst.length; j++) &#123; let vInstance = flattenddChildrenInst[j]; vInstance._mountIndex = j; //对每个children进行挂载，递归下去 mountImages.push(FeactReconciler.mountComponent(vInstance, this)); &#125; this._renderedChildren = flattenChildren(children); return mountImages; &#125; _createInitialChildren(props, el) &#123; //获得所有children 真实 dom var mountImages = this.mountChildren(props.children, el); for (var i = 0; i &lt; mountImages.length; i++) &#123; el.appendChild(mountImages[i]); &#125; &#125; mountComponent(hostParent, hostContainerInfo) &#123; this._hostParent = hostParent; this._rootNodeID = globalIdCounter++; this._domID = hostContainerInfo &amp;&amp; hostContainerInfo._idCounter++; //宿主Element const domElement = document.createElement(this._currentElement.type); this._updateDOMProperties(null, this._currentElement.props); //挂载 this._createInitialChildren(this._currentElement.props, domElement); FeactInstanceMap.set(domElement, this); this._hostNode = domElement; return domElement; &#125; 如果不给key，靠什么索引？靠index在list数组中，用key来标识数组创建子组件时，若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index作为key的。 小于才移动，大于等于都不移动 但是，若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。本文开始引入的例子就是最好的证明。123456789101112131415&#123;this.state.data.map((v,idx)=&gt;&lt;Item key=&#123;idx&#125; v=&#123;v&#125; /&gt;)&#125;// 开始时：['a','b','c']=&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;a &lt;input type=\"text\"/&gt;&lt;/li&gt; &lt;li key=\"1\"&gt;b &lt;input type=\"text\"/&gt;&lt;/li&gt; &lt;li key=\"2\"&gt;c &lt;input type=\"text\"/&gt;&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['c','b','a'] =&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;c &lt;input type=\"text\"/&gt;&lt;/li&gt; &lt;li key=\"1\"&gt;b &lt;input type=\"text\"/&gt;&lt;/li&gt; &lt;li key=\"2\"&gt;a &lt;input type=\"text\"/&gt;&lt;/li&gt;&lt;/ul&gt; 上面实例中在数组重新排序后，key对应的实例都没有销毁，而是重新更新。具体更新过程我们拿key=0的元素来说明， 数组重新排序后： 组件重新render得到新的虚拟dom；新老两个虚拟dom进行diff，新老版的都有key=0的组件，react认为同一个组件，则只可能更新组件；然后比较其children，发现内容的文本内容不同（由a—&gt;c)，而input组件并没有变化，这时触发组件的componentWillReceiveProps方法，从而更新其子组件文本内容;因为组件的children中input组件没有变化，其又与父组件传入的任props没有关联，所以input组件不会更新(即其componentWillReceiveProps方法不会被执行)，导致用户输入的值不会变化。这就是index作为key存在的问题，所以不要使用index作为key。 按照上述情况，我们调用mountChildren得到一个children真实dom的数组，然后挂在宿主dom上，获得chilren真实dom的过程是对每一个一级children执行mountComponent获得其真实dom,关键是有些chilren是数组的形式:1Feact.createElement('div', &#123;&#125;, ['child 1',null,'child 3'],'child 4') 按照react的思路 我们在挂载时候需要扁平化，即为把children数组转变为对象（可以理解为转换为hash），这样方便快速索引，这里有个技巧,我们在key前加.把数字变为非数字，这样for in遍历对象的顺序将和声明的顺序一样，也和我们for循环添加的顺序一致，对于有key的节点，我们以key值作为实例的索引，对于是[]数组的情况，我们递归调用flattenChildren，并把调用顺序传递下去，可以得到之后我们再利用类似lodash的flatten方法，把所有children扁平到一个数组中，再依次mountComponent得到真实dom,注意：在FeactDOMComponent挂载的时候有个全局自增的id，这个id将作为这个FeactDOMComponent的唯一索引。在后续事件中用的上。1this._rootNodeID = globalIdCounter++;下面的图中有一个数组children，然后有4个不带key的children,对于不带key的，我们用.加index的形式使其变为非数字，对于有key字段的内部实例，我们用$加key的形式作为key,数组作为第一个元素，其扁平化后的key为2级的形式。处理完最复杂的FeactDOMComponent的mount情形后，我们的mount过程基本结束。最后查看dom可以得到，也可以打开调试工具查看： \b二. setState状态变更每次在setState的过程中，把状态保存到一个队列中，在需要更新的时候，把状态全部拿出来合并，得到一个最终状态，再统一更新，那么什么时候知道需要更新呢，在react中，有一个事务的概念，在触发了生命周期，或者是触发了事件的时候，会进入一个大的事务的中，也就是我们的setState操作都在大事务的前中期，在事务的结束阶段，我们才把队列中的状态拿出来，合并，并更新组件状态，render也是在这之后才发生对于事件12345678910111213function enqueueUpdate(component) &#123; if (!batchingStrategy.isBatchingUpdates) &#123; //在一开始就进入了更新的事务 //大部分都是setTimeout 中进行setState才进入此 batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; dirtyComponents.push(component); if (component._updateBatchNumber == null) &#123; component._updateBatchNumber = updateBatchNumber + 1; &#125;&#125; 在setTimeout中 事务是一气呵成而在一些生命周期，或事件dispatchevent中，batchupdate的flag早在一开始就设置为了true在http://www.mattgreer.org/articles/react-internals-part-three-basic-updating/ 文章中,实现了setState的类似缓存变更功能，但没有对多children的情况做处理，只简单处理字符串，diff的过程也没有体现，模仿react，我们需要定义receiveComponent这个方法，这个方法的具体意义是：更新本组件虚拟dom树下的的真实dom，也就是说，执行了这个方法之后，这个虚拟dom包括这个虚拟dom之下的所有叶子都得到了更新，更新虚拟dom的主要是更新属性，对于FeactDOMComponent,需要更新这个虚拟dom的自身的属性，以及更新其所有的一级child,通过递归依次向下，比如有个&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;那么更新div的话，其div下的所有children也将得到更新。 根据react官方介绍，我们还需要保存每个虚拟dom的hostNode，即为其对应的真实虚拟dom,FeactDOMComponent这样的虚拟dom，很好保存，在mount组件的时候即可以保存，对于合成组件即自定义组件，我们可以获得其render出来元素的hostNode.123getHost() &#123; return this._renderedComponent.getHost(); &#125; 那么什么时候知道需要更新呢，在react中，有一个事务的概念，在触发了生命周期，或者是触发了事件的时候，会进入一个大的事务的中，也就是我们的setState操作都在大事务的前中期，在事务的结束阶段，我们才把队列中的状态拿出来，合并，并更新组件状态，render也是在这之后才发生 我们再原封不动使用React的shouldUpdateFeactComponent来判断是否需要更新组件，可以从这个函数中看出，我们更新组件的有几种情况，对于文本，数字，我们都要更新，对于虚拟DOM，我们只要type相等，且key相等就需要更新，这里key相等也有undefined == undefined的情形 假如有个父节点，其setState了，那么子节点需要render,那么子节点是怎么知道需要render的呢？先不考虑setState，我们知道，在render的时候，会调用creactElement创建新元素，如果有多次render,那么每次都会creactElement创建新元素。事实上，我们在第一次实例化element为内部实例的时候，会把该内部实例保存下来，之后会用每次creactElement得到的新element会与之前的实例中的element进行对比，如果满足shouldUpdateFeactComponent更新要求，那么只需执行receiveComponent方法，更新组件即可。FeactCompositeComponentWrapper的更新如下所示：FeactCompositeComponentWrapper需要判断其render方法出来的element需不需要更新，如果需要更新，用之前的实例进行更新（receiveComponent）,如果不满足更新条件，那么按照react的思路，我们要销毁之前的保存的节点（销毁生命周期暂时无体现），并重新挂载新的节点，即先实例化新节点，再挂载到hostNode的父节点上完成转换。123456789101112131415161718192021_updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const prevRenderedElement = prevComponentInstance._currentElement; //接受新props 和 state的时候再次render const nextRenderedElement = inst.render(); //渲染过的_renderedComponent接受新的render得到的element //这个地方也会出现分叉，可能是FeactDOMComponent.receiveComponent //也可能是FeactCompositeComponentWrapper.receiveComponent if (shouldUpdateFeactComponent(prevRenderedElement, nextRenderedElement)) &#123; FeactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement); &#125; else &#123; var oldHostNode = prevComponentInstance.getHost(); var child = instantiateFeactComponent(nextRenderedElement); this._renderedComponent = child; var nextMarkup = FeactReconciler.mountComponent(child, this); let parent = oldHostNode.parentElement; parent.innerHTML = ''; parent.append(nextMarkup); &#125; &#125; 有个问题是setState怎么缓存的？这个实现上比较简单，先用个数组把所有变动存起来，再在需要更新的时候，依次赋值123456789101112_processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; nextState = Object.assign(&#123;&#125;, nextState, this._pendingPartialState[i]); &#125; this._pendingPartialState = null; return nextState; &#125; FeactDOMComponent的更新稍微麻烦一些，需要考虑diff,以做出最小改动,在理解diff上，有一个很重要的点，就是FeactDOMComponent的更新，只需要考虑一级child节点，diff的比较对象是内部实例，之所以可以for in进行遍历还有顺序保证，即新children的从左到右的顺序，并且使用从0自增的nextIndex,是由于之前介绍的在key前加.的操作，可以保证是for循环的顺序，可用用nextIndex自增，得到的index和for的index一致，更新一个FeactDOMComponent的大致流程是： 依次更新该FeactDOMComponent下的所有children，该更新的更新，该新挂载的重新挂载，得到新的children内部虚拟dom实例（这个过程会产生递归） 收集新增加的节点（包括替换旧的也算新增），和要删除的节点 做O(n)的diff,这里的这个n,指的是所有一级children的个数，关于diff文章说的很清楚了，有几个问题可以解答下：_mountIndex怎么来的？在初始挂载的时候，就会按照children的index次序，为每个child增加_mountIndex属性，lastIndex的意义是什么？访问过的旧有节点的最大位置，这个index只会增加。lastPlaceNode是什么？是按顺序得到的新节点的真实dom，所有的新增节点，节点移动，都是在这个lastPlaceNode之后，所以也叫afterNode，mountImages用来保存所有新增节点的真实dom,且所有的新增dom都在第二步进行完成放入数组中了。 根据得到的更新数组，进行patch操作，更新真实dom 利用lastPlaceNode的好处是，我们可以对于MOVE_EXISTING的操作，我们也可以调用原生的insertBefore方法，这个方法把原有节点移动到lastPlaceNode这个后面，刚好符合要求（按照新的children顺序 我们的新节点，不管是移动的新节点，还是真正新增的节点，都要放在lastPlaceNode之后） \b三. 事件机制事件没有实现合成事件和批处理队列,这里只是简单实现一下思路在挂载阶段和更新阶段，我们都会调用_updateDOMProperties函数来更新节点的属性，这里就把eventHanlder响应函数加入到全局map中保存了起来123456789_updateDOMProperties(lastProps, nextProps) &#123; let eventReg = /^on[\\w]*$/; for (let propskey in nextProps) &#123; if (propskey.match(eventReg)) &#123; let eventHanlder = nextProps[propskey]; ReactEventEmitter.putListener(this._rootNodeID, propskey, eventHanlder); &#125; &#125;&#125; react的事件机制react的事件冒泡回调数组不是存于全局事件对象中，而是存在合成事件SyntheticEvent对象中，在合成事件产生过程中，有一段开发模块中的Proxy对象，代码如下：1234567891011121314151617181920212223242526272829303132333435363738//SyntheticEvent -----&gt; 合成事件的构造函数/** Proxying after everything set on SyntheticEvent * to resolve Proxy issue on some WebKit browsers * in which some Event properties are set to undefined (GH#10010) */if (__DEV__) &#123; if (isProxySupported) &#123; /*eslint-disable no-func-assign */ SyntheticEvent = new Proxy(SyntheticEvent, &#123; construct: function(target, args) &#123; return this.apply(target, Object.create(target.prototype), args); &#125;, apply: function(constructor, that, args) &#123; return new Proxy(constructor.apply(that, args), &#123; set: function(target, prop, value) &#123; if ( prop !== 'isPersistent' &amp;&amp; !target.constructor.Interface.hasOwnProperty(prop) &amp;&amp; shouldBeReleasedProperties.indexOf(prop) === -1 ) &#123; warning( didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.', ); didWarnForAddedNewProperty = true; &#125; target[prop] = value; return true; &#125;, &#125;); &#125;, &#125;); /*eslint-enable no-func-assign */ &#125;&#125; 要实现一个合成事件系统，我们得需要3样东西，SyntheticEvent，存储映射关系的内部对象的key,以及为了事件冒泡系统的内部实例的_hostParent父亲实例引用，对于_hostParent，只要在mount的时候把this传入即可，由于我们的事件只能挂在ReactDomComponent上，在合成组件即继承自React.component的组件，并不能挂载事件，只能定义事件响应在原型上，所以不用为其增加标识，我们设置一个全局id,在FeactDOMComponentmount时这个id自增，保证每一个FeactDOMComponent有一个唯一的id，这样我们就能利用id作为key，存储对应的事件响应函数,如图,在一个全局二维数组里保存有所有id对应的相应函数 我们用_hostParent找到所有需要冒泡的虚拟dom,在dispatchEvent的时候简单调用， 事实上，react的事件分发是在一个事务中的，所以在这个事务中做出的任何setState操作都会缓存，在事务结束的时候进行统一更新.1234567891011121314151617181920212223242526272829303132333435363738394041424344var ReactEventEmitter = &#123; listenerBank: &#123;&#125;, putListener: function putListener(id, registrationName, listener) &#123; var bankForRegistrationName = this.listenerBank[registrationName] || (this.listenerBank[registrationName] = &#123;&#125;); bankForRegistrationName[id] = listener; &#125;, getListener: function getListener(id, registrationName) &#123; return this.listenerBank[registrationName][id]; &#125;, trapBubbledEvent: function trapBubbledEvent(topLevelEventType, element) &#123; var eventMap = &#123; onClick: 'click', &#125;; var baseEventType = eventMap[topLevelEventType]; element.addEventListener(baseEventType, this.dispatchEvent.bind(this, topLevelEventType)); &#125;, dispatchEvent: function dispatchEvent(eventType, event) &#123; //这个是原生事件 event.preventDefault(); let internalInst = FeactInstanceMap.get(event.target); // var id = internalInst._rootNodeID; //先默认实现一个bubbule的事件系统 var parentArray = []; var listenArray = []; var parent = internalInst; while (parent) &#123; parentArray.push(parent); parent = parent._hostParent; &#125; for (let i = 0; i &lt; parentArray.length; i++) &#123; let instID = parentArray[i]._rootNodeID; let handler = this.getListener(instID, eventType); handler &amp;&amp; listenArray.push(handler); &#125; for (let i = 0; i &lt; listenArray.length; i++) &#123; listenArray[i](event); &#125; &#125;,&#125;; 最终代码：","tags":[{"name":"React","slug":"React","permalink":"http://07lyt.com/tags/React/"}]},{"title":"react-native踩坑之旅","date":"2017-07-02T13:20:52.000Z","path":"2017/07/02/react-native踩坑/","text":"2017-07-20更新:在本地化的时候遇到点问题，如果没有本地话过的话，get key内部throw的错无法catch到 2017-07-09更新：做了个TODO的小demo,用的内部的组内的redux业务框架，如下：总结下：调试利器：RN debuger在mac上开ios模拟器，拥有跟页面调试基本一致的体验。初步发现的一些三方包： https://github.com/crazycodeboy/react-native-check-box https://github.com/sunnylqm/react-native-storage https://github.com/sconxu/react-native-checkbox https://github.com/FaridSafi/react-native-gifted-listview https://github.com/jaysoo/react-native-parallax-scroll-view https://github.com/ldn0x7dc/react-native-media-kit https://github.com/tlenclos/react-native-audio-streaming https://github.com/zmxv/react-native-sound https://github.com/oblador/react-native-vector-icons https://github.com/react-native-material-design/react-native-material-design https://github.com/react-native-material-design/react-native-material-design https://github.com/halilb/react-native-textinput-effects 关于mac android指南\b准备工作：(http://reactnative.cn/docs/0.45/getting-started.html#content)： 去https://developer.android.com/studio/install.html下载最新的\bandroid studio android studio有去下载android sdk的能力，只要翻墙就可以用\bandroid studio去下载sdk android studio的6.0必装，对应的是sdk 23 然后在Android 6.0 &gt; (Marshmallow)中勾选Google &gt; APIs、Android SDK Platform 23 装好后要设置ANDROID_HOME环境变量再把工具路径1export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 加入环境变量 如何调试(真机)我的\b调试机型 vivo android 5.1.1 用exop mac客户端可以调试（这个客户端似乎不需要xcode \b或者android sdk）用这个客户端建立的项目只有一个.expo文件夹，没有我们的ios,android文件夹 exop像是一个壳客户端, 在android 5.0以上，\b要执行1adb reverse tcp:8081 tcp:8081 不然localhost认不出来之后执行\breact-native run-android即可调试，调试具有热启动的能力，远程debugger能力（不得不感叹很强大），下面是一些截图： 还有类似于看dom的功能 ps:Genymotion自己装的有 但没有试过 之后是打包APK的过程1$ keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 用上面的命令生成一个keystore文件，这个文件使用来签名用的，好像是个二进制文件，这个文件\b好像是java \bjdk的能力,引用： 这条命令会要求你输入密钥库（keystore）和对应密钥的密码，然后设置一些发行相关的信息。最后它会生成一个叫做my-release-key.keystore的密钥库文件。 在运行上面这条语句之后，密钥库里应该已经生成了一个单独的密钥，有效期为10000天。–alias参数后面的别名是你将来为应用签名时所需要用到的，所以记得记录这个别名。 还要生成一个Profile文件：1234567编辑~/.gradle/gradle.properties（没有这个文件你就创建一个），添加如下的代码（注意把其中的****替换为相应密码）注意：~表示用户目录，比如windows上可能是C:\\Users\\用户名，而mac上可能是/Users/用户名。MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 之后把生成的文件拷贝到android/app(是app!)下，不要拷贝到anroid文件夹下，另外有2个build.gradle文件，要注意，复制的这段代码要去掉省略号，要复制到子build.gradle中，根build.gradle不用管 1234567891011121314151617181920...android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125;&#125;... 之后在android文件中执行1./gradlew assembleRelease \b即可获得打包好的apk了 ignite: https://github.com/infinitered/ignite ps:有些库要求不同版本的android build tool android-building-from-source: https://facebook.github.io/react-native/docs/android-building-from-source.html 如何run\b 0.38的官方android例子 ：(看样子是要build)12345678Running the examples on AndroidNote that you'll need the Android NDK installed, see prerequisites../gradlew :Examples:Movies:android:app:installDebug# Start the packager in a separate shell (make sure you ran npm install):./packager/packager.sh# Open the Movies app in your emulator 下面是一些问题记录，有些没解决有些解决了官方文档：(http://reactnative.cn/docs/0.45/upgrading.html) mac上1.最新的官方demo，要求xcode8.3.3系统要求10.12及以上 官方用的expo，这个工具我理解是提供了一个供应用运行的app容器。 \b那些示例项目android ios该怎么运行？react-native run-ios/android? expo的应用怎么打包？目前都是运行在特定的expo那个应用上的 跑expo的应用在android上需要下个google play store，再搜索expo下，翻墙用的蓝灯，试了好多root软件都是，一键root expo 的应用不能装apk么，都是内嵌到那个expo应用里的？ expo可以在ios模拟器跑，但是好像好慢的样子？通过create-react-native-app AwesomeProject 那个cli\b创建的项目，啥都没有ios android文件夹都没有,执行了yarn start之后 也产生了.expo文件那么如何部署？通过create-react-native-app出来的项目，执行yarn start得到一个二维码，用expo能扫开，很方便.\b通过yarn run android连上真机的话，即为进行了真机debug,如果不连真机的话，得到一个这样的错12Error running adb: No Android device found. Please connect a device and follow the instructions here to enable USB debugging:https://developer.android.com/studio/run/device.html#developer-device-options. If you are using Genymotion go to Settings -&gt; ADB, select \"Use custom Android SDK tools\", and point it at your Android SDK directory. 进行yarn run ios：会打开模拟器1234$ react-native-scripts ios00:32:00: Starting packager...00:32:11: Starting simulator...Found Xcode 7.3.0, which is older than the recommended Xcode 8.2.0. 我已经装了xcode 8.3.3为什么有这个提示？而且文件结构永远没有ios,android文件，用的是expo 如果这样初始项目1react-native init AwesomeProject 会有ios android文件夹，npm 还会自动install?执行react-native run-ios得到build failed \b结果，但是通过xcode打开项目，进行run，却能正常\b打开模拟器，\b打开项目，通过命令就报错：1234567891011121314151617** BUILD FAILED **The following build commands failed: CompileC /Users/liyangtao/testProject/AwesomeProject/ios/build/Build/Intermediates/React.build/Debug-iphonesimulator/React.build/Objects-normal/x86_64/RCTTabBarItem.o Views/RCTTabBarItem.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler(1 failure)Installing build/Build/Products/Debug-iphonesimulator/AwesomeProject.appAn error was encountered processing the command (domain=NSPOSIXErrorDomain, code=2):Failed to install the requested applicationAn application bundle was not found at the provided path.Provide a valid path to the desired application bundle.Print: Entry, \":CFBundleIdentifier\", Does Not ExistCommand failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/AwesomeProject.app/Info.plistPrint: Entry, \":CFBundleIdentifier\", Does Not Exist 12lsof -n -i4TCP:8081kill - 9 xxxx (issuse:https://github.com/facebook/react-native/issues/7308#issuecomment-219597774)有可能跟react-native的版本有关 从0.24版本开始，react-native还需要额外安装react模块，且对react的版本有严格要求，高于或低于某个范围都不可以。本文无法在这里列出所有react native和对应的react模块版本要求，只能提醒读者先尝试执行npm install，然后注意观察安装过程中的报错信息，例如require react@某.某.某版本, but none was installed，然后根据这样的提示，执行npm install react@某.某.某版本 –save。 还有貌似我在任何文件件都能\b执行react-native如果react-native run-android那么1Downloading https://services.gradle.org/distributions/gradle-2.14.1-all.zip 都会去下载一次，好慢，1&gt; java.lang.UnsupportedClassVersionError: com/android/build/gradle/AppPlugin : Unsupported major.minor version 52.0 而且会有这个错误解决办法是：\b我的jdk是1.7的，升级为1.8就好了(https://stackoverflow.com/questions/42874971/react-native-build-error-android-java-lang-unsupportedclassversionerror-com-a)12345678910111213141516171819up vote6down voteacceptedAt last figured out the problemcheck $JAVA_HOMENeed JDK 1.8 to workInstall Java JDK 1.8 and change the JAVA_HOMEedit ~/.bashrc and add JDK 1.8 path as JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-oracle/jre/and source ~/.bashrc close the current terminal window/tab and runreact-native run-android 问题：react-native-cli是啥？local-cli是啥？react-native-cli为什么要全局装？react-native为什么要局部装？装的版本有什么要求么（遇到一个坑，在很老的项目中，react-native包含了react,之后分离了）eject是个啥？react-native upgrade能干啥？答： 新版本的npm包通常还会包含一些动态生成的文件，这些文件是在运行react-native init创建新项目时生成的，比如iOS和Android的项目文件。为了使老项目的项目文件也能得到更新（不重新init），你需要在命令行中运行： $ react-native upgrade这一命令会检查最新的项目模板，然后进行如下操作： 如果是新添加的文件，则直接创建。如果文件和当前版本的文件相同，则跳过。如果文件和当前版本的文件不同，则会提示你一些选项：查看两者的不同，选择保留你的版本或是用新的模板覆盖。你可以按下h键来查看所有可以使用的命令。译注：如果你有修改原生代码，那么在使用upgrade升级前，先备份，再覆盖。覆盖完成后，使用比对工具找出差异，将你之前修改的代码逐步搬运到新文件中。123react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios \b这样得到的应用是有ios文件么？ ps aux | grep react-native 不要随意关app，\b调试可以删掉app重来 android\b无法naitive debug?? cp ./gradle.properties /Users/liyangtao/work/dux-rn/duxRnTest/android/app","tags":[{"name":"react-native","slug":"react-native","permalink":"http://07lyt.com/tags/react-native/"}]},{"title":"redux源码分析及自己实现","date":"2017-06-19T13:20:52.000Z","path":"2017/06/19/redux解析/","text":"在介绍redux源码前，先来提几个问题： \bdispatch做了什么 订阅状态改变是怎么实现的？ 状态树是怎样产生的？ dispatch出去的action是怎么过中间件的？ 中间是怎么串起来的，执行顺序是如何的？ 为什么源码中不用for来设计中间件? 中间件的设计是否\u001d对应了哪种设计模式？ 中间件compose为什么要从后往前包装，得到的\b新dispatch为什么又是从前到后的？ 假如2个store,\b\b哪些部分是独立的？哪些部分是可复用的？ 源码赏析先回答第一第二个问题 \bdispatch做了什么 订阅状态改变是怎么实现的？ dispatch只做了两件很微小的工作: 根据\b之前state生成新state（执行reducer/一般为rootreducer） 触发订阅函数 如下：12345678910111213141516171819202122function dispatch(action) &#123; currentState = currentReducer(currentState, action); for (let i = 0; i &lt; currentListeners.length; i++) &#123; currentListeners[i](); &#125; return action;&#125;function subscribe(listener) &#123; let index = 0; for (let i = 0; i &lt; currentListeners.length; i++) &#123; //如果有不做操作 if (listener == currentListeners[i]) &#123; index = i; return; &#125; &#125; index = currentListeners.push(listener) - 1; return function unsubscribe() &#123; currentListeners.splice(index, 1); &#125;;&#125; 再来看一个问题： 状态树是怎样产生的？我们在使用redux的\b时候，要产生状态树，需要用到redux中的combineReducer函数，那么可以先想一下，这个函数接受一个对象，返回一个新函数，作为一个新reducer存在，这个新reducer的状态应该是啥？从库的角度来说，它不可能有状态，所以状态只跟我们传入的参数有关，我们传入了多个reducer,怎么\b合成这些\breducer?所以用个对象hashMap就好,每个key对应一个子reducer，这个combineReducer只负责承接\b状态的转手合成，状态的生成都是reducer得到。 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。简单实现如下：12345678910111213export default function combineReducers(reducers)&#123; let keysOfreducers = Object.keys(reducers); return function newReducer(state=&#123;&#125;,action)&#123; let newState= &#123;&#125; for(let i=0;i&lt;keysOfreducers.length;i++)&#123; let key = keysOfreducers[i]; //可以看到我们传入进去的是父state的各个key，从而子\breducer不需要关心父reducer的存在 let singleReducerState = state[key]; newState[key] = reducers[key](singleReducerState,action); &#125; return newState; &#125;&#125; 中间件部分（重点）中间作为是作为源码中比较难读的一部分，涉及到一些函数式的编程都在里面，中间件也是redux相当强大的部分，下面详细说下：从中间件\b的签名说起：第一眼\b看到这种中间件结构，其实是奔溃的。。12345678const xxxxMiddleware = (&#123;getState,dispatch&#125;)=&gt;next=&gt;action=&gt; &#123;&#125;function xxxxMiddleware(&#123;getState,dispatch&#125;) &#123; return function (next) &#123; return function (action) &#123;...&#125; &#125;&#125; 那么能不能改成这样的呢? 123function xxxxMiddleware(&#123;getState,dispatch&#125;,next,action)&#123; &#125; 或者这样？123function xxxxMiddleware(&#123;getState,dispatch&#125;)=&gt;(next,action)=&gt;&#123; &#125; 答案是\b当然可以,那么我们来改造一下源码:(加入了curry化 和 compose的实现)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import R from 'ramda';/* ---------------------util---------------------*/var curryMy = function(fn) &#123; var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; return function() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; if (args.length &gt;= fn.length) &#123; return fn.apply(window, args); &#125; else &#123; return curryMy.apply(window, [fn].concat(args)); &#125; &#125;;&#125;;function compose(curryedMiddwares, func) &#123; let pre = func; for (let i = 0; i &lt; curryedMiddwares.length; i++) &#123; let curryedMiddware = curryedMiddwares[curryedMiddwares.length - 1 - i]; //不断把后一个的结果保存到前一个中 pre = curryedMiddware(pre); &#125; return pre;&#125;/*-----------------applyMiddleware----------------------------------*/export default function applyMiddleware(...middlewares) &#123; return creatStore =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; let store = creatStore(reducer, preloadedState, enhancer); if (middlewares[0].length == 3) &#123; /* 对应以下情况： function (&#123;getState,dispatch&#125;,next,action)&#123; &#125; */ middlewares = middlewares.map(middleware =&gt; &#123; return R.curry(middleware); &#125;); &#125; let injectedMiddlewares = middlewares.map(middleware =&gt; &#123; return middleware(&#123; getState, dispatch: action =&gt; store.dispatch(action), &#125;); &#125;); let curryedMiddwares = injectedMiddlewares; if (injectedMiddlewares[0].length &gt; 1) &#123; /* 对应以下情况： function (&#123;getState,dispatch&#125;)=&gt;(next,action)=&gt;&#123; &#125; */ curryedMiddwares = injectedMiddlewares.map(middware =&gt; &#123; //这里也可以用R.curry return curryMy(middware); &#125;); &#125; //包装dispatch,使得dispatch一个action的时候，能过中间件 //R.compose || compose 任选一个 //R.compose(...curryedMiddwares)(dispatch) let dispatch = R.curry(compose)(curryedMiddwares)(store.dispatch); return &#123; ...store, dispatch, &#125;; &#125;;&#125; 我们自己实现了一遍applyMiddleware可以看到我们用到了2个函数式编程中非常重要的概念： curry化 compose组合 简单介绍下这两者先说柯里化： \b有n个参数的单个函数转换成有\b单个参数的\u001c\bn个函数 简单例子：123456789101112add(x,y)&#123; return x+y&#125;let curry_add = R.curry(add)/* 调用*/let add20 = curry_add(20);add20(30) //return 50curry_add(10)(10) //return 20 先转换一下思路，function作为F\b\bunction的实例，\b可以向变量一样到处传递的，且function作为变量有一个非常重要的功能：存储12let add20 = curry_add(20);add20(30) //return 50 可以看到我们把20存储了下来，之后的函数保存的\b有20这个值了 curry化的意义:只传递给函数\b一部分参数来调用他，让他返回一个函数去处理剩下的参数，一句话： 保存参数，延迟执行，局部调用 ps:自己实现R.curry可以用递归去做 再说组合1234567let g= (str) =&gt; parseInt(str)let f= (num) =&gt; !!numf(g('0')) //falselet composed_f_g = R.compose(f,g)composed_f_g('0') //false 在大致\b了解了这两个概念后：来看我们的applyMiddleware由于柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，所以不管我们的中间件函数签名如何，\b都要进行科里\b化，目的是存储变量（即为存储next函数，下一个中间件的执行函数），\b延迟执行。 看一个例子(已curry化)：12345678910111213141516171819202122232425262728293031323334353637//Afunction A(&#123;getState,dispatch&#125;)&#123; return function A(next) &#123; return function A(action) &#123; console.log('A before next') next(action); console.log('A after next') return 'A'; &#125; &#125;&#125;//Bfunction B(&#123;getState,dispatch&#125;)&#123; return function B(next) &#123; return function B(action) &#123; console.log('B before next') next(action); console.log('B after next') return 'B'; &#125; &#125;&#125;//Cfunction C(&#123;getState,dispatch&#125;)&#123; return function C(next) &#123; return function C(action) &#123; console.log('C before next') next(action); console.log('C after next') return 'C'; &#125; &#125;&#125;//串联中间件applyMiddleware(A,B,C) 看看源码123456789 var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;//注入api chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))//合成 dispatch = compose(...chain)(store.dispatch) 一开始把middlewareAPI注入，得到一个部分执行的函数，保存了api(体现了存储的功能)12345678function B(next) &#123; return function B(action) &#123; console.log('B before next') next(action); console.log('B after next') return 'B'; &#125;&#125; 再来看关键的一步1dispatch = compose(...chain)(store.dispatch) 123\bdispatch = compose(A,B,C)(store.dispatch) 等价于dispatch = A(B(C(store.dispatch))) 下面我们来暴力展开下1234567891011121314C(store.dispatch) //得到function C(action) &#123; console.log('C before next') /* 替换next */ store.dispatch(action); /* 替换next */ console.log('C after next') return 'C';&#125; 123456789101112131415161718B(C(store.dispatch))//得到 function B(action) &#123; console.log('B before next') /* 替换next */ console.log('C before next') store.dispatch(action); console.log('C after next') //C的返回 这不是真的返回 return 'C'; /* 替换next */ console.log('B after next') return 'B'; &#125; 123456789101112131415161718192021222324252627282930//再执行dipatch = A(B(C(store.dispatch))) //得到新的dispatchdipatch = function A(action) &#123; console.log('A before next') /* 再次替换next */ console.log('B before next') /* 替换next */ console.log('C before next') //原来的dispatch在这里 store.dispatch(action); console.log('C after next') //C的返回 这不是真的返回 return 'C'; /* 替换next */ console.log('B after next') //B的返回 这不是真的返回 return 'B'; /* 再次替换next */ console.log('A after next') return 'A';&#125; \b所以我们可以抽象出来中间件是怎么执行的：如下：看到这里好像发现了什么，这不是跟koa的co实现类似吗？可以回答：一模一样。所以网上有一种说法，叫做洋葱模型（onion model） compose的实现有很多，不止一种 看看之前的koa的compose: 12345678910111213function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;&#125; 以及我们的compose: 123456789function compose(curryedMiddwares, func) &#123; let pre = func; for (let i = 0; i &lt; curryedMiddwares.length; i++) &#123; let curryedMiddware = curryedMiddwares[curryedMiddwares.length - 1 - i]; //不断把后一个的结果保存到前一个中 pre = curryedMiddware(pre); &#125; return pre;&#125; 我们的compose好像接受了额外参数？没关系，我们科里化它就好R.curry(compose) 最后是redux自身的compose:1234567891011121314export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) //把从最后一个开始计算的结果依次往前传递 return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; 那么源码1dispatch = compose(...chain)(store.dispatch) 就很清楚了，如下图，我们包装了老的dispatch,得到了一个新的dispatch,调用这个新的dispatch，就顺次执行了中间\b\b件中的函数，对开发\b来说这个新的dispatch是透明的 值得\b一提的是redux的applyMiddleware叫做(higher-order store)其他的 higher-order store还有devTools等，看下面一个例子：12345const newCreateStore = compose( applyMiddleware(m1, m2, m3), devTools, createStore); 我们通过applyMiddleware,devTools把原有createStore的能力提升了 注意点：小心在中间件中dispatch(action)如下图，可能有死循环 设计不好一不小心就爆栈，假如在中间件中dispatch(action)，这个action又重头开始依次经过中间件，\b遇到这个中间件，又重头开始，形成死循环。所以一般的建议是： 最好清楚dispatch action的路径 像\bthunk-middleware一样注入dispatch给业务，中间件不关心dispatch 几个问题：源码中 var middlewareAPI = { \b getState: store.getState, dispatch: (action) =&gt; dispatch(action) } 为什么不写成： var middlewareAPI = { \b getState: store.getState, dispatch: dispatch } 为什么要用函数包一下？只有包装过，才会永远等于store.dispatch,来看一张图，如果不包装的话,我们在进行compose之前，都是得到的旧dispatch,传入middware后，middware中的dispatch将\b一直指向那边老的内存区域\b，而新的dispatch得执行了compose之后才能得到，如果用闭包，传入的dipatch将一直引用最新的store.dispatch 中间是怎么串起来的，执行顺序是如何的？利用组合，从左到右执行 为什么源码中不用for来设计中间件?1.不能回溯，\b在中间交出控制权2.\b中间件没有控制权（但是控制能力可以用类似于事件冒泡那样去实现），不能进行向下走的控制,\b因而没有异步能力 中间件的设计是否\u001d对应了哪种设计模式？1.职责链 中间件compose为什么要从后往前包装？ 从后往前包装是为了保存next函数，不从后往前的话，当前中间件的next函数无法确立，因为next函数就是后一个中间件的执行代码 得到的\b新dispatch为什么又是从前到后的？因为最后一个包装的在最外层，因而可以先得到执行，从而得到从前到后的效果。 假如2个store,\b\b哪些部分是独立的？哪些部分是可复用的？除了中间件可以复用，其他都是独立的。 http://cn.redux.js.org/docs/faq/Performance.html http://redux.js.org/docs/recipes/ImplementingUndoHistory.html","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"class语法糖分析","date":"2017-06-14T13:20:52.000Z","path":"2017/06/14/class语法糖分析/","text":"class语法糖分析比较好奇class到es5 babel是怎么转换的 123456789101112131415161718192021222324252627282930313233 class Base &#123; constructor (name) &#123; this.name = name &#125; state=&#123; isMan:false &#125; keepQuiet()&#123; console.log('base---&gt;………………………………') &#125; alert()&#123; alert('base---&gt;alert') &#125;&#125;&lt;!--more--&gt;class child extends Base&#123; constructor(name,age) &#123; super(name); this.age= age; &#125; buySomething=()=&gt;&#123; console.log('child buy') &#125; alert()&#123; alert('child-----&gt;alert') &#125;&#125;new child('titan',80) 生成的代码如下：重点看下_createClass，_inherits方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171('use strict');//获得一个对象的某个属性//prototype,'constructor',thisvar _get = function get(_x, _x2, _x3) &#123; var _again = true; _function: while (_again) &#123; var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) &#123; var parent = Object.getPrototypeOf(object); if (parent === null) &#123; return undefined; &#125; else &#123; _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; &#125; &#125; else if ('value' in desc) &#123; //这个desc.value是Base的构造函数 return desc.value; &#125; else &#123; //这个应该是只针对可读的 var getter = desc.get; if (getter === undefined) &#123; return undefined; &#125; return getter.call(receiver); &#125; &#125;&#125;;var _createClass = (function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; //闭包 return function(Constructor, protoProps, staticProps) &#123; //真正的构造执行的地方 //定义原型属性 //传入的protoProps是一个对象，babel都会生成对应的key,value属性 if (protoProps) defineProperties(Constructor.prototype, protoProps); //定义静态属性，直接挂载在Constructor上 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;)();function _inherits(subClass, superClass) &#123; if (typeof superClass !== 'function' &amp;&amp; superClass !== null) &#123; throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); &#125; //创建一个空对象，对象的__proto__指向superClass.prototype，传统继承模式 /* create 的第二个参数： propertiesObject 可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。 prototype上有constructor属性 */ subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125;, &#125;); //getPrototypeOf ------ setPrototypeOf if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError('Cannot call a class as a function'); &#125;&#125;var Base = (function() &#123; function Base(name) &#123; _classCallCheck(this, Base); this.state = &#123; isMan: false, &#125;; this.name = name; &#125; _createClass(Base, [ &#123; key: 'keepQuiet', value: function keepQuiet() &#123; console.log('base---&gt;………………………………'); &#125;, &#125;, &#123; key: 'alert', value: (function(_alert) &#123; function alert() &#123; //递归情况 return _alert.apply(this, arguments); &#125; alert.toString = function() &#123; return _alert.toString(); &#125;; return alert; &#125;)(function() &#123; alert('base---&gt;alert'); &#125;), &#125;, ]); return Base;&#125;)();var child = (function(_Base) &#123; //继承Base _inherits(child, _Base); function child(name, age) &#123; _classCallCheck(this, child); /* _get(Object.getPrototypeOf(child.prototype), 'constructor', this) 得到Base的构造函数，通过call注入this得到父类的属性，name */ _get(Object.getPrototypeOf(child.prototype), 'constructor', this).call(this, name); //箭头函数在这声明 this.buySomething = function() &#123; console.log('child buy'); &#125;; this.age = age; &#125; //在自己的原型上，覆盖了父类的alert _createClass(child, [ &#123; key: 'alert', value: (function(_alert2) &#123; function alert() &#123; return _alert2.apply(this, arguments); &#125; alert.toString = function() &#123; return _alert2.toString(); &#125;; return alert; &#125;)(function() &#123; alert('child-----&gt;alert'); &#125;), &#125;, ]); return child;&#125;)(Base);new child('titan', 80);","tags":[{"name":"babel","slug":"babel","permalink":"http://07lyt.com/tags/babel/"}]},{"title":"diff算法的简单实现","date":"2017-06-14T09:20:52.000Z","path":"2017/06/14/diff算法的简单实现/","text":"12let diffchange = diffList([&#123; key: 1 &#125;, &#123; key: 2 &#125;], [&#123; key: 33 &#125;, &#123; key: 1 &#125;, &#123; key: 3 &#125;], 'key');console.log('diffchange', diffchange); 123第一步 add：[&#123;key:33&#125;,&#123; key: 1 &#125;, &#123; key: 2 &#125;]第二步 add：[&#123;key:33&#125;,&#123; key: 1 &#125;,&#123; key: 3 &#125;, &#123; key: 2 &#125;],第三步 remove：[&#123;key:33&#125;,&#123; key: 1 &#125;,&#123; key: 3 &#125;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//这个list要一个key,如果没有key,则移除所有的旧的元素，增加新的元素function diffList(oldList, newList, key) &#123; var move = function(list, from, to) &#123; var item = list.splice(from, 1); if (from &gt; to) list.splice(to + 1, 0, item[0]); else list.splice(to, 0, item[0]); &#125;; let changes = []; let lastIndex = 0; let copy_oldList = _.cloneDeep(oldList); for (var index = 0; index &lt; newList.length; index++) &#123; var elementKeyValue = newList[index][key]; if (elementKeyValue) &#123; let findedIndex = _.findIndex(oldList, &#123; [key]: elementKeyValue &#125;); if (findedIndex == -1) &#123; //老集合没有这个key的值 //增加 changes.push(&#123; type: 'add', index: index, item: newList[index], &#125;); //插入copyed copy_oldList.splice(index, 0, newList[index]); &#125; else &#123; //老集合有这个object,key一样 //移动 if (findedIndex &gt;= lastIndex) &#123; //not move &#125; else &#123; //move let item = oldList[findedIndex]; let findedIndexCopyList = _.findIndex(copy_oldList, &#123; [key]: item[key] &#125;); // changes.push(&#123; // type: 'move', // from: findedIndexCopyList, // to: index, // &#125;); /* var item = list.splice(from, 1); if (from &gt; to) list.splice(to + 1, 0, item[0]); else list.splice(to, 0, item[0]); */ //删除from 插入 to changes.push(&#123; type: 'remove', index: findedIndexCopyList, &#125;); changes.push(&#123; type: 'add', index: index, item: item, &#125;); move(copy_oldList, findedIndexCopyList, index); &#125; lastIndex = Math.max(lastIndex, findedIndex); &#125; &#125; else &#123; //没有key的话 强行加入 changes.push(&#123; type: 'add', index: index, item: newList[index], &#125;); copy_oldList.splice(index, 0, newList[index]); &#125; &#125; for (var indexDelte = 0; indexDelte &lt; oldList.length; indexDelte++) &#123; var oldItem = oldList[indexDelte]; if (!oldItem[key]) &#123; //如果没有key changes.push(&#123; type: 'remove', index: newList.length+indexDelte &#125;); continue; &#125; let findedIndex = _.findIndex(newList, &#123; [key]: oldItem[key] &#125;); if (findedIndex == -1) &#123; //新的没找到，说明这个老的要删除掉 changes.push(&#123; type: 'remove', index: _.findIndex(copy_oldList, &#123; [key]: oldItem[key] &#125;), &#125;); let findedIndex = _.findIndex(copy_oldList, &#123; [key]: oldItem[key] &#125;); copy_oldList.splice(findedIndex, 1); &#125; &#125; return changes;&#125;//let diffchage = diffList([&#123; key: 1 &#125;, &#123; key: 2 &#125;], [&#123; key: 2 &#125;, &#123; key: 1 &#125;, &#123; key: 3 &#125;], 'key');//没有key的情况//let diffchage = diffList([&#123; key: 1 &#125;, &#123; key: 2 &#125;], [&#123; key: 33 &#125;, &#123; key: 1 &#125;, &#123; key: 3 &#125;], 'key111');let diffchange = diffList([&#123; key: 1 &#125;, &#123; key: 2 &#125;], [&#123; key: 33 &#125;, &#123; key: 1 &#125;, &#123; key: 3 &#125;], 'key');console.log('diffchange', diffchange);","tags":[{"name":"算法","slug":"算法","permalink":"http://07lyt.com/tags/算法/"}]},{"title":"JavaScript中存在纯函数吗？","date":"2017-06-12T13:20:52.000Z","path":"2017/06/12/javascript纯函数/","text":"JavaScript中存在纯函数吗?(自译) https://hackernoon.com/do-pure-functions-exist-in-javascript-b128ed5f0ed2 什么是纯函数？满足下面两个条件：1) The function returns exactly the same result every time it’s called with the same set of arguments.2) Evaluation of the function does not modify some state outside its scope nor has an observable interaction with the outside world besides returning a value. (No side effects.) Sometimes, a third condition is added: ‘Relies on no external mutable state.’ This, in fact, is redundant as such dependency on mutable variable would inevitably lead to breaking the first condition, too. 有下面四个函数 doubleA doubleB doubleC doubleD1234567891011121314151617181920212223// A: Simple multiplicationfunction doubleA(n) &#123; return n * 2&#125;// B: With a variablevar two = 2function doubleB(n) &#123; return n * two&#125;// C: With a helper functionfunction getTwo() &#123; return 2&#125;function doubleC(n) &#123; return n * getTwo()&#125;// D: Mapping an arrayfunction doubleD(arr) &#123; return arr.map(n =&gt; n * 2)&#125; 大多数人认为doubleB不纯，doubleA, doubleC, doubleD 为纯函数. 123doubleB(1) // -&gt; 2two = 3doubleB(1) // -&gt; 3 \b可以知道doubleB\b不纯 然而事实上：上述4个函数都不纯？为什么？ 对于doubleC 123doubleC(1) // -&gt; 2getTwo = function() &#123; return 3 &#125;doubleC(1) // -&gt; 3 对于doubleD “Map, filter, reduce. Repeat.”在函数式编程中是核心的数据变换方法，在用到他们的时候应该谨慎 12345doubleD([1]) // -&gt; [2]Array.prototype.map = function() &#123; return [3]&#125;doubleD([1]) // -&gt; [3] 两次调用结果不一致，因而doubleD也不纯。 doubleA 乘法操作符是纯的？？？ 有个不常用的点：JavaScript also calls valueOf method of an object when it expects a number (or a boolean, or a function). What’s left is to make this function return different value each time it is invoked. 12345var o = &#123; valueOf: Math.random&#125;doubleA(o) // -&gt; 1.7709942335937932doubleA(o) // -&gt; 1.2600863386367704 因而 doubleA不纯 \b#### 到底什么是纯函数？ 没有绝对的定义，一个函数可能在一个项目\b里纯，在其他项目里不纯 备注：一些\b阻止上述\b小伎俩的手段：对于doubleB：123456var doubleB = (function () &#123; var two = 2 return function (n) &#123; return n * two &#125;&#125;)() 或是 12const two = 2const doubleB = (n) =&gt; n * two 对于doubleA 1234function doubleA(n) &#123; if (typeof n !== 'number') return NaN return n * 2&#125; 总之不要忘记保证一个函数真正的为纯函数","tags":[{"name":"自译","slug":"自译","permalink":"http://07lyt.com/tags/自译/"}]},{"title":"2个字符串的编辑距离（Levenshtein_distance）","date":"2017-06-04T13:20:52.000Z","path":"2017/06/04/diff的o(m*n)/","text":"在react中，在render后的diff阶段，对一个列表进行了diff比较，react的实现比较高效，是o(n)量级，一种通用的diff是类似于求两个字符串的编辑距离(o(m*n)),参考： https://en.wikipedia.org/wiki/Levenshtein_distance 比如要计算cafe和coffee的编辑距离，cafe→caffe→coffe→coffee，要经过3次转变。 动态规划解决思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* Utils*/function replareStr(word1, pos, char) &#123; let newWord = ''; for (let i = 0; i &lt; word1.length; i++) &#123; if (i == pos) &#123; newWord += char; &#125; else &#123; newWord += word1[i]; &#125; &#125; return newWord;&#125;function deleteStr(word1, pos) &#123; let newWord = ''; for (let i = 0; i &lt; word1.length; i++) &#123; if (i == pos) &#123; // ddnewWord+=char; &#125; else &#123; newWord += word1[i]; &#125; &#125; return newWord;&#125;function insterStr(word1, pos, char) &#123; let newWord = ''; if (pos &lt; 0) newWord += char; for (let i = 0; i &lt; word1.length; i++) &#123; newWord += word1[i]; if (i == pos) &#123; newWord += char; &#125; &#125; return newWord;&#125;/* * 需要把word1 变到 word2 * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;array&#125; 表示从word1 改变到 word2 中间要过渡的字符串组 */var minDistance = function(word1, word2) &#123; let rowNumber = word1.length + 1; let columnNumber = word2.length + 1; let DP = []; /* init dp */ for (let i = 0; i &lt; rowNumber; i++) &#123; let temp = Array(columnNumber); if (i == 0) &#123; for (let j = 0; j &lt; columnNumber; j++) &#123; temp[j] = j; &#125; &#125; else &#123; temp[0] = i; &#125; DP.push(temp); &#125; for (let i = 1; i &lt; rowNumber; i++) &#123; for (let j = 1; j &lt; columnNumber; j++) &#123; let first, second, third; if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; first = DP[i - 1][j - 1]; &#125; else &#123; first = DP[i - 1][j - 1] + 1; &#125; second = DP[i][j - 1] + 1; third = DP[i - 1][j] + 1; DP[i][j] = Math.min(first, second, third); &#125; &#125; let internalwords = []; let endRow = rowNumber - 1; let endColumn = columnNumber - 1; let numberOperation = DP[endRow][endColumn]; while (numberOperation) &#123; let isOperated = false; let duijiao = Infinity; let above = Infinity; let left = Infinity; if (endRow - 1 &lt; 0) &#123; duijiao = Infinity; above = Infinity; &#125; else &#123; if (endColumn - 1 &gt;= 0) &#123; duijiao = DP[endRow - 1][endColumn - 1]; &#125; else &#123; duijiao = Infinity; &#125; above = DP[endRow - 1][endColumn]; &#125; if (endColumn - 1 &lt; 0) &#123; left = Infinity; &#125; else &#123; left = DP[endRow][endColumn - 1]; &#125; let min = Math.min(duijiao, above, left); if (min == duijiao) &#123; isOperated = true; endRow = endRow - 1; endColumn = endColumn - 1; if (duijiao &lt; numberOperation) &#123; //如果小于则替换，不小于不做操作 let newword1 = word1; let tobechar = word2.charAt(endColumn); internalwords.push((word1 = replareStr(newword1, endRow, tobechar))); &#125; &#125; else if (min == above &amp;&amp; !isOperated) &#123; //删除above isOperated = true; endRow = endRow - 1; internalwords.push((word1 = deleteStr(word1, endRow))); &#125; else if (min == left &amp;&amp; !isOperated) &#123; //向左添加 isOperated = true; endColumn = endColumn - 1; let tobeinsertChar = word2.charAt(endColumn); internalwords.push((word1 = insterStr(word1, endRow - 1, tobeinsertChar))); &#125; numberOperation = DP[endRow][endColumn]; &#125; return internalwords;&#125;;//let interwords = minDistance('sunday', 'saturday');//let interwords = minDistance('sitting', 'kitten');let interwords = minDistance('a12234', '1234');console.log('interwords', interwords);/* 2步 interwords (2) [\"a1234\", \"1234\"]*/ 从sunday——&gt;saturday,需要3步[“surday”, “sturday”, “saturday”]从sitting——&gt;kitten，需要3步[“sittin”, “sitten”, “kitten”]从a12234——&gt;1234，需要2步[“a1234”, “1234”]","tags":[{"name":"算法 动态规划","slug":"算法-动态规划","permalink":"http://07lyt.com/tags/算法-动态规划/"}]},{"title":"react-redux源码分析","date":"2017-05-28T13:20:52.000Z","path":"2017/05/28/react-redux/","text":"react-redux(4.4.5)react-reudx 5.0+的版本已经进行了比较大的重构，这里主要介绍v4的版本 providerprovider主要做了传递store的事情，通过在parent组件内，使用getChildContext方法，这个方法可以把相应的属性隐式往下传，子组件及子组件的子组件都可以获得此属性 1234567891011121314export default class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.store &#125; &#125; constructor(props, context) &#123; super(props, context) this.store = props.store &#125; render() &#123; return Children.only(this.props.children) &#125;&#125; 从Provider的代码中可以看到在构造函数初始化的时候将store赋了值，之后通过getChildContext将值往下传递还要注意childContextTypes需要声明出用到的属性12345678/*Index.childContextTypes=&#123; name: React.PropTypes.string.isRequired&#125;*/Provider.childContextTypes = &#123; store: storeShape.isRequired&#125; 如同在connect中也要声明用到的context,如下12345678/*ScrollBar.contextTypes=&#123; name:React.PropTypes.string&#125;*/ Connect.contextTypes = &#123; store: storeShape &#125; https://react.bootcss.com/react/docs/higher-order-components.html connect干了什么？connect雏形 12345678910111213141516171819202122232425262728293031import React, &#123; Component, PropTypes &#125; from 'react';function connect(mapStateToProps, mapDispatchToprops, ownerProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; class Connect extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125; shouldComponentUpdate(nextProps, nextState) &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentDidUpdate(prevProps, prevState) &#123;&#125; componentWillUnmount() &#123;&#125; render() &#123; return &lt;wrappedComponent&gt;&lt;/wrappedComponent&gt;; &#125; &#125; Connect.contextTypes = &#123;&#125;; return Connect &#125;;&#125; 1connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;&#125; 首先connect接受4个参数，第一个参数是要把对应的state映射到组件props的函数，第二个是把dipatch过程映射到props上的函数或者对象，第三个参数是把state映射到的props和dispatch映射到的props合成到一个props并最终注入到组件component中的方法，他们都有对应的默认实现，如下注意在源码中Returning object literals的写法1234567const defaultMapStateToProps = state =&gt; (&#123;&#125;) // eslint-disable-line no-unused-varsconst defaultMapDispatchToProps = dispatch =&gt; (&#123; dispatch &#125;)const defaultMergeProps = (stateProps, dispatchProps, parentProps) =&gt; (&#123; ...parentProps, ...stateProps, ...dispatchProps&#125;) mapStateToProps默认返回一个空对象，不做任何state转换，mapDispatchToProps默认注入dispatch方法，mergeProps默认合并state映射到的props，dispatch映射到的props以及自身的props。 12345678910111213141516171819202122export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123; const shouldSubscribe = Boolean(mapStateToProps) const mapState = mapStateToProps || defaultMapStateToProps //dispatch let mapDispatch if (typeof mapDispatchToProps === 'function') &#123; //函数执行，得到一个object注入到组件的props中 mapDispatch = mapDispatchToProps &#125; else if (!mapDispatchToProps) &#123; mapDispatch = defaultMapDispatchToProps &#125; else &#123; //对象传入，包装为一个function，执行完成后得到一个object，这个object就将注入到组件的props中 mapDispatch = wrapActionCreators(mapDispatchToProps) &#125; //[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 官方要求是一个function const finalMergeProps = mergeProps || defaultMergeProps const &#123; pure = true, withRef = false &#125; = options //如果不传第三个参数，checkMergedEquals为false,这个flag将会影响最后的mergedProps的计算，使得每次都要重新render一个新的component const checkMergedEquals = pure &amp;&amp; finalMergeProps !== defaultMergeProps // Helps track hot reloading. const version = nextVersion++ 对不同类型的mapDispatchToProps进行包装，包括对象，与函数形式，使得得到的mapDispatch是一个function connnect组件作为一个Component的wrapper,或者称为HOC（high order component），其负责处理store状态的变化，并选择渲染组件,在构造时拿到全局的store12345678constructor(props, context) &#123; super(props, context) this.version = version this.store = props.store || context.store const storeState = this.store.getState() this.state = &#123; storeState &#125; this.clearCache() &#125; 先初始connnect的状态为全局状态 有几个问题 1.组件如何知道store的变化？2.组件如何处理自身props的变化？3.mapStateToProps是如何注入到props中的呢4.mapDispatchToProps是如何注入到props中的呢 首先connect组件render的时候会去读一些状态1234567const &#123; haveOwnPropsChanged, hasStoreStateChanged, haveStatePropsBeenPrecalculated, statePropsPrecalculationError, renderedElement &#125; = this 由于在construct的时候进行了clear123456789101112clearCache() &#123; this.dispatchProps = null this.stateProps = null this.mergedProps = null this.haveOwnPropsChanged = true this.hasStoreStateChanged = true this.haveStatePropsBeenPrecalculated = false this.statePropsPrecalculationError = null this.renderedElement = null this.finalMapDispatchToProps = null this.finalMapStateToProps = null &#125; 读到的值将为true,true,false,null,null connect中提供了三个重要的对象this.stateProps,this.dispatchProps,this.mergedPropsthis.stateProps用来保存mapStateToProps的转换结果，这里类似于一个小reducerthis.dispatchProps用来保存mapDispatchToProps的转换结果this.mergedProps 用于最后挂载到component上的props这三个对象this.stateProps,this.dispatchProps,this.mergedProps 分别于updateStatePropsIfNeededupdateDispatchPropsIfNeededupdateMergedPropsIfNeeded得到更新只要这3个函数中的某一个执行一次，对应的mapStateToProps, mapDispatchToProps, mergeProps都会相应执行一次 1234567891011121314151617181920212223242526272829/* 步骤： 1.判断是否应该更新this.stateProps this.dispatchProps 2.this.stateProps this.dispatchProps是否变更*/ //先声明变量默认值 let shouldUpdateStateProps = true let shouldUpdateDispatchProps = true //如果之前render过，则计算一下是否需要更新this.stateProps this.dispatchProps if (pure &amp;&amp; renderedElement) &#123; shouldUpdateStateProps = hasStoreStateChanged || ( haveOwnPropsChanged &amp;&amp; this.doStatePropsDependOnOwnProps ) shouldUpdateDispatchProps = haveOwnPropsChanged &amp;&amp; this.doDispatchPropsDependOnOwnProps &#125; let haveStatePropsChanged = false let haveDispatchPropsChanged = false //haveStatePropsBeenPrecalculated在这里是一个保存是否先前计算过的flag if (haveStatePropsBeenPrecalculated) &#123; haveStatePropsChanged = true &#125; else if (shouldUpdateStateProps) &#123; haveStatePropsChanged = this.updateStatePropsIfNeeded() &#125; if (shouldUpdateDispatchProps) &#123; haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded() &#125; selector 的作用就是为 React Components 构造适合自己需要的状态视图。selector 的引入，降低了 React Component 对 Store/State 数据结构的依赖，利于代码解耦；同时由于 selector 的实现完全是自定义函数，因此也有足够的灵活性（例如对原始状态数据进行过滤、汇总等）一个简化的render流程，判断this.stateProps，this.dispatchProps是否应该更新的主要逻辑是经过mapStateToProps select后的props有变更过或者是当componentWillReceiveProps判断自身props变更后（浅比较），如果mapDispatchToProps的入参有2个，也将判断this.stateProps应该更新。同理this.dispatchProps的更新也是依赖于自身props变更后,且mapDispatchToProps的入参有2个。 从初始路径开始，看看当store变化后connent如何处理,首先看到组件在初始的时候就使用store注册了store的变更回调，这个回调会在dispatch任何type的情况下得到执行，所以初始时需要判断之前的store状态和当前的store是否一致，123if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; 1.因为有些情况下dispatch出来的一个action不会引起reducer结果的任何变化，之后如果mapStateToProps的入参只有一个，会进行一次select操作，如果selector得到的结果没有任何变化（浅拷贝）,则直接返回，这个时候效率是最高的，没有组件的rerender(表现在connnect组件的setState),相当于组件不知道store改变了，react组件保持原状 2.如果mapStateToProps得到的结果有变化（浅拷贝），handleChange会做几个动作，一个是置2个标志位为true,12this.haveStatePropsBeenPrecalculated = truethis.hasStoreStateChanged = true this.haveStatePropsBeenPrecalculated用来表达updateStatePropsIfNeeded已经执行过，即mapStateToProps进行过select，this.hasStoreStateChanged用来表达store的state已经变化，需要重新计算this.stateProps这个状态位在shouldComponentUpdate，以及判断this.stateProps是否更新时用的上另一个重要的动作是： this.setState({ storeState }) 这个时候将会触发 123shouldComponentUpdate() &#123; return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged &#125; 由于this.hasStoreStateChanged已经被置位，所以会进行render的操作每次进入render都会进行一系列的判断值得注意的是，如果在之前检测到store变化后，mapStateToProps得到新的结果，updateStatePropsIfNeeded执行过， 则this.haveStatePropsBeenPrecalculated = true那么下面的代码就进入第一个分支，updateStatePropsIfNeeded不需要再重新计算了。12345if (haveStatePropsBeenPrecalculated) &#123; haveStatePropsChanged = true&#125; else if (shouldUpdateStateProps) &#123; haveStatePropsChanged = this.updateStatePropsIfNeeded()&#125; 对于mapStateToProps mapDispatchToProps第二个ownprops参数的认识：这个2个函数的第二个参数主要是为了处理自身props变动的情形，如果这2个函数带了第二个参数ownprops，那么每次props变动的时候，这2个函数都会得到执行，即为重新select,如果不带这2个参数，那么自身props有变动的时候，这2个函数不会得到执行，对于这2个函数，带不带第二个参数ownprops，props变更的行为都跟裸用react组件时的行为一致。 updateMergedPropsIfNeeded是最后的过滤器12345678910111213141516171819202122232425262728293031323334componentDidMount() &#123; this.trySubscribe() &#125; trySubscribe() &#123; if (shouldSubscribe &amp;&amp; !this.unsubscribe) &#123; this.unsubscribe = this.store.subscribe(this.handleChange.bind(this)) this.handleChange() &#125; &#125;handleChange() &#123; if (!this.unsubscribe) &#123; return &#125; const storeState = this.store.getState() const prevStoreState = this.state.storeState if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; if (pure &amp;&amp; !this.doStatePropsDependOnOwnProps) &#123; const haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this) if (!haveStatePropsChanged) &#123; return &#125; if (haveStatePropsChanged === errorObject) &#123; this.statePropsPrecalculationError = errorObject.value &#125; this.haveStatePropsBeenPrecalculated = true &#125; this.hasStoreStateChanged = true this.setState(&#123; storeState &#125;) &#125; react-redux(v4)原理解析(ppt)在用react-redux的时候难免会有些问题？ 组件怎么让我们无感知的得到store的？ connect干了什么？ connect过的组件如何知道store的变化？ connect过的组件如何处理父级传下来的props？ mapStateToProps是如何注入到props中的呢? mapDispatchToProps是如何注入到props中的呢? mergeProps是做什么的？ 整个react-redux流程是如何的？ 高阶组件的弊端？ 组件怎么让我们无感知的得到store的？利用最外层的Provideprovider主要做了传递store的事情，通过在parent组件内，使用getChildContext方法，这个方法可以把相应的属性隐式往下传，子组件及子组件的子组件都可以获得此属性 1234567891011121314export default class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.store &#125; &#125; constructor(props, context) &#123; super(props, context) this.store = props.store &#125; render() &#123; return Children.only(this.props.children) &#125;&#125; 要注意childContextTypes需要声明出用到的属性12345678/*Index.childContextTypes=&#123; name: React.PropTypes.string.isRequired&#125;*/Provider.childContextTypes = &#123; store: storeShape.isRequired&#125; 如同在connect中也要声明用到的context,如下12345678/*ScrollBar.contextTypes=&#123; name:React.PropTypes.string&#125;*/ Connect.contextTypes = &#123; store: storeShape &#125; 那么connect是什么？connect是一个返回高阶组件的高阶函数什么是高阶组件以及使用高阶组件的正确姿势? 123456789101112function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;wrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; &#125;;&#125; connect过的组件如何知道store的变化？123456789101112131415161718192021222324function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); &#125; componentDidMount() &#123; this.store.subscribe(this.handleChange.bind(this)); this.handleChange(); &#125; handleChange() &#123; let currentState = this.store.getState(); this.mergedProps = mapStateToProps(currentState); this.setState(&#123; storeState: currentState, &#125;); &#125; render() &#123; let finnalProps = this.mergerPropsFunc(this.mergedProps, this.mergedActions, this.props); return &lt;wrappedComponent &#123;...finnalProps&#125; /&gt;; &#125; &#125; &#125;;&#125; connect过的组件如何处理父级传下来的props?透传123456789101112function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;wrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; &#125;;&#125; mapStateToProps是如何注入到props中的呢?mapStateToProps也叫selector1234567891011121314151617181920function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.store = props.store || context.store; const storeState = this.store.getState(); //初始化state this.state = &#123; storeState &#125;; //selector this.mergedProps = mapStateToProps(this.store.getState()); &#125; render() &#123; return &lt;wrappedComponent &#123;...this.props&#125; &#123;...this.mergedProps&#125; /&gt;; &#125; &#125; &#125;;&#125; mapDispatchToProps是如何注入到props中的呢?12345678910111213141516171819202122function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.store = props.store || context.store; const storeState = this.store.getState(); //计算dispatch if (typeof mapDispatchToprops === 'function') &#123; this.dispatchProps = mapDispatchToprops(this.store.dispatch); &#125; else &#123; //bindActionCreators(actionCreators, dispatch) //对象 this.dispatchProps = bindActionCreators(mapDispatchToprops, this.store.dispatch); &#125; &#125; render() &#123; return &lt;wrappedComponent &#123;...this.props&#125; &#123;...this.mergedProps&#125; &#123;...this.dispatchProps&#125; /&gt;; &#125; &#125; &#125;;&#125; mergeProps是做什么的？`this.props`,`this.mergedProps`,`this.mergedActions`合成,等于`Object.assign` 123456789101112131415161718192021222324const defaultMergeProps = (stateProps, dispatchProps, ownerProps) =&gt; (&#123; ...stateProps, ...dispatchProps, ...ownerProps,&#125;);function connect(mapStateToProps, mapDispatchToprops, mergeProps, option) &#123; return function wrappComponent(wrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.store = props.store || context.store; const storeState = this.store.getState(); //初始化state this.state = &#123; storeState &#125;; this.mergerPropsFunc = mergeProps || defaultMergeProps; &#125; render() &#123; let finnalProps = this.mergerPropsFunc(this.mergedProps, this.dispatchProps, this.props); return &lt;wrappedComponent &#123;...finnalProps&#125; /&gt;; &#125; &#125; &#125;;&#125; 事实上mapStateToProps 和 mapDispatchToProps都有对应的默认实现12const defaultMapStateToProps = state =&gt; (&#123;&#125;) // eslint-disable-line no-unused-varsconst defaultMapDispatchToProps = dispatch =&gt; (&#123; dispatch &#125;) mapStateToProps默认返回一个空对象，不做任何state转换 mapDispatchToProps默认注入dispatch方法 mergeProps合成三部分props,即stateProps,dispatchProps,this.props 三份重要的props1.this.stateProps ——- mapStateToProps 2.this.dispatchProps — mapDispatchToProps 3.this.mergedProps ——– mergedProps connect的一切逻辑判断都围绕这三个props进行react-redux工作流程 connect维护了自己的state怎么处理三个props的默认shallowEqual1234567891011121314151617181920212223export default function shallowEqual(objA, objB) &#123; if (objA === objB) &#123; return true &#125; const keysA = Object.keys(objA) const keysB = Object.keys(objB) if (keysA.length !== keysB.length) &#123; return false &#125; // Test for A's keys different from B. const hasOwn = Object.prototype.hasOwnProperty for (let i = 0; i &lt; keysA.length; i++) &#123; if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123; return false &#125; &#125; return true&#125; 对于this.stateProps的处理12345678function updateStatePropsIfNeeded() &#123; const nextStateProps = this.computeStateProps(this.store, this.props) if (this.stateProps &amp;&amp; shallowEqual(nextStateProps, this.stateProps)) &#123; return false &#125; this.stateProps = nextStateProps return true &#125; 其执行一次相当于mapStateToProps执行一次 对于this.dispatchProps的处理12345678function updateDispatchPropsIfNeeded() &#123; const nextDispatchProps = this.computeDispatchProps(this.store, this.props) if (this.dispatchProps &amp;&amp; shallowEqual(nextDispatchProps, this.dispatchProps)) &#123; return false &#125; this.dispatchProps = nextDispatchProps return true &#125; 其执行一次相当于mapDispatchToProps执行一次 对于this.mergedProps的处理12345678function updateMergedPropsIfNeeded() &#123; const nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props) if (this.mergedProps &amp;&amp; checkMergedEquals &amp;&amp; shallowEqual(nextMergedProps, this.mergedProps)) &#123; return false &#125; this.mergedProps = nextMergedProps return true &#125; 其执行一次相当于mergeProps执行一次 怎样性能最高？ 不让组件setState12345678910111213141516171819202122232425262728function handleChange() &#123; if (!this.unsubscribe) &#123; return &#125; const storeState = this.store.getState() const prevStoreState = this.state.storeState //第一次判断 if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; if (pure &amp;&amp; !this.doStatePropsDependOnOwnProps) &#123; const haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this) //状态相等 if (!haveStatePropsChanged) &#123; return &#125; if (haveStatePropsChanged === errorObject) &#123; this.statePropsPrecalculationError = errorObject.value &#125; this.haveStatePropsBeenPrecalculated = true &#125; this.hasStoreStateChanged = true this.setState(&#123; storeState &#125;) &#125; 有些情况下dispatch出来的一个action不会引起reducer结果的任何变化,直接返回 之后如果mapStateToProps的入参只有一个，会进行一次select操作，如果selector得到的结果没有任何变化（浅拷贝）,则直接返回，这个时候效率是最高的，组件不清楚发生了什么，保持原状 怎么最大限度保证不setState?1. connect的state的状态粒度最细2. mapStateToProps函数签名不写第二个ownProps谈谈 [ownProps]mapStateToProps,mapDispatchToProps，函数签名中的第二个参数，其签名为123(state/dispatch,props)=&gt;&#123; return …………&#125; 从其功能来看，调用mapStateToProps,mapDispatchToProps得到的新props跟state与组件props有关，映射出来的props将会与state,组件props强耦合，因此只要有新props到达，都会进行一次selector,虽然带来了灵活性，但是增加selector的次数，性能稍有损失 对于mapStateToProps mapDispatchToProps,如果不带这个ownProps参数，那么自身props有变动的时候，这2个函数不会得到执行，对于组件来说，带不带第二个参数ownprops，props变更的行为都跟裸用react组件时的行为一致。 对于connect过的高阶组件的弊端？Refs属性不能传递，所以源码中会有123456 if (withRef) &#123; this.renderedElement = createElement(WrappedComponent, &#123; ...this.mergedProps, ref: 'wrappedInstance' &#125;)&#125; 这样的写法，在外部需要2次调用refs才能得到真正的示例","tags":[{"name":"redux","slug":"redux","permalink":"http://07lyt.com/tags/redux/"}]},{"title":"webpack内部流程","date":"2017-04-28T13:20:52.000Z","path":"2017/04/28/webpack流程/","text":"webpack的一切都建立在其插件机制之上webpack是什么？ webpack 类似C++,java中的编译器，有编译，链接的能力 那么为什么是编译器？ webpack也需要做词法分析，语法分析，也需要把代码合起来注意webapck的语法分析重点分析require即为依赖的分析，要区分babel是对整个业务代码的分析 webpack是基于node的能力的 下图是webpack的整个框架流程，可以看到有complation,compiler 更详细的这张阿里博客的图很能说明问题地址：http://taobaofed.org/blog/2016/08/24/react-key/已经说的非常详细了 下图是webpack的内部类结构图 每次编译的\bcomplation\b对象: webpack是基于tapable 关于tapable:https://segmentfault.com/a/1190000008060440 tapable是一个事件系统，有关于事件一系列同/异步，串并行事件处理机制，提供事件注册等能力，如图:下面是tapable的一些简单用法 12345678910111213141516171819202122232425262728293031323334353637383940414243var Tapable = require(\"tapable\");function MyClass() &#123; Tapable.call(this);&#125;MyClass.prototype = Object.create(Tapable.prototype);MyClass.prototype.method = function() &#123;&#125;;//pluginfunction plugin()&#123;&#125;plugin.prototype.apply = function()&#123; console.log('plugin plugin tapable')&#125;;let tap =new MyClass();//注册事件tap.plugin('first',function(args,cb)&#123; console.log('first',args) cb()&#125;);tap.plugin('first',function(args,cb)&#123; console.log('first 2',args) cb()&#125;);tap.plugin('first',function(args,cb)&#123; console.log('first 3',args) cb()&#125;);tap.apply(new plugin());//触发事件//tap.applyPlugins('first');tap.applyPluginsAsync('first',&#123;a:1&#125;, function () &#123; console.log('async')&#125;) 源码中，webpack在build模块时 (调用doBuild方法)，要先调用相应的loader对resource进行加工，生成一段js代码后交给acorn解析生成AST.所以不管是css文件，还是jpg文件，还是html模版， 最终经过loader处理会变成一个module：一段js代码。 webpack使用acorn解析每一个经loader处理过的source，并且成AST，然后遍历所有节点，当遇到require调用时，会分析是AMD的还是CMD的调用，或者是require.ensure . 我们不再分析AST的遍历过程了。 下图是webpack\b的时间线流程还是那2个关键的compiler,compilation 分析完语法树之后，\b进行addchunk等操作，之后就调用模板生成器生成代码（assets）每次执行都有对应的事件发出（emit等） 看看babel插件机制： 以babel为例，当webpack发现模块名称匹配test中的正则/js[x]?的时候。 它会将当前模块作为参数传入babel函数处理，babel([当前模块资源的引用])。 函数执行的结果将会缓存在webpack的compilation对象上，并分配唯一的id 。 以上的这一步，非常非常关键。唯一的id值决定了webpack在最后的编译结果中，是否会存在重复代码。 而缓存在compilation对象上，则决定了webpack可以在plugin阶段直接拿取模块资源进行二度加工。 相关参考资料：http://taobaofed.org/blog/2016/08/24/react-key/","tags":[{"name":"基础工具","slug":"基础工具","permalink":"http://07lyt.com/tags/基础工具/"}]},{"title":"动手实现一个简易HTML解析器","date":"2017-04-19T13:20:52.000Z","path":"2017/04/19/动手实现一个简易HTML解析器/","text":"在动手之前，先说说动机，之前看过浏览器工作原理的一系列文章，如： chrome dom树构建源码解析 浏览器的工作原理：新式网络浏览器幕后揭秘 以及一些规范 html解析构建规范 css 规范 在了解了原理与一些规范之后就想要自己试试造个轮子，加深对浏览器的理解。在大致梳理好流程之后，有以下目录： 目录 概述 HTML解析篇 CSS解析篇 应用CSS样式到DOM中 事件系统 可以先看看效果 一.概述在浏览器中，我们的类有以下的继承关系，如一个div dom 继承自HTMLElemnt,HTMLElemnt继承自Element等。为了方便起见，将一些重要的如dispatchEvent等方法，children，parent，attributes等属性都纳入HTMLElement中。并且依照css object model，构造cssom对象。 因而实现下面的类，并实现manager来管理，即可实现一个简易的解析器。 二.HTML解析篇解析html标签，最先想到的是正则，但是用正则可以解析，但是有几个问题： 如何建立dom树的父子关系 如何建立dom树的兄弟关系 如何实现getElementById方法 纯文本节点怎么解析 innerHTML该怎么做 innerText该怎么做 addEventListener该怎么做 怎么构造attributeNode 其中1,2是构建dom树的关键，对于7将在事件篇中实现。 1. 如何建立dom树的父子关系chrome dom树构建源码解析参考这篇文章，我们需要做的是一个临时栈，以一个例子来说明如图所示，有一段HTML文本，我们的解析是从文本的第一个字符到最后一个字符，从上到下，从左到右进行解析，按照chrome的做法，chrome是先解析文本，得到一系列token，再进行树的构建(参考文章)。而利用正则的步进过程，我们可以把2个阶段合成一个进行实现，绿色的部分是我们的临时栈，我们的解析策略是:正则匹配到一个开始标签时，就new一个Node，然后推入绿色临时栈中，对于或纯文本的node，也进行new操作，但是不入栈，因为这个node已经算是闭合了图中，有一段HTML文本，先解析到，之后new一个HTMLElement入栈，又解析到，也new一个Element入栈，在遇到闭合之后，便可以pop出，同时把栈顶的元素作为被pop出元素的父元素，进行parent属性与children属性的操作，如图右侧代码所示。 在遇到id为f1的div之后，遇到一个文本dp，临时栈如图绿色部分所示这个时候new完一个文本节点即可进行父子赋值操作了，如图右侧所示。 同理，类似操作如下：因此dom树便可以在解析完文本之后构建出来 整个流程简化如下代码，每次解析到一个正则匹配的tag，便进行操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849generatorHtmlNode(html)&#123; html = html.replace(/[\\r\\n]+/g, \"\"); html = html.trim(); //&lt;&gt; &lt;/&gt;等的正则匹配 let tagRegex = /&lt;(\\/)?([^\\/&lt;&gt;]+)(\\/)?&gt;/g; //保存root let root; //记录tag解析位置，用以得到纯文本 let cursor = 0; //用以记录前一个解析到的node let preslibingNode; //解析dom树过程中的临时栈 let htmlstack = []; //保存正则匹配临时结果 let regexResult while ((regexResult = tagRegex.exec(html))) &#123; let holeMatch = regexResult[0]; let isEnd = !!regexResult[1]; let matchGroup = regexResult[2]; let isEndOfOneTag = !!regexResult[3]; //是单闭合标签 let tagName = findTheHtmlTag(regexResult[2]); //解析纯文本 let planText = html.slice(cursor, regexResult.index); let parentNode = getTop(htmlstack); if (!flag) &#123; let node = new HTMLElement( tagName, parentNode, holeMatch, findAttributeKeyPair(matchGroup) ); //临时栈 htmlstack.push(node); &#125; else&#123; //遇到结束标识 popStack(htmlstack); &#125; /* 省略 ………………………………………… ………………………………………… ………………………………………… */ //更新文本游标 cursor = regexResult.index + holeMatch.length; &#125; return root;&#125; 2. 如何建立dom树的兄弟关系同dom树的构建过程，我们可以开辟一些临时空间来保存之前创建的Element.我们用一个变量preslibingNode来存储之前创建的Element.我们重要的是preslibingNode的更新时机，我们应该选择在遇到所有开闭标签以及文本的时候进行更新变量，并要注意赋值判断。以下图的例子来说明。左侧有一串html文本，我们的preslibingNode变量在解析过程中的变化过程如右侧所示。preslibingNode初始为undefined，在遇到第一个并new 它时，preslibingNode为undefined，因而对的previousSibling属性不作操作，并将preslibingNode更新为，之后解析遇到,preslibingNode为其parent,因而不对的previousSibling属性进行操作，同理更新preslibingNode变量，要注意在遇到如闭合标签的情况下，也要更新preslibingNode变量，但不必更新span节点的preslibingNode信息，如右图。之后遇到dp2的文本的时候，由于preslibingNode有值且不是其父亲节点，因而可以应用previousSibling属性，如代码所示：12345678if ( preslibingNode &amp;&amp; preslibingNode != parentNode ) &#123; //构建双向链表 node.previousSibling = preslibingNode; preslibingNode.nextSibling = node; &#125; 之后的过程如图所示，直到所有的文本解析完毕。 3. 如何实现getElementById方法实现getElementById方法，可以在解析的时候，每次解析到一个含有id的dom，就保存到一个全局hashMap中（key为id,value为dom），这样要要想获取，可以直接从hashmap中获取，减少遍历耗时，以空间换时间 4. 纯文本节点怎么解析利用正则的index特性，再借用一个当前游标，便可以将当前的匹配的html标签与上一个html标签之间的内容保存下来，即为文本的内容12345678910111213141516171819generatorHtmlNode(html)&#123; //&lt;&gt; &lt;/&gt;等的正则匹配 let tagRegex = /&lt;(\\/)?([^\\/&lt;&gt;]+)(\\/)?&gt;/g; let regexResult while ((regexResult = tagRegex.exec(html))) &#123; let holeMatch = regexResult[0]; //解析纯文本 let planText = html.slice(cursor, regexResult.index); /* 省略 ………………………………………… ………………………………………… ………………………………………… */ //更新文本游标 cursor = regexResult.index + holeMatch.length; &#125; return root;&#125; 5. innerHTML该如何操作可以在解析到某个标签时，将这个标签字符串左边的内容都暂时砍去，然后往右找第一个对应的闭合标签，找到了，截取出来即为innerHTML，具体做法是把正则匹配到的结果result传入一个函数，如下所示：123456789101112131415function getInnerHtml(regexResult, node) &#123; //整个HTMLstring,每次都相同 let holeHtml = regexResult.input; let tag = node.name; //切割到当前tag的children位置 获得innerHTML的右边部分 let rightHtml = holeHtml.slice( regexResult.index + regexResult[0].length, holeHtml.length ); //构造第一个匹配到的相应tag的闭合标签 let re = new RegExp(\"&lt;\\\\/(\" + tag + \")&gt;\", \"i\"); // re为/&lt;\\/(div)&gt;/i 没有/g标志，可以用match，效果和exec一样 let regMatched = rightHtml.match(re); //进行切割返回 return rightHtml.substring(0, regMatched.index);&#125; 6. innerText该如何操作innerText也应该很容易，利用innerHTML得到的文本，再利用replace(regex)方法，将标签替换为空即可,这个时候对正则不要分组，会影响性能利用得到的innerHTML，进行正则替换即可，1innerHTML.replace(/&lt;\\/?[^\\/&lt;&gt;]+\\/?&gt;/ig, \"\"); 7. addEventListener该怎么做应该维护一个全局的hashMap，在调用addEventListener时，用以保存对应事件的listen,hashMap的key应为dom,value也应该为一个hashMap(x)查看Event部分 8. 怎么构造attributeNode对于每一个开始标签，利用正则匹配出标签里面的id=’xxx’ class=’xxx1 xx2’等，既可以构造相应的attributeNode每个HTMLElement有一个attributeCollection，按正则匹配进行构造：1234567891011121314151617function findAttributeKeyPair(str) &#123; let attributeRegex = /(([\\w]+)=(('|\")[\\s\\w-]+('|\")))/g; let result; let pairs = []; let attributeCollection = []; while ((result = attributeRegex.exec(str))) &#123; pairs.push(result[1]); &#125; for (let i = 0; i &lt; pairs.length; i++) &#123; let pair = pairs[i]; let keyValue = pair.split(\"=\"); let key = keyValue[0]; let value = keyValue[1].replace(/['\"]+/g, \"\"); attributeCollection.push(new attributeNode(key, value)); &#125; return attributeCollection;&#125; 三.CSS解析篇DOM-CSS / CSSOM浏览器css object model对象，通过document.styleSheets可以得到当前文档的所有样式集，每一个标签可以对应解析出一个CSSStyleSheet对象，本文支持解析出CSSStyleSheet对象CSSStyleSheet对象有一个cssRules属性，其为一CSSRuleList集合，保存有style内含的所有规则，每一个规则为CSSStyleRule。如下：因而我们可以按照上图构造对象，构造selector，property等属性。按照文章开头的介绍，我们构造了下面的css object model。这个规则对应到我们具体些的css样式，即为每一个大括号，每一个CSSStyleRule有cssText属性保存整个css文本，selectorText用来保存css选择器文本，此外我们还引入innerStyleRule到这个规则中，innerStyleRule用以递归css的每一个选择器，以匹配dom是否满足样式规则，并引入_weight对象来保存CSSStyleRule的权重。综上所述，所以我们的目的是解析一段样式文本，得到一个数组，这个数组中保存有多个CSSStyleRule，每一个CSSStyleRule对应一个样式规则所以有几个问题？1.如何解析得到每一个css block块？2.如何得到选择文本？3.如何得到每个具体样式对于上述三个问题，都可以用正则来解析得到12345678910111213141516171819202122232425262728cssRuleGenerator(cssSnippet) &#123; //选择器 及 cssbody 匹配 let cssRegex = /([^\\&#123;\\&#125;]+?)&#123;([^\\&#123;\\&#125;]+)&#125;/ig; let result; let stylesheet = []; while ((result = cssRegex.exec(cssSnippet))) &#123; console.log(\"regex: \", result); let holeMatch = result[0]; //分组拿到选择器 let selector = result[1]; //分组拿到cssBody let cssRuleBody = result[2]; let selectorList = selector; selectorList = selectorList.trim(); let groups = selectorList.split(\",\"); for (let i = 0; i &lt; groups.length; i++) &#123; let seletorTex = groups[i].trim(); stylesheet.push( new CSSStyleRule( holeMatch.trim(), seletorTex.trim(), cssRuleBody.trim() ) ); &#125; &#125; return stylesheet; &#125; 成熟的方案是postcss,postcss有方法能解析cssstr 四.应用CSS样式到DOM中先不考虑css属性和伪类伪元素的情形，只考虑类，id,后代，兄弟等常用选择器，那么问题是：如何把样式应用到对应的node节点中？对于这个问题，可以拆分成以下的小问题1.如何匹配css规则到dom 特别是像有后代选择器，兄弟选择器的情形，如何正确匹配？2.如何保证迭代效率 试想遇到嵌套层级很深的css样式，如果不匹配，又要重新选择路径，大大浪费了性能3.如何处理css优先级问题4.css的应用顺序是从左往右还是从右往左在回答这些问题之前，先介绍cssom的几个类实现，如下： 1.CSSStyleRule对于CSSStyleRule，有一个属性是selectorArray，css中，selector的概念，按MDN，有： basic selector:Type selectors elementnameClass selectors .classnameID selectors #idnameUniversal selectors ns| |Attribute selectors [attr=value] combine selector:basic selector[basic selector] combinator:Adjacent sibling selectors A + BGeneral sibling selectors A ~ BChild selectors A &gt; BDescendant selectors A B 这些都是selector，而CSS的选择器是由selectorlist组成的123selectorlist &#123; property: value; [more property:value; pairs] &#125;...where selectorlist is: selector[:pseudo-class] [::pseudo-element] [, more selectorlists] 所以我们可以把selectorlist切开为一个数组，如对于1div.class1 + span &gt;div 选择器，可以解析出5个selectors1[&apos;div.class1&apos;,&apos;+&apos;,&apos;span&apos;,&apos;&gt;&apos;,&apos;div&apos;] 第一个为combine selector，第二个为combinator，第三个为basic selector，后续类似。 1.1 innerStyleRule根据上一步中的selectorArray，我们可以构造出innerStyleRule。一个innerStyleRule的内部属性如下：每个innerStyleRule包括一个matchTypes和values数组，matchType数组中目前只会有tag,id,class三种enum类型，values数组保存tag,id,calss对应的tagName，idName，className。innerStyleRule最重要的一个属性为relation，即combinator，combinator即为关系，包括父子，兄弟等。innerStyleRule对象示意：12345&#123; matchTypes:Array(enum):MATCHTYPE, values:Array Of String(tagName,className,idName) relation:enum:RELATIONTYPE,&#125; 1234567891011121314//enum of mathTypesexport const MATCHTYPE=&#123; TAG:&apos;Tag&apos;, ID:&apos;id&apos;, CLASS:&apos;CLASS&apos;&#125;//enum of relationTypeexport const RELATIONTYPE=&#123; SUBSELECTOR:&apos;SubSelector&apos;,//NO COMBINATOR DESCENDANT:&apos;Descendant&apos;, // &quot;Space&quot; combinator CHILD: &apos;Child&apos;, // &gt; combinator DIRECTADJACENT:&apos;DirectAdjacent&apos;, // + combinator INDIRECTADJACENT:&apos;IndirectAdjacent&apos; // ~ combinator&#125; 以 [&#39;div.class1&#39;,&#39;+&#39;,&#39;span&#39;,&#39;&gt;&#39;,&#39;div&#39;]这个selectorArray为例，可以得到一个有3个innerStyleRule元素的数组1234567891011121314151617[ &#123; matchType:[&apos;TAG&apos;], relation:&quot;CHILD&quot;,//&gt; values:[&quot;div&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;], relation:&quot;DIRECTADJACENT&quot;,//+ values:[&quot;span&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;SUBSELECTOR&quot;,//NO COMBINATOR values:[&quot;div&quot;,&quot;class1&quot;] &#125;,] 这个数组会在dom匹配css的过程中起到作用，在计算权重的时候也能起到作用。 2.选择器权重实现css选择器优先级是按照下图的关系构造的，每位可以是一个16进制数（那最多只有16个，不过超过16个元素的css选择器也不建议实现）如一个例子，权重值为0x0113:详细参考这篇文章(https://css-tricks.com/specifics-on-css-specificity/)在1.1中得到的innerStyleRule得到了tag,class,id信息，根据其数据结构可以方便的计算样式的weight。 3.按样式类别归类得到的innerStyleRule数组的第0个元素为选择器最右边的元素，根据这个元素可以做一些归类操作，目的是利用hashMap，加速css的匹配过程，这部分的缓存操作能大大提升性能。如图所示，左上方是有html及对应的css，css按从上到下从1到6编号，右侧是按weight进行排过序的css样式，在样式解析过程中，我们会根据selectorlist最右侧的选择器将 CSS 规则添加到某个哈希表中，如图下侧。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，如图所示。实现为：12345678910111213141516 //在创建CSSStyleRule时 //对内部序列选择器中最右的进行判断，存入全局样式缓存中，主要用于应用样式时的加速 //CSSRULEHASHMAP为缓存HashMap let rightRule = this.innerStyles[0]; if (rightRule.matchType.indexOf(MATCHTYPE.ID) &gt;= 0) &#123; CSSRULEHASHMAP.ID.push(this); &#125; if (rightRule.matchType.indexOf(MATCHTYPE.CLASS) &gt;= 0) &#123; CSSRULEHASHMAP.CLASS.push(this); &#125; if (rightRule.matchType.indexOf(MATCHTYPE.TAG) &gt;= 0) &#123; CSSRULEHASHMAP.TAG.push(this); &#125; else &#123; CSSRULEHASHMAP.UNKNOW.push(this); &#125;//这部操作为了解析时候的快速命中，试想在创建一个node，如果一个没有id,class属性的html标签node被创建，那么对它应用的样式应该忽略含有id,class的样式 之后这个缓存Map会在匹配过程中用到。 4.2 应用CSS样式到DOM中以解析下图html与css为例： 我们在构建每一个HTMLElement的时候,去看看这个Node符不符合这6个样式，如果符合，即应用这些样式到HTMLElement上。这个时候可以回答之前提到的问题，如何处理CSS优先级。我们可以把所有相关的样式按权重从小到大排序，按图右侧。在应用样式时，我们先从小到大将低权重样式应用到HTMLElement上，然后用数组后面的高权重的样式去覆盖之前的样式（如果有相同的就覆盖，如果没有相同的就新获得了一个样式）这样依次将整个符合的样式组应用到HTMLElement中。如下图，当解析到节点时，1，2号样式符合，之后从后往前应用样式，依次覆盖，margin被覆盖掉。观察这个节点，发现其没有id属性，所以在遍历6个样式的时候，4号样式是可以不用关心的，因为4号样式为#id选择样式，必定跟当前的节点不会匹配，所以之前的HashMap就派上用场，我们从hashMap中取出classMap和tagMap就好，这样，遍历的时候只需要遍历5个样式。这样能节约很大一部分的匹配过程，按官方介绍，能提升95%的性能。这就回答了一开始的如何提升性能的问题。之后解析到，需要取出5个样式(没有id)，之后符合一个样式，应用其在dom上。 如下图，解析到，需要取出4个样式(没有class)，之后符合两个样式，依次应用其在dom上。 同理，遇到只需要取出3个tagHashMap，之后6匹配成功。 然后回到第一个小问题，css样式如何匹配dom？先考虑下面的例子先看图中的最右测的innerStyleRule数据结构，对于6号样式，为123.div1 div.div2 .div3 ~ span&#123; font-size:20px;&#125; 其对应的innerStyleRules表达为：12345678910111213141516171819202122[ &#123; matchType:[&apos;TAG&apos;], relation:&quot;INDIRECTADJACENT&quot;,//~ values:[&quot;span&quot;] &#125;, &#123; matchType:[&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div3&quot;] &#125;, &#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div&quot;,&quot;div2&quot;] &#125;, &#123; matchType:[&apos;CLASS&apos;], relation:&quot;SUBSELECTOR&quot;,//nothing values:[&quot;div1&quot;] &#125;] 接下来看看如图HTML部分解析到的是如何匹配成功的。首先在解析HTML文本之前，我们先把CSS的文本解析为了CSSOM，之后开始解析HTML文本，现在解析器解析到了，首先看innerStyleRules数组第一个元素（即为最右侧selector），type为[‘TAG’]，值为[‘span’]，当前HTMLElement为，符合要求，接下来看relation，为INDIRECTADJACENT（~之后选择器）表示选择之后的兄弟节点，那么我们可以反过来看，如果找到一个满足条件的前面的兄弟节点，那么这一级的~是成功的，由于前面的dom已经构建好，因此找到第一个满足条件的前面的兄弟节点，即~这个选择器关系成立，我们可以观察的previousSibling，以及的previousSibling的previousSibling，逐次判断，如果某个previousSibling（HTMLElement）满足innerStyleRules[1]的条件，即为：12345&#123; matchType:[&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div3&quot;] &#125; 有class,且className为div3，则INDIRECTADJACENT（~）匹配成功，这里匹配到。之后以为匹配HTMLElement，其 relation为DESCENDANT，那么我们找到第一个祖先满足条件（div且有class为div2）：12345&#123; matchType:[&apos;TAG&apos;,&apos;CLASS&apos;], relation:&quot;DESCENDANT&quot;,//space values:[&quot;div&quot;,&quot;div2&quot;] &#125; 找到了是其祖先且满足条件，之后其relation也是DESCENDANT祖先选择器，同理找到了。找祖先的过程可以不断的拿parent属性进行匹配，如.parent，.parent.parent，.parent.parent.parent，这样一直下去，直到根节点为止。 在解析HTML过程中，我们每次new 一个HTMLElement，便执行一次embedCsstoHtmlNode，使得样式嵌入到HTMLElement中。12345678910111213141516171819202122232425262728293031function embedCsstoHtmlNode(node) &#123; //从样式hashMap中获得能用上的样式 let wantedStyles = _constructTheWantedStyleSheets(node); //按照权重对sheet进行排序 quickSort(wantedStyles); //根据node有没有id,有没有class 去拿HASHMAP的值 TAG，UNKNOW一定要拿，ID,CLASS如果NODE没有，可以不拿 for (let i = 0; i &lt; wantedStyles.length; i++) &#123; wantedStyles[i]._resetCursor(); if (matchTheCssStyle(wantedStyles[i], node)) &#123; if (!node.style) node.style = &#123;&#125;; _overrideNodeStyle(node, wantedStyles[i].style); &#125; &#125;&#125;//如果node有id,class才会并入需要的样式//CSSRULEHASHMAP是styleRule的hashMap，分ID,CLASS,TAG,UNKNOW 4个维度function _constructTheWantedStyleSheets(node) &#123; let styleSheets = []; if (node.getAttribute(&quot;id&quot;)) &#123; styleSheets = styleSheets.concat(CSSRULEHASHMAP.ID); &#125; if (node.getAttribute(&quot;class&quot;)) &#123; styleSheets = styleSheets.concat(CSSRULEHASHMAP.CLASS); &#125; //TAG是一定要得，需要过滤的是没有class 和 id的情况 styleSheets = styleSheets.concat(CSSRULEHASHMAP.TAG); styleSheets = styleSheets.concat(CSSRULEHASHMAP.UNKNOW); return styleSheets;&#125; 先从样式hashMap中选择出一部分能匹配中的，之后对这些样式按权重进行排序，然后从第0个开始迭代，这里排序使用了快速排序，之后按照权重从低到高依次调用matchTheCssStyle方法，对node与style匹配成功的即可以进行样式写入，注意在每次样式匹配前调用了 wantedStyles[i]._resetCursor()重置游标方法，这个目的是为了清理在判断style是否与node匹配的过程中产生的内部状态。matchTheCssStyle方法用以判断HTMLElement是否与一个CSSStyleRule匹配，matchTheCssStyle需要判断CSSStyleRule.innerstyleRules中所有的innerstyleRule都匹配。因而在matchTheCssStyle方法中我们需要一个判断单个innerstyleRule是否匹配某个HTMLElement的方法:_isMatchNodeIndex(cssRule, node, index)按游标进行匹配，如果innerStyleRules中某个游标下的innerStyle与HTMLElement及其属性匹配（主要idName,tagName,className对应到HTMLElement中的idName,tagName,className是否对应匹配，这个方法只是比较tagName，idName等，与关系无关）则返回true。matchTheCssStyle的匹配过程为获得当前innerStyleRules游标对应关系，游标初始为0，由于innerStyleRules按从右到左保存，0对应选择器列表中最右的selector，对应上例中选择的是：12345&#123; matchType:[&apos;TAG&apos;], relation:&quot;INDIRECTADJACENT&quot;,//~ values:[&quot;span&quot;]&#125; 如果HTMLElement为span标签，则匹配成功，更新游标信息，之后又去找其第一个匹配兄弟（如果是DESCENDANT，则为找第一个祖先），看是否匹配，如果匹配，则以这个匹配的HTMLElement递归下去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function matchTheCssStyle(cssStyleRule, node) &#123; //获得当前innerStyles游标对应关系，游标初始为0 //由于innerStyles按从右到左保存，0对应选择器列表中最右的selector let RuleCombinator = cssStyleRule.innerStyles[cssStyleRule.cursor].relation; switch (RuleCombinator) &#123; case RELATIONTYPE.DESCENDANT: //后代 /* 如innerStyle为 &#123; matchType:[&apos;TAG&apos;], relation:&quot;CHILD&quot;,//&gt; values:[&quot;div&quot;] &#125;, 则当前node为div就算匹配成功 从右往左开始，如果当前游标对应innerStyles 与 node信息不匹配，返回false */ if (!_isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor)) return; //进到上一级游标 cssStyleRule.cursor++; //对父元素进行匹配 let parent = node.parent; if (!parent) return; //游标已更新 while (!_isMatchNodeIndex(cssStyleRule, parent, cssStyleRule.cursor)) &#123; //由于是后代选择器，找到第一个满足条件的父亲或祖先 parent = parent.parent; //如果找到root根了还没找到，返回false if (!parent) return; &#125; //到这里则最近的祖先找到了 if (cssStyleRule._isCursorEnd()) &#123; return true; &#125; //祖先匹配到了,并且游标没结束 递归这个找到的祖先元素 return matchTheCssStyle(cssStyleRule, parent); case RELATIONTYPE.SUBSELECTOR: //最左 //已经是最左，只要返回是否匹配 return _isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor); case RELATIONTYPE.CHILD: //儿子 //&gt; if (!_isMatchNodeIndex(cssStyleRule, node, cssStyleRule.cursor)) return; cssStyleRule.cursor++; let parentC = node.parent; if (!parentC) return; if (!_isMatchNodeIndex(cssStyleRule, parentC, cssStyleRule.cursor)) return; if (cssStyleRule._isCursorEnd()) &#123; return true; &#125; return matchTheCssStyle(cssStyleRule, parentC); case RELATIONTYPE.DIRECTADJACENT: //同胞 //+ …………………… case RELATIONTYPE.INDIRECTADJACENT: //兄弟 //~ find all pre …………………… &#125;&#125; 到这里就可以回答之前的问题，为什么要从右往左开始？因为从右往左开始不需要依赖没解析到的node,当stylesheets已经生成好了之后，再进行dom树的解析过程中，每遇到一个node,不论是后代关系，还是兄弟关系，在创建这个node的时候，这个关系就已经确立了的，根本原因是dom树的解析过程是从上到下，从左到右的，或是以解析&lt;&gt;开标签为首要任务的，解析的这个node如果是某个node的后代，那么只要看这个node的parent，往上看，如果是某个node的兄弟，也只需要看previousSibling，这些node在构造这个node的时候已经生成试想如果是从左往右的话，比如#id1 div，那么如果在构造#id1这个node的时候，就要等其后代们都构造完了，才能把样式用于这些后代，所以要等后代构造完，即是先要构造dom树，再把style，应用上去，这样做会造成屏幕白屏，而且有不必要的树遍历过程构造dom树，算是一次遍历，应用样式到dom树又有一次遍历，性能会有影响而从右到左只有一次遍历过程，即为边构建dom树边应用样式，同步进行。 五.事件系统在事件系统中，主要有几个问题？1.dom的addEventListener API怎么实现？2.e.stopPropagation/e.stopImmediatePropagation怎么实现？3.dom的dispatchEvent API怎么实现？ 按mdn描述：事件响应会有一个Event对象，用于保存事件属性，包括事件冒泡及捕获过程中的状态 先来看看事件对象的mdn定义，我们实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export const EVENTPHASE = &#123; BUBBLE: 1, CAPTURE: 2, TARGET: 3&#125;;export default class Event &#123; // event = new Event(typeArg, eventInit); /* typeArg Is a DOMString representing the name of the event. eventInit Optional Is an EventInit dictionary, having the following fields: &quot;bubbles&quot;: (Optional) A Boolean indicating whether the event bubbles. The default is false. &quot;cancelable&quot;: (Optional) A Boolean indicating whether the event can be canceled. The default is false. &quot;scoped&quot;: (Optional) A Boolean indicating whether the given event bubbles. If this value is true, deepPath will only contain a target node. &quot;composed&quot;: (Optional) A Boolean indicating whether the event will trigger listeners outside of a shadow root. The default is false. */ /* var event = new MouseEvent(&apos;click&apos;, &#123; &apos;view&apos;: window, &apos;bubbles&apos;: true, &apos;cancelable&apos;: true &#125;); */ constructor(typeArg, eventInit) &#123; //this.eventPhase enum this._isStopPropagation = false; this._isStopImmediatePropagation = false; this.type = typeArg; //todo default config this.option = eventInit || &#123; bubbles: true, cancelable: true &#125;; this.bubbles = this.option.bubbles; this.timeStamp = +new Date(); //该属性总是指向被绑定事件句柄（event handler）的元素 this.currentTarget; this.target; this.eventPhase; &#125; preventDefault() &#123; //not stop bubbling &#125; stopPropagation() &#123; if (this.option.cancelable) &#123; this._isStopPropagation = true; &#125; &#125; stopImmediatePropagation() &#123; //停止冒泡 且停止队列 if (this.option.cancelable) &#123; this._isStopImmediatePropagation = true; &#125; &#125; //event.initEvent(type, bubbles, cancelable); /* type Is a DOMString defining the type of event. bubbles Is a Boolean deciding whether the event should bubble up through the event chain or not. Once set, the read-only property Event.bubbles will give its value. cancelable Is a Boolean defining whether the event can be canceled. Once set, the read-only property Event.cancelable will give its value. */ initEvent(type, bubbles, cancelable) &#123; //old style this.type = type; &#125;&#125; 对于旧标准var event = Document.createEvent(),event.initEvent()的事件创建方式，我们先不实现，我们使用新的事件创建形式，即为通过构造函数形式创建事件关于事件流程： 创建事件与触发事件参考关于事件系统中target 与 currentTarget 的区别 首先我们来实现addEventListener， 基于chrome的实现思路，我们将事件监听函数存入一个全局hashMap中，并把每个node作为key,value为这个节点对应的事件集合。如图所示：这个实现与V8的实现有一些区别，V8是每个Key对应一个vector,这边是每个key对应一个hashMap 不过都能实现，不影响理解。我们实现如下:1234567891011addEventListener(eventName, fn, useCaputrue) &#123; let domKey = MD5(this); //在V8是用指针即内存地址来作为KEY，这样能保证KEY的唯一 if (!EVENTMAP[domKey]) EVENTMAP[domKey] = &#123;&#125;; let listenersQueue = EVENTMAP[domKey] &amp;&amp; EVENTMAP[domKey][eventName]; if (!listenersQueue) EVENTMAP[domKey][eventName] = []; EVENTMAP[domKey][eventName].push(&#123; fn: fn, useCaputrue: useCaputrue &#125;);&#125; 这就回答了第一个问题。 现在来实现dispatchEvent，按照定义dispatchEvent，应该有以下的方法接口1var cancelled = !elem.dispatchEvent(event); 值得一提的是，我们只实现W3C事件，原生事件是通过层层封装的，如下图考虑dispatchEvent事件之后，事件要进行捕获和冒泡，因而要得到冒泡捕获路径，路径可以不断遍历parent属性来得到。如上图，我们先进行事件捕获，到达target之后，再进行事件冒泡，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//分发事件 dispatchEvent(event) &#123; event.target = this; let nodeChain = _getNodeChain(this); //先捕获 let captureNotCancel = _eventCaptrueTraverse( event, nodeChain); // event 这两个event不是要分开成2个单独的，因为如果第一个stopProgation之后，第二个也用的这个event //后冒泡 let bubbleNotCancel = _eventBubbleTraverse(event, nodeChain); // return NotCancel return captureNotCancel &amp;&amp; bubbleNotCancel; &#125;//获得路径function _getNodeChain(node) &#123; let nodeChain = []; nodeChain.push(node); let parent = node.parent; while (parent) &#123; nodeChain.push(parent); parent = parent.parent; &#125; return nodeChain;&#125;//冒泡流程function _eventBubbleTraverse( event, nodeChain) &#123; if(!event.bubbles)return true; for (let i = 0; nodeChain &amp;&amp; i &lt; nodeChain.length; i++) &#123; //如果stopPropagation之后，flag为true，停止传播 if (event._isStopPropagation) return false; if (i == 0) &#123; event.eventPhase = EVENTPHASE.TARGET; &#125; else &#123; event.eventPhase = EVENTPHASE.BUBBLE; &#125; let nodec = nodeChain[i]; let nodeKey = MD5(nodec); let queues = EVENTMAP[nodeKey] &amp;&amp; EVENTMAP[nodeKey][event.type]; for (let j = 0; queues &amp;&amp; j &lt; queues.length; j++) &#123; let fn = queues[j].fn; let useCaputrue = queues[j].useCaputrue; event.currentTarget = nodec; //如果stopImmediatePropagation之后，立即停止传播 if (event._isStopImmediatePropagation) return false; if (!useCaputrue) &#123; fn.call(nodec, event); &#125; &#125; &#125; return true;&#125; 我们通过parent属性得到链路数组，之后，从前到后，并从后到前循环这个数组，完成捕获与冒泡过程，如果中途有stopPropagation/stopImmediatePropagation则置位flag，停止事件流程，这样就回答了后面2个问题。 六.总结到此基本实现了一遍html的简单解析器，但是还有好多没做，比如removeNode API， 并如何处理removeNode之后的内存空间，其事件响应函数还没有被remove，DOM Level 0事件，属于属性事件，需要特殊处理，需要getter，setter等，相关的代码地址后续会贴出来。参考资料：从Chrome源码看浏览器如何构建DOM树从Chrome源码看浏览器如何计算CSS从Chrome源码看浏览器的事件机制浏览器的工作原理：新式网络浏览器幕后揭秘 dom深度尽量浅。不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。不要给类选择器指定标签，类，代表具有一类属性的标签，不仅是一个，虽然可以实现，但是降低了效率。避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp&gt;p{}避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）；","tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://07lyt.com/tags/前端基础/"}]},{"title":"一个模板引擎的简单实现","date":"2017-03-11T13:20:52.000Z","path":"2017/03/11/一个模板引擎的简单实现/","text":"模板引擎在后端直出，前端渲染都应用广泛，知道其原理对于理解渲染会很有帮助，比如ejs,dot,react的jsx解析到creatElement等，下面是一个简易的实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788export function template(templateStr, varialObj) &#123; //变量占位符 let placeHolder = /&lt;%([^%&gt;]+)?%&gt;/g; //non sense let scriptHolder = /&#123;=([\\s\\S]+?)=&#125;/g; //js 正则 let javaScriptReg = /^(\\s)?(if|for|else|switch|case|break|\\&#123;|\\&#125;)(.*)/g; let code = 'let r = [];'; let result = void 0; let cursor = 0; while ((result = placeHolder.exec(templateStr))) &#123; console.log('result: ', result); let matched = result[0]; let varialbelKey = result[1]; //htmlTag 打上引号 if (templateStr.slice(cursor, result.index).trim()) &#123; code += 'r.push(\"' + templateStr.slice(cursor, result.index).replace(/['\"]/g, '\\\\\"').replace(/[\\s]/mg, '') + '\");\\n'; &#125; //更新游标 cursor = result.index + matched.length; console.log('varialbelKey', varialbelKey); if (varialbelKey.match(javaScriptReg)) &#123; //是js let keys = Object.keys(varialObj); for (let j = 0; j &lt; keys.length; j++) &#123; if (varialbelKey.indexOf(keys[j]) &gt;= 0) &#123; //注意 这里ob是入参 varialbelKey = varialbelKey.replace(keys[j], 'ob.' + keys[j]); &#125; &#125; code += varialbelKey + '\\n'; &#125; else &#123; //是变量 code += 'r.push(ob.' + varialbelKey.replace(/\\s/g, '') + '||' + varialbelKey.replace(/\\s/g, '') + ');\\n'; &#125; &#125; code += 'r.push(\"' + templateStr.slice(cursor, templateStr.length).replace(/['\"]/g, '\\\\\"').replace(/[\\s]/mg, '') + '\");\\n'; code += 'return r.join(\"\")'; console.log('code is : ', code); // 利用Function /* example: code: let r = [];r.push(\"&lt;html&gt;\"); for(var i =0;i&lt;ob.arrylist.length;i++) &#123; r.push(\"&lt;li&gt;\"); r.push(ob.arrylist[i]||arrylist[i]); r.push(\"&lt;/li&gt;\"); if(ob.non)&#123; r.push(\"&lt;p&gt;prar&lt;/p&gt;\"); r.push(ob.ss||ss); &#125; &#125; r.push(\"&lt;div&gt;\"); r.push(ob.ss||ss); r.push(\"&lt;/div&gt;&lt;/html&gt;\"); return r.join(\"\") */ return new Function('ob', code.replace(/\\n\\r\\t/g, '')).apply(varialObj, [varialObj]);&#125;let templateStr = `&lt;html&gt; &lt;% for(var i =0;i&lt;arrylist.length;i++) &#123; %&gt; &lt;li&gt;&lt;% arrylist[i] %&gt;&lt;/li&gt; &lt;% if(non)&#123;%&gt; &lt;p&gt;prar&lt;/p&gt; &lt;% ss %&gt; &lt;%&#125;%&gt; &lt;% &#125; %&gt; &lt;div&gt; &lt;% ss %&gt; &lt;/div&gt;&lt;/html&gt;`;var outStr = template(templateStr, &#123; ss: 2, arrylist: [1, 2, 3, 4], non: 1 &#125;);console.log('out_str_is', outStr);/* out_str_is &lt;html&gt;&lt;li&gt;1&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;2&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;3&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;li&gt;4&lt;/li&gt;&lt;p&gt;prar&lt;/p&gt;2&lt;div&gt;2&lt;/div&gt;&lt;/html&gt;*/ 梳理一下： 利用强大的正则 利用Function的动态构造函数能力，使得if else等语句得以执行 参考文献：http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"下拉+滑动","date":"2017-02-25T13:20:52.000Z","path":"2017/02/25/下拉+滑动/","text":"\b滑动使用了left,性能会有影响","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"截图实践","date":"2017-02-20T13:20:52.000Z","path":"2017/02/20/截图实践/","text":"一.概述二.phantomjs实现三.前端canvans实现 一.概述背景：在运营活动中发现，通过截图分享得到的回流率较高。传统截图方式时手机同时按2个键，一是会把手机状态栏截图，二是截图操作不是处于活动流程中，需要提示用户。注意：需求是截屏得到一个图片的URL（不是得到一个可以展示的img标签）这决定了一种canvas的实现无法做到兼容截屏通常的形式有工具和浏览器能力2种，如下：1.利用浏览器需要利用到canvas的能力，canvas.drawImg方法即可吧图片绘制到canvas中，但是还需要把canvas数据换成blob，模拟文件上传。2.后端形式需要利用到具体的工具，phantomjs作为微型浏览器，也是用js触发执行，与node场景吻合，快速实现 二.phantomJs后端实现对于程序员来说，命令式交互也是一种交互，如下：phantomJs 不是node,是微型浏览器通过键盘鼠标交互为传统的与浏览器交互，我们通过用指令的方式可以与phantomjs交互，相比常用浏览器，phantomJs少了绘制和合成的阶段，如下绿色部分phantomJs的使用很简单，下面是一个简单的例子，以链接形式打开页面，还可以直接给HTML字符打开页面：详细使用可以查看phantomjs API/github.js12345671. var page = require('webpage').create();2. page.open('http://github.com/', function() &#123;3. page.render('github.png');4. phantom.exit();5. &#125;); $ phantomjs github.js 在使用时，我们使用phantom包，这个包作为桥接，桥接了phantomjs，但要注意执行环境的区别，如下:phantom包的使用比较简单，只要注意环境区别就行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546let instance; let page; /* 创建实例 */ try &#123; instance = yield phantom.create(); page = yield instance.createPage(); &#125; catch(e)&#123; this.logger.error('init error',e) &#125; let pageCreate = `创建page实例用时$&#123;+(new Date())-startTime&#125;ms`; let pageCreateTime = +(new Date()); Time.pageCreate=pageCreate; /* phantom 页面 事件 注册 */ yield page.on('onConsoleMessage',function(msg) &#123; console.log('CC',msg); sendEvent(msg,logs) &#125;); yield page.on('onResourceRequested', function(requestData, networkRequest) &#123; &#125;); yield page.on('onResourceReceived',function(response) &#123; if(response &amp;&amp; response.url == 'http://127.0.0.1:8080/misc/getfont' &amp;&amp; response.stage == 'end')&#123; isFontCssLoaded = true; fontCssCb &amp;&amp; fontCssCb('success') &#125; &#125;); yield page.on('onLoadFinished',function(status)&#123; if(status == 'success') &#123; isFinishedLoaded = true; finishedCb &amp;&amp; finishedCb(status) &#125; &#125;); //转移cookie yield transferCookie.call(this,page); ………………………… 小问题，下面的cssStr变量1，2能取到么1234567891011121314151617181920212223242526一.const cssStr=` @font-face &#123; font-family: \"STXihei\"; src: url(\"http://127.0.0.1:8080/misc/getfont\"); &#125; body &#123; font-family: \"STXihei\", serif &#125;`;function evaluateJS(page)&#123; return page.evaluate(function () &#123; //这里能否使用cssStr变量？ &#125;)&#125;二.const cssStr=` @font-face &#123; font-family: \"STXihei\"; src: url(\"http://127.0.0.1:8080/misc/getfont\"); &#125; body &#123; font-family: \"STXihei\", serif &#125;`;function evaluateJS(page)&#123; return page.evaluate(function (cssStr) &#123;&#125;,cssStr)&#125; 两套环境体现在：一中的代码无法获取cssStr变量，需要用二中的方式，将变量序列化出去获得。然后最后我们没有使用phantomjs。 主要是是几个原因: 静态页面（直出内容是空白，前端把控时机）console.log(‘screenshot’) 检测页面dom出现 前端post整个HTML片段字库（机器没有字库，每次遇到新机器都要装字体） 慢（主要原因） 慢是最主要的原因 phantom\b不建议用在生产环境 从下图可看到，一个phantom过程需要花费的路径 打印出时间，基本要花费3S或以上 鉴于以上原因，舍弃了phantomjs的方案 三.前端canvas实现思路：把dom画在canvas上，然后canvas导出blob,模拟文件上传，把blob传到后端。遇到canvas画图，就有一个跨域，或者是污染的说法，什么是“被污染”的 canvas?尽管不通过 CORS 就可以在画布中使用图片（ctx.drawImage(domImg, 0, 0);），但是这会污染画布。一旦画布被污染，你就无法读取其数据。例如，你不能再使用画布的 toBlob(), toDataURL() 或 getImageData() 方法，调用它们会抛出安全错误。下面是几种会污染canvas的情况，如果画在canvas中的img的域满足一下几种的话： blob:http://localhost:6334/2a99e4f1-2009-4d9d-9812-83122eefe90d (协议不同) http://xxxxx (不同域) https://xxx (不同域) svg带foreignObject带html标签 (仅限Safari，普通svg不会污染) 由于html带有交互性质，比如visited过的link，出于安全考虑，Safari把这个数据导出禁止了，也可以理解为污染了canvas那么canvas就会被污染 对于ctx.drawImage( img, 0, 0 )会污染的唯一解决办法 (让 canvas.toBlob(), canvas.toDataURL()不报错)：img加载时需要有crossorigin 1&lt;img crossorigin=\"anonymous\" src=\"//p0.meitu……\" &gt; 12345var img = new Image(); img.crossOrigin=\"anonymous\";（已经加载好的dom无效） &gt; ps: 图片请求可以跨域（Access-Control-Allow-Headers) 有crossorigin属性的图片src必须是http(s) (ios error : Cross-origin image load denied by Cross-Origin Resource Sharing policy。ios认为crossorigin必须和http(s)关联) 画在canvas的图片为base64无交互格式图片 所以有一种把dom画在canvas上的方案就不符合，因为污染了canvas，即为svg有交互行为被阻止了 有一种方案是利用svg的能力原理：https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas如下12345678910111213141516171819202122232425 var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d'); var data = '&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\"&gt;' + '&lt;foreignObject width=\"100%\" height=\"100%\"&gt;' + '&lt;div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"font-size:40px\"&gt;' + //html '&lt;em&gt;I&lt;/em&gt; like' + //html '&lt;span style=\"color:white; text-shadow:0 0 2px blue;\"&gt;' + //html 'cheese&lt;/span&gt;' + //html '&lt;/div&gt;' + //html '&lt;/foreignObject&gt;' + '&lt;/svg&gt;'; var DOMURL = window.URL || window.webkitURL || window; var img = new Image(); var svgBlob = new Blob([data], &#123;type: 'image/svg+xml;charset=utf-8'&#125;); var base64 = fileReader.readAsDataURL(svgBlob)//data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcm……== img.onload = function () &#123; ctx.drawImage(img, 0, 0);//(手动加粗) canvas.toDataURL()//（ios 受阻碍）由于是blob协议，污染了canvas 这种svg图片是有交互的（html标签） &#125; img.src = base64;//(手动加粗) svg带foreignObject带html标签(仅限Safari，普通svg不会污染)ios调用toDataURL受阻（因为带了交互行为了） 插播一下rasterizeHTML的内联化实现如何把css文本转换为cssSheet(不污染本文档)?123456789101112var rulesForCssTextFromBrowser = function (styleContent) &#123; var doc = document.implementation.createHTMLDocument(\"\"), styleElement = document.createElement(\"style\"), rules; styleElement.textContent = styleContent; // the style will only be parsed once it is added to a document doc.body.appendChild(styleElement); rules = styleElement.sheet.cssRules; return Array.prototype.slice.call(rules);&#125;; 另一种实现：利用 html2canvas，这个库是纯计算dom，并用canvas API 绘制DOM，只要把图片都以base64形式传递给这个库，canvas就不会被污染纯canvas API绘制DOM（DOM需可见，因为要getComputedStyle, html2canvas）如图，先深度优先拿到所有图片dom，然后人工转base64，最后上传 组件\b内部使用，暂不开源 对于\b一些开发建议:对于能用img标签写的尽量用img标签写，并加上crossorigin属性 形如:1&lt;img crossorigin=\"anonymous\" src=\"//p0.meituan……\" &gt; 这样可以减少对图片的ajax请求，减少截屏耗时","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"自己实现lodash/cloneDeep","date":"2016-12-14T13:20:52.000Z","path":"2016/12/14/自己实现clonedeep/","text":"\blodash之cloneDeep的实现背景先回顾一下浅拷贝如图所示，浅拷贝是新建立了\b一个对象，但是对象每个key还是引用了之前的。而我们的深拷贝需要开辟所有的内存\b区域 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如图所示，要把\b上图中的对象深拷贝为下面的对象。 其实对于这种\b对象，\b用用递归就能简单实现。 但是要注意对于下图的循环引用↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如果要递归来拷贝的话，那么得要加一些逻辑，不然一个递归将无限进行下去，因为这里面的路径有一个环。\b参考lodash,我们用一个hashMap保存每个对象\b\b有没有被Copy过由于对象作为key,可以用\bsymbol，也可以用其他手段实现，这里我们用stack,stack每个元素为一个array pair\b来实现，当然这种实现不唯一。 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147module.exports=(function()&#123; /* \b用来存储\b有没有copy过的栈 */ function stackSet(key,value)&#123; //o(n) var data=this.__data__; var index=this.arryIndexOf(key); if(index&lt;0)&#123; //var data=[];//这个里面保存的是数组arry,数组的第一个是key,数组的第二个value data.push([key,value]); &#125; else&#123; data[index][1]=value &#125; &#125; function arryIndexOf(key)&#123; var data=this.__data__; var length=data.length; for(var i=0;i&lt;length;i++)&#123; var entry=data[i]; if(entry[0]==key) return i; &#125; return -1; &#125; function stackHas(key)&#123; var data=this.__data__; var length=data.length; for(var i=0;i&lt;length;i++)&#123; var entry=data[i]; if(entry[0]==key) return i!=-1; &#125; return false; &#125; function stackGet(key)&#123; //o(n) var index=this.arryIndexOf(key); if(index&lt;0)return; return this.__data__ &amp;&amp; this.__data__[index] &amp;&amp; this.__data__[index][1]; &#125; function Stack()&#123; var dataarry=[]; this.__data__=dataarry;//这个里面保存的是数组arry,数组的第一个是key,数组的第二个value &#125; Stack.prototype.get=stackGet; Stack.prototype.set=stackSet; Stack.prototype.arryIndexOf=arryIndexOf; /* Util functions */ var TAGS=[ '[object Number]', '[object Date]' ]; var toString=Object.prototype.toString; function isObject(object)&#123; return object!=null &amp;&amp; ( typeof object == 'object') &#125; function assignkeyvalue(object,key,value)&#123; object[key]=value; &#125; function baseAssign(object,props)&#123; var index=-1; var length=props.length; if(!object)&#123; return; &#125; var dest=&#123;&#125;; while(++index&lt;length)&#123; var key=props[index]; assignkeyvalue(dest,key,object[key]) &#125; return dest &#125; function getTag(object)&#123; return toString.call(object); &#125; /* 拷贝对象 */ function copyObject(object,stack)&#123; if(!isObject(object)) &#123; return &#125; var tag=getTag(object); if(!!~TAGS.indexOf(tag))&#123; //Number Data 还有很多，这里是个示意 var ctor=object.constructor; return new ctor(+object); &#125; var index=-1; var keys=Object.keys(object); var length=keys.length; var dest=&#123;&#125;; //keys not include symbol while(++index&lt;length)&#123; var key=keys[index]; if(isObject(object[key]))&#123; stack=stack||new Stack; //看对象有没有copy过 var saved_value=stack.get(object); if(saved_value)&#123; return saved_value &#125; //设置为已拷贝 stack.set(object,dest); //递归赋值 assignkeyvalue(dest,key,copyObject(object[key],stack)); &#125; else&#123; assignkeyvalue(dest,key,object[key]); &#125; &#125; return dest; &#125; /* 拷贝数组 */ function copyArry(arry)&#123; if(!Array.isArray(arry))&#123;return []&#125; var dest =[], index=-1, length=arry.length; while(++index&lt;length)&#123; if(isObject(arry[index]))&#123; dest[index]=copyObject(arry[index]) &#125; else&#123; dest[index]=arry[index] &#125; &#125; return dest; &#125; function cloneDeep(object)&#123; if(!isObject(object))return object; return Array.isArray(object)?copyArry(object):copyObject(object) &#125; return cloneDeep;&#125;)(); 接下来我们用mocha 写一些用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180var assert = require('assert');var deepClone = require('./clonedeep.js');var lodash = require('lodash');/* 这部分是自己的cloneDeep实现*/describe('cloneDeep', function() &#123; describe('own', function() &#123; it('plant object', function() &#123; var origin = &#123; a: 1, &#125;; var dest = deepClone(origin); assert.notEqual(origin, dest); &#125;); it('nest object', function() &#123; var origin = &#123; a: &#123; b: new Date(), &#125;, &#125;; var dest = deepClone(origin); assert.notEqual(origin, dest); assert.deepEqual(origin, dest, '应该相等'); assert.notEqual(origin.a, dest.a, '属性不应该相等'); &#125;); it('function', function() &#123; var origin = &#123; fuc: function() &#123;&#125;, &#125;; var dest = deepClone(origin); assert.ok(origin.fuc === dest.fuc); assert.equal(origin.fuc, dest.fuc); &#125;); it('arry', function() &#123; var orign = [1, 3, 3, 5, 9]; var dest = deepClone(orign); assert.notEqual(dest, orign); assert.deepEqual(dest, orign); &#125;); it('arry nest object', function() &#123; var origin = [&#123; a: &#123; b: 1 &#125; &#125;, &#123; b: new Number(1) &#125;]; var dest = deepClone(origin); assert.deepEqual(origin, dest); assert.notEqual(origin[0], dest[0]); assert.notEqual(origin[0].a, dest[0].a); &#125;); it('primary', function() &#123; var origin = 1; var dest = deepClone(origin); assert.equal(origin, dest); &#125;); it('primary object', function() &#123; var orgin = Object(1); var dest = deepClone(orgin); assert.notEqual(orgin, dest); assert.deepEqual(orgin, dest); assert.deepEqual(orgin.toString(), dest.toString()); &#125;); it('date', function() &#123; var orgin = new Date(); var dest = deepClone(orgin); assert.notEqual(orgin, dest); assert.deepEqual(orgin, dest); assert.deepEqual(orgin.toString(), dest.toString()); &#125;); it('undefine', function() &#123; var orgin = undefined; var dest = deepClone(orgin); // assert.notEqual(orgin,dest); assert.strictEqual(orgin, dest); //assert.deepEqual(orgin.toString(),dest.toString()); &#125;); it('circular reference', function() &#123; var orgin = &#123;&#125;; //orgin.a=orgin; var bb = &#123;&#125;; var cc = &#123;&#125;; bb.c = cc; cc.d = orgin; orgin.b = bb; var dest = deepClone(orgin); // assert.notEqual(orgin,dest); //console.log(orgin===dest) assert.notStrictEqual(orgin, dest); assert.notStrictEqual(orgin.b, dest.b); //assert.deepEqual(orgin.toString(),dest.toString()); &#125;); &#125;); /* 这部分是lodash的cloneDeep实现 */ describe('lodash', function() &#123; it('plant object', function() &#123; var origin = &#123; a: 1, &#125;; var dest = lodash.cloneDeep(origin); assert.notEqual(origin, dest); &#125;); it('nest object', function() &#123; var origin = &#123; a: &#123; b: new Date(), &#125;, &#125;; var dest = lodash.cloneDeep(origin); assert.notEqual(origin, dest); assert.deepEqual(origin, dest, '应该相等'); assert.notEqual(origin.a, dest.a, '属性不应该相等'); &#125;); it('function', function() &#123; var fuc = function() &#123;&#125;; var dest = lodash.cloneDeep(fuc); //console.log('fds',typeof dest) //for(var inn in dest)&#123; // console.log('ii',inn) //&#125; assert.notEqual(fuc, dest); &#125;); it('arry', function() &#123; var orign = [1, 3, 3, 5, 9]; var dest = lodash.cloneDeep(orign); assert.notEqual(dest, orign); assert.deepEqual(dest, orign); &#125;); it('arry nest object', function() &#123; var origin = [&#123; a: &#123; b: 1 &#125; &#125;, &#123; b: new Number(1) &#125;]; var dest = lodash.cloneDeep(origin); assert.deepEqual(origin, dest); assert.notEqual(origin[0], dest[0]); assert.notEqual(origin[0].a, dest[0].a); &#125;); it('primary', function() &#123; var origin = 1; var dest = lodash.cloneDeep(origin); assert.equal(origin, dest); &#125;); it('primary object', function() &#123; var orgin = Object(1); var dest = lodash.cloneDeep(orgin); assert.notEqual(orgin, dest); assert.deepEqual(orgin, dest); assert.deepEqual(orgin.toString(), dest.toString()); &#125;); it('date', function() &#123; var orgin = new Date(); var dest = lodash.cloneDeep(orgin); assert.notEqual(orgin, dest); assert.deepEqual(orgin, dest); assert.deepEqual(orgin.toString(), dest.toString()); &#125;); it('undefine', function() &#123; var orgin = undefined; var dest = lodash.cloneDeep(orgin); // assert.notEqual(orgin,dest); assert.strictEqual(orgin, dest); //assert.deepEqual(orgin.toString(),dest.toString()); &#125;); it('circular reference', function() &#123; var orgin = &#123;&#125;; //orgin.a=orgin; var bb = &#123;&#125;; var cc = &#123;&#125;; bb.c = cc; cc.d = orgin; orgin.b = bb; var dest = lodash.cloneDeep(orgin); // assert.notEqual(orgin,dest); assert.notStrictEqual(orgin, dest); assert.notStrictEqual(orgin.b, dest.b); //assert.deepEqual(orgin.toString(),dest.toString()); &#125;); &#125;);&#125;); \b\b测试有2部分，上面的部分是自己的cloneDeep，下面的是lodash的，测试结果通过其实\b是慢慢的迭代，对用例进行开发（\b\bTest-driven development）","tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://07lyt.com/tags/前端基础/"}]},{"title":"webpack v1 概览","date":"2016-11-28T13:20:52.000Z","path":"2016/11/28/webpack1/","text":"目录 Webpack简介 Webpack常用概念 Webpack运行时 Webpack使用 Webpack进阶 通灵塔webpack编译优化（Dll/DllReference） 1. Webpack 简介Webpack 是德国开发者 Tobias Koppers 开发的模块加载器。核心的理念是，视各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块，来使用和处理。 webpack.config.js 配置1.entry2.output 123456789101112131415161718var path = require(\"path\");var webpack = require(\"../../\");module.exports = &#123; entry: &#123; main: \"./example\", common: [\"./vendor\"] // optional &#125;, output: &#123; path: path.join(__dirname, \"js\"), filename: \"[name].chunkhash.js\", chunkFilename: \"[chunkhash].js\" &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: [\"common\"] &#125;) ] &#125;; 2. Webpack 常用概念 模块(module) chunk 资源(assets) loader(资源加载) plugin 代码分割 2.1 模块模块间依赖关系网(js,css,png,node_module) 模块使用CommonJs管理，每个模块有一个模块id,一般情况下id为数字，但可以使用插件换成文件具体路径，以下为id为184的模块 /* 184 */ /***/ function(module, exports, __webpack_require__) { var Core = __webpack_require__(185); var NativeCore = __webpack_require__(194); var Network = __webpack_require__(196); var Promise = __webpack_require__(188); Core.prototype._mixin(Core.prototype, NativeCore); Core.prototype._mixin(Core.prototype, Network); Core.prototype.all = function(list){ return Promise.all(list); }; module.exports = Core; /***/ }, 2.2 chunk 上图打包成chunk之后得到3个chunk chunk是一个或多个源文件的集合，可以是js,css,png等，表现为一个数组，装载这些文件.chunk有父子概念， 多个chunk也可以包含同一个module模块. 一般来说每个entry产生一个chunk,但可以借助插件来改变chunk的依赖情况（后续commonplugin会涉及），父子chunk的表现为chunk执行前置后置的关系 网状的modules最后经过webpack整理最后会表现为一个chunk有一个modules数组，这个数组全是module,且由webpack理清了网状依赖关系一个chunk有多个\bmodule,平行的module 每个chunk也有一个唯一的id,并且有对应的flag entry:runtime initial:优化chunk render:normal chunk 没有runtime 2.3 assets即为最终项目中引用的文件，一个资源文件中可能含有一个或多个chunk，并且有一个或多个module，表现如下 window[&quot;webpackJsonp&quot;] = function webpackJsonpCallback(chunkIds, moreModules) {} 2.4 loaderwebpack中所有文件即模块，用loader将所有文件转换为模块，loader为资源加载器，对于每一类文件都需要设置loader。loader是一个函数，可以传递参数进行loader设置常用loader有： babel-loader css-loader style-loader url-loader file-loader ………… 2.5 pluginplugin用处广泛，是webpack的重要组成部分，利用plugin可以侵入编译过程，改变chunk的依赖关系常用plugin: CortexRecombinerPlugin CommonsChunkPlugin ExtractTextPlugin WebpackShellPlugin ………… 2.6 代码分割代码分割得到的结果类似于RequireJS，可以异步加载模块分割点： CommonJs：require.ensure(dependencies, callback) AMD：require(dependencies, callback) 对于被分割后的chunk,其依赖也在被分割后的chunk里面 3. Webpack运行时常用的有有3个方法： __webpack_require__ __webpack_require__.e= function requireEnsure(chunkId, callback) {} webpackJsonp= function webpackJsonpCallback(chunkIds, moreModules) 1. __webpack_require____webpack_require__方法用来同步加载已经安装过的模块，即执行一个模块中的代码，得到module.exports的值， 要运行的模块在打包的时候就已经打包进assets中，属于同步加载，影响文件体积 2. requireEnsure__webpack_require__.e=requireEnsure 用以支持code spliting，通过挂载script标签来异步加载模块，不影响文件体积。 3. webpackJsonp= function webpackJsonpCallback(chunkIds, moreModules) webpackJsonp方法用来安装模块，方法中chunkIds表示本assets中包含的chunk，为一个数组，可以有1个或多个id，列出的chunkid标志即将安装的chunkid，安装过的chunk在异步加载时可以直接调用，不再需要加载script标签，第二个参数为包含的模块，可以为对象或者数组，其中对象标志有模块对应的模块id，在执行后这些模块将被加载进内存，可以通过__webpack_require__(模块id)的方式调用 4. Webpack使用4.1 webpack.config.js配置 entry output module resolve externals target devServer plugin 4.2 loader test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 链式调用:css!postcss!less 传参数：css?modules!postcss!less require指定：require(“style-loader!css-loader!less-loader!./my-styles.less”); 编写loader 4.3 plugin插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: &quot;common&quot;, filename: &quot;common.js&quot;, minChunks: Infinity//当项目中引用次数超过2次的包自动打入commons.js中,可自行根据需要进行调整优化 }), new ExtractTextPlugin(&quot;[name].css&quot;, { // disable: env == &quot;dev&quot;, allChunks: true }), new CortexRecombinerPlugin({ base: path.resolve(__dirname, relativeToRootPath), noBeta:env==&apos;product&apos; }), new webpack.WatchIgnorePlugin([path.resolve(__dirname, relativeToRootPath, &quot;./node_modules/@cortex&quot;)]), new WebpackShellPlugin({onBuildStart: [&apos;gulp&apos;]}) ] 1.CommonsChunkPlugin （4种使用情形 改变chunk依赖） 打包多个入口的共同文件(多页或者是多个执行环境)从不同入口抽出多个公共的模块，考虑如下简单情形有2个没有引入该插件的entry,得到2个分立的chunk,查看module发现有些模块是重用的因此可以将这些公共模块抽出，引入CommonsChunkPlugin，得到：抽出了公共模块出来共享模块分配到一个新的chunk中了: 打包工具库文件(现有项目使用)zepto,react,………… 移动共同依赖模块(code spliting增加页面初始化时间) 针对code spliting产生多个chunk的情形，移动一部分共同的chunk到common中，减少异步请求次数，针对代码分割点比较多又小的情况 异步加载共有common chunk针对code spliting，移动一部分公共的代码块形成一个异步common chunk,没有增加页面初始时间，但会在某个分割点加载分割common代码 2.DedupePlugin 去冗余 3.OccurrenceOrderPlugin 重设模块id,使得高使用率的模块获得数字较小的id,表现为内存优先加载 4.UglifyJsPlugin js压缩 5.DllPlugin 用来生成动态链接库 6.DllReferencePlugin 用来引入动态链接库 7.CortexRecombinerPlugin cortex代码转换，移动 8.DefinePlugin 给代码中引入变量 9.ProvidePlugin 提供全局变量，而不用在每个入口require(‘zepto’)等 new webpack.ProviderPlugin({ $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;window.jQuery&quot;:&quot;jquery&quot;})] 10.HotModuleReplacementPlugin 热更新插件，需要配合webpack-dev-server 11.ExtractTextPlugin 抽取文本，文本不一定是css,除了有module.exports的js和json文件都可以算是文本 12.……………… 4.4 externals假如我们需要通过标签来引入jquery，并且要写一个jquery插件，并且写的这个插件要用webpack打包，可以使用下面的配置 module.exports = { output: { //target也可以为UMD libraryTarget: &quot;window&quot;, library:[&apos;jquery&apos;,&apos;custom&apos;] }, externals: [&quot;$&quot;, &apos;jquery&apos;] } 以上的output表示给window的jquery.custom对象挂上我们的插件模块 window[&quot;jquery&quot;] = window[&quot;jquery&quot;] || {}; window[&quot;jquery&quot;][&quot;custom&quot;] =XXX externals表示代码中遇到require(‘jquery’)或者require(‘$’)不进行依赖判断，直接输出 module.exports = window[&quot;jquery&quot;]; externals也可以写为对象的形式 externals: { &quot;jquery&quot;: &quot;jQuery&quot; } require(‘jquery’)等价为：window.jQuery，所有的jquery都会被解析为jQuery，在UMD模式下，如果有CommonJs模块，require(‘jquery’)会被解析为require(‘jQuery’)， require(&apos;jquery&apos;)=&gt;require(&apos;jQuery&apos;) 要注意此时的2个不同的require，第一个require为webpack中使用的require，第二个为CommonJs的require 4.5 非标准模块引入 shimming-modules imports-loader require(&quot;imports?xConfig=&gt;{value:123}!./file.js&quot;) 引入全局变量xConfig={value：123}给到file.js exports-loader暴露到变量中 require(&quot;imports?variable=&gt;{}!exports?variable.XModule!./file.js&quot;) 先引入变量variable={}给到file.js再暴露XModule在variable对象中 expose-loader暴露到全局 require(&quot;expose?XModule!./file.js&quot;) 4.6 热更新 热更新依赖2个模块，一个是webpack-dev-server，是一个npm包，提供socket，类似静态资源服务器，第二个为HotModuleReplacement，可以通过提供插件或者命令行的形式启动HMR，要启动HMR需要在每个entry中加入，webpack/hot/dev-server或者webpack/hot/only-dev-server,前者在热更新失败的时候会刷新整个页面，后者不刷新，如果更新失败，需要手动刷新 热更新原理： webpack-dev-server为通过webpack打包生成的资源文件提供Web服务。通过Socket.IO连接着webpack-dev-server服务器的HMR runtime。webpack-dev-server发送关于编译状态的消息到客户端，客户端根据消息作出响应。 可视化工具webpack analyse 官方工具模块详情：chunk详情： webpack visualizer 分析模块占比 Webpack Chart 5. Webpack进阶/总结5.1 调试 使用react-transform-hmr热更新react 选择性热更新 if (module.hot) { module.hot.accept(&apos;./components/App&apos;, render); } 服务端集成，koa结合webpack-middleware 5.2 代码编写 某些模块只加载一部分（lodash,zepto） 代码分割（按行为/按环境(微信，DPApp)） 整合css-sprite（sprity） 分析打包报告（stats.json 可视化工具） 6. 通灵塔编译打包速度优化随着通灵塔功能越来越强大，其背后引用到的第三方库也越来越多，文件也变得越来越大，如图所示，编译后的模块有1835个，公共库加index.js接近7MB，现在一次编译打包的时间要5-15秒不等，每次启动通灵塔项目都要花一些时间，虽然CommonsChunkPlugin解决了公共库的问题，但是每次webpack编译都要生成一遍公共库common.js，由于common.js里都是相对稳定的三方库，如react,react-dom等，这些三方库应该不需要每次都编译打包，因而可以使用DllPlugin + DllReferencePlugin来解决，通过DllPlugin生成稳定的DLL模块，并让webpack不对这些模块每次都编译打包 先在项目路径下引入webpack.dll.js，内容如下所示，通过webpack.DllPlugin引入DLL插件，DllPlugin不执行模块代码，只提供了模块的实现，具体的调用还得其他模块来进行，其他模块利用DLL插件生成的映射关系.json文件来进行模块调用，之后利用OccurenceOrderPlugin来重排模块id,增加模块命中概率，利用UglifyJsPlugin来压缩JS，因为这个dll最后还是要写在HTML中以script标签的形式引用12345678910111213141516171819202122232425var path = require(\"path\");var webpack = require(\"webpack\");module.exports = &#123; entry: &#123; vendor: ['./vendors.js'] &#125;, output: &#123; path: path.join(__dirname, \"dll\"), filename: \"dll.[name].js\", library: \"[name]\" &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, \"dll\", \"[name]-manifest.json\"), name: \"[name]\" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin() ], resolve: &#123; root: path.resolve(__dirname, \"\"), modulesDirectories: [\"node_modules\"] &#125;&#125;; 项目入口设置一个vendors.js文件，将稳定的模块都可以放入这个js中，最后执行webpack --config webpack.dll.js生成DLL dll.vendor.js，如下所示得到了一个压缩后1.75MB的dll文件，并且一共有1083个模块，之后在原有项目中再引入DllReferencePlugin插件,由webpack根据manifest.json映射文件生成调用关系1234new webpack.DllReferencePlugin(&#123; manifest: require(\"../dll/vendor-manifest.json\"), context: path.join(__dirname, '..') &#125;), manifest.json片段：123\"./node_modules/react/react.js\": 1, \"./node_modules/process/browser.js\": 2, \"./node_modules/moment/moment.js\": 3 再执行webpack命令，打包得到如下结果common.js+index.js不到3M，一次编译打包也只有857个模块，少了1000多个模块的编译打包，实测打包速度快了2秒左右，根据机器差异和机器资源使用情况webpack编译打包的时间应该能快上1-5秒不等。最后消失的模块都跑到dll.vendor.js中了，为了让页面正常运行需要在页面中引入这个dll之后页面正常运行~总结：使用DLL+DllReferencePlugin能在开发阶段节省每次编译打包的等待，在beta或者线上也可以节省脚本执行webpack命令从开始到结束的时间，但是需要再引入一个script标签，需要视情况使用DLL。 DLL相关代码已push到通灵塔app-yy-ziggurat-dashboard的dll分支 参考资料： http://webpack.github.io/docs/ http://engineering.invisionapp.com/post/optimizing-webpack/ https://github.com/petehunt/webpack-howto http://gaearon.github.io/react-hot-loader/ https://github.com/petehunt/webpack-howto#8-optimizing-common-code","tags":[{"name":"基础工具","slug":"基础工具","permalink":"http://07lyt.com/tags/基础工具/"}]},{"title":"koa-generator解析","date":"2016-08-28T13:20:52.000Z","path":"2016/08/28/koa-generator解析/","text":"目录 引言 解析 讨论 1.引言 在koa中，存在着大量的中间件，koa并不绑定任何中间件，许多功能都要靠中间件来进行实现， @dp/node-server基于koa，koa-router作为koa的一个基础中间件，在很多web应用都有用到。在node-server中用到的==action==本质也是用到了koa-router，因此koa-router与我们的关系还是很紧密的，理解其原理对于我们写action有一定帮助。 1.1 回顾co+generator koa通过co来组合不同的generator,使得我们的中间件可以串行化执行，并提供downstrem，upstream回溯的能力。 co这个库，将我们的异步操作都串行化，koa中间件执行核心，即是先把所有generator fuction反复包装，然后调用co.wrap同步化 在图1中，橙色的箭头表示yield一个generator function或者是yield一个generator的点，通过co，我们得以递归的执行generator或者generator function。虚线的箭头表示控制权的交出与交回，绿色表示控制权在不在本函数内部，一个请求的经过所有中间件的时间等于图1中最下面的长条的时间。在最后一个中间件之后不存在我们注册的中间件，yield会将控制权交给一个noop空的generator function。如果之前还有yield非generator的点，co会将相关array,object,thunkfunction转为promise,统一对promise进行处理，并等待promise的resolve，期间控制权在node中，直到resolve之后控制权才交回我们的函数。图1·co+generator 过程 相关代码片段每app.use一次加入一个中间件generator function到this.middleware这个数组中12345678910app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are not allowed, // so we have to make sure that `fn` is a generator function assert(fn &amp;&amp; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function'); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn);///////////加入一个中间件 return this;&#125;; 反复包装的过程，不断的将得到的generator作为参赛传递到==下一个 generator==中:12345678910111213function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next);//反复包装 &#125; return yield *next; &#125;&#125; 123456789101112131415app.callback = function()&#123; var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); var self = this; if (!this.listeners('error').length) this.on('error', this.onerror); return function(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).then(function () &#123; respond.call(ctx);//通过co执行中间件,执行完成在respond中处理this.body &#125;).catch(ctx.onerror); &#125;&#125;; 2.koa-router解析 中间件一般都分为注册和执行2个阶段，一般我们只用关心注册的阶段，在执行阶段，执行的控制流完全交给了co，我们只提供了执行的实现，执行的时机由co把控。 2.2 koa-router用法 router.get(&#39;/&#39;, function *(next) {…}) HTTP动词注册 router.use(&#39;/&#39;, function *(next) {…}) 路径匹配注册 router.register(&#39;/&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…}) 多HTTP方法注册 router.param(&#39;param&#39;,function *(next){…}) 命名参数注册对于1，2两种注册方法，其本质是调用了3这个注册方法，对于4注册方法，是与其它注册方法不同的另外一种注册方法。 2.3 koa-router数据结构图2展示了koa-router 的内部数据结构，Router作为我们直接使用的对象，暴露register等方法，图2中Router对象的stack属性作为一个集合保存了多个Layer,每个Layer保存了本层的注册路径，并引用了多个中间件generator function，在我们的应用中，即为Action。在图3中，展示了一个Router拥有4个Layer的情况。 图2·koa-router中间件类图图3·Router进行了4次注册的情况 2.4 koa-router注册中间件流程一开始的GET,POST,PUT等HTTP动词都是调用了register方法，包括@dp/node-server里面的注册，也是直接调用了register进行路由注册,以register为例，图4中用户一开始调用register,会在Router中创建一个Layer对象，之后再使用layer的param进行命名参数注册，最后将得到的layer加入队列。 图4·koa-router注册顺序图 koa-router注册中间件相关片段1234567891011121314151617181920212223242526272829303132333435Router.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var stack = this.stack; //-------------&gt; create route var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || \"\", &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; //-------------&gt; add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); /* …………………… */ //-------------&gt; 加入stack中，增加了一个Layer stack.some(function (m, i) &#123; if (!m.methods.length &amp;&amp; i === stack.length - 1) &#123; return stack.push(route); &#125; else if (m.methods.length) &#123; if (stack[i - 1]) &#123; return stack.splice(i, 0, route); &#125; else &#123; return stack.unshift(route); &#125; &#125;); &#125; return route;&#125;; 2.4.1 koa-router注册过程分解1.router.register(&#39;/dp/ac4&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…})在这一步，我们注册’/dp/ac4’这个路径，注册get,post方法，router的数据结构会如图5红色部分所示变化。 图5·注册一个非命名参数情形 2.router.param(&#39;user&#39;,function *(next){…})在这一步注册了一个命名参数中间件，这时koa-router会在所有layer中检查是否有对应命名参数的layer已经注册，如图6，在第三个layer中，注册了user命名参数，其会新增一个action的引用,指向新增加的命名参数中间件，即为图中的红色部分。在执行阶段，如果路径匹配，这个action就会得到执行。 图6·注册一个命名参数的情形 3.router.register(&#39;/dp/:user&#39;,[&#39;GET&#39;,&#39;POST&#39;],function *(next){…})在这一步注册了一个带命名参数和路径的Layer，这时koa-router会在所有命名参数中检查是否有对应命名参数中间件已经注册，如图7中的==user==命名参数，如果已经有过注册，即会执行红色部分的注册过程，将引用指向已经注册过的命名参数中间件。 图7·注册一个带命名参数和路径的情形 2.5 koa-router中间件执行流程在注册完成以后，每来一个请求，就会进行中间件的执行，在请求到达我们的中间件之前，koa-router会依赖Path-to-RegExp进行路由路径的正则匹配，如图8所示，我们之前注册的路径通过红色部分的Path-to-RegExp组件将会转换为相应的正则表达式保存在各个Layer中，之后对于请求的路径，即会进行如图8所示的正则匹配，并获得相应的匹配结果。 图8·中间件执行前的处理在请求实际得到处理之前，会将所有符合请求路径与方法都匹配的路径筛选出，并进行中间件包装，包装过程与app.callback中的包装过程类似，每次传递generator到下一个中间件中，当所有Layer包装完成后，koa-router会交出控制权，由co来执行中间件函数。 图9·中间件执行前的处理图10中，如果HTTP的请求路径为’dp/ac1’，koa-router会将所有layer的路径进行正则匹配，如图，第一，二个匹配成功，在匹配完成之后，进行中间的包装过程，这个过程还会产生命名参数，包装过程从最后一个layer的最后一个action开始包装，依次传递generator，最后在包装完第一个layer的第一个action后得到一个generator，之后便可以将这个generator交于co来控制执行。 图10·中间件执行前的包装过程图11中，展示了有2个action（图中红色）匹配路径与方法的情况，在最下面的执行过程的白色部分，koa-router进行了中间件的包装，在包装完成之后，即橙色部分yield交出控制权，控制权交到了第一个action中，第一个action在执行完成或者执行中途，同样yield next在橙色部分将控制权交出到下一个action中，下一个action同样yield next将控制权交于相对于koa-router下一个中间件，之后控制权返回可以执行action剩余的动作。 图11·注册中间件执行过程 相关代码片段每次执行koa-router中间件的过程即是执行dispatch这个generator function的过程123456789101112131415161718192021222324252627282930313233343536373839 var dispatch = function *dispatch(next) &#123; var path = router.opts.routerPath || this.routerPath || this.path;//获得请求路径 var matched = router.match(path, this.method);//对本router中的layer进行匹配，得到匹配结果 var layer, i, ii;//加入上下文matched属性 if (this.matched) &#123; this.matched.push.apply(this.matched, matched.path); &#125; else &#123; this.matched = matched.path; &#125;//pathAndMethod为路径和HTTP方法都匹配的所有layer if (matched.pathAndMethod.length) &#123; i = matched.pathAndMethod.length; var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path this._matchedRoute = mostSpecificPath while (matched.route &amp;&amp; i--) &#123; layer = matched.pathAndMethod[i];//从最后一个layer开始压缩 ii = layer.stack.length; this.captures = layer.captures(path, this.captures);//构造上下文captures属性 this.params = layer.params(path, this.captures, this.params);//构造上下文命名参数 while (ii--) &#123;//对当前layer中所有的中间件进行压缩，从最后一个开始，压缩过程类似app.callback中compose的压缩过程，即不断的将generator传递 if (layer.stack[ii].constructor.name === 'GeneratorFunction') &#123; next = layer.stack[ii].call(this, next); &#125; else &#123; next = Promise.resolve(layer.stack[ii].call(this, next)); &#125; &#125; &#125; &#125;//交出控制权 if (typeof next.next === 'function') &#123; yield *next; &#125; else &#123; yield next; &#125; &#125;; 3.讨论我们的项目中的action，通常是一个generator function，==有一些接口没有写yield next==，由于我们的koa-router在@dp/node-server中是最后一个注册的中间件，所以不进行yield next影响也不大，但个人建议还是写yield next，如果今后在路由之后有进行this.body的处理，即koa-router不是最后一个中间件的情况，如果不写yield next，之后的中间件将会得不到执行；对于现在koa-router是最后一个中间件，即便写了yield next，控制流也会进入到一个内容为空的==noop==函数中，之后立即返回，对于执行逻辑不造成影响，所以建议还是在每一个action中写yield next~~。 参考资料：co: https://github.com/tj/cokoa: http://koa.bootcss.com/koa-router: https://github.com/alexmingoia/koa-routerpath-to-regexp: https://github.com/pillarjs/path-to-regexp","tags":[{"name":"node","slug":"node","permalink":"http://07lyt.com/tags/node/"}]},{"title":"domAPI/css","date":"2016-06-12T13:20:52.000Z","path":"2016/06/12/getBoundingClientRect/","text":"Reselect 解决selector中计算量过大的问题 multireducer 解决state中多个list导致state过大的问题（拆分list到state） reducer enhance —- 高阶reducer acdlite/redux-actions 是actionCreactor的\b工厂方法 javascript 可以说都是传值的，对于引用类型来说是应该叫传共享调用 call by shareref:https://github.com/nodejh/nodejh.github.io/issues/32 getBoundingClientRect的top的是盒模型上边缘与视口顶端的距离其bottom为盒模型下边缘与视口顶端的距离 text-shadow: h-shadow v-shadow blur color;水平方向，垂直方向 Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。 Object.getOwnPropertyNames 返回一个数组，该数组对元素是 obj 自身拥有的枚举或不可枚举属性名称字符串。 数组中枚举属性的顺序与通过 for…in 循环（或 Object.keys）迭代该对象属性时一致。 数组中不可枚举属性的顺序未定义。 下面的例子演示了该方法不会获取到原型链上的属性： function ParentClass() {}ParentClass.prototype.inheritedMethod = function() {}; function ChildClass() { this.prop = 5; this.method = function() {};} ChildClass.prototype = new ParentClass;ChildClass.prototype.prototypeMethod = function() {}; console.log( Object.getOwnPropertyNames( new ChildClass() // [“prop”, “method”] )); 1.jquery.dotdotdot 2：.header{ overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;} 单行overflow: hidden;white-space: nowrap;text-overflow: ellipsis;","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"不一样的前端手指操","date":"2016-06-12T13:20:52.000Z","path":"2016/06/12/不一样的前端手指操/","text":"看见题目可能有点好奇，不过看下去你就知道什么叫手指操了~ 目录 引言 原理 核心库 实现 关键帧/图片调整 spritesheet progressbar 可能会遇到的问题 相关工具 访问地址 写在前面（特别注意）在移动端上做动画，一定不能用top,bottom,background-position等元素做动画,不管是JS动画还是CSS动画。主要是浏览器重排，重绘，合成等，只能用4个(需要加translateZ(0)开启GPU加速)：translate,scale,opacity,rotate。详细资料参考： 高性能动画 各CSS元素渲染情况 高性能 Mobile Web 开发 Rendering: repaint, reflow/relayout, restyle 引言毕业季没事做，一直都对视差滚动感兴趣，感觉很新鲜（虽然现在已经不火了）不过还是决定试试看，先看看效果。 片段演示（完整版访问地址在最后）片段演示 原理用了一点视差滚动的效果，可能不明显，关于视差滚动，与很多资料，本质是不同层的移动速度不同，比如坐火车时，远处的物体移动得慢，近处的物体移动的很快，我们就人为的实现这种速度的差异参考demo。 参考资料： 视差滚动原理介绍 Parallax Scrolling 视差滚动相关 视差滚动 如果再结合一些动画，就可以得到如下的比较cool的页面： 参考demo: http://tedxguc.com/ http://everylastdrop.co.uk/ http://nasaprospect.com/ 核心库为了实现上述的效果，选择了skrollr这个库，使用这个库，懂CSS就可以玩出这个效果了，用关键帧加CSS就可以了123456&lt;section class=\"scene1 fullpage\" data-6300=\"transform:translate3d(0,0%,0);display:block\" data-10000=\"transform:translate3d(0,-100%,0);display:block\" data-30000=\"transform:translate3d(0,-100%,0);display:block\" data-33000=\"transform:translate3d(0,-130%,0);display:none\"&gt;&lt;/section&gt; 总的来说，共使用了 skrollr 多用于桌面端，用在了移动端效果也不错，用起来很方便 zepto 不用多说 imagesloaded 图片预加载 相当简单nice 实现 关键帧/图片调整在skrollr初始化之前，需要对图片进行一些调整，首先选好了图片之 后，得保证显示在手机上不变形，因而需要根据不同的手机屏幕大小调整 图片的大小，然后再根据所得的图片设置一下结束的关键帧。 background是设置结束关键帧ratio是设置背景图片的比例 123456789101112$.plug.background(true,\".scene1-1\",6700,$.plug.ratio(true,1080,1920,\".scene1-1\"));$.plug.background(false,\".scene2-1\",18000,$.plug.ratio(false,4500,1667,\".scene2-1\"));$.plug.background(false,\".scene2-2\",22000,$.plug.ratio(false,4500,1667,\".scene2-2\"));$.plug.background(false,\".scene3-1\",42000,$.plug.ratio(false,3840,2160,\".scene3-1\"));$.plug.background(false,\".scene3-2\",48000,$.plug.ratio(false,3840,2160,\".scene3-2\"));$.plug.background(false,\".scene4-1\",58000,$.plug.ratio(false,2560,1496,\".scene4-1\"));$.plug.background(false,\".scene4-2\",62000,$.plug.ratio(false,2560,1496,\".scene4-2\"));$.plug.background(false,\".scene5-1\",76000,$.plug.ratio(false,2857,1216,\".scene5-1\"));$.plug.background(false,\".scene6-1\",112000,$.plug.ratio(false,800,800,\".scene6-1\"));$.plug.background(true,\".scenev-1-1\",94000,$.plug.ratio(true,600,1200,\".scenev-1-1\"));$.plug.background(true,\".scenev-1-2\",98000,$.plug.ratio(true,600,1200,\".scenev-1-2\"));$.plug.background(true,\".scenev-1-3\",102000,$.plug.ratio(true,600,1200,\".scenev-1-3\")); 如下所示，对于横向图片，以手机高度为准，先根据手机高度设置图片高 度，再根据图片比例设置图片的长度，对于纵向显示的图片，以屏幕宽度为准，手法类似，代码非常简单。 12345678910111213141516171819202122 (function($)&#123; function ratio(iswidth,width,height,dom,scale,isback)&#123; var ratioo=scale||1; var ratio=width/height; if(iswidth)&#123; var wi=window.innerWidth*ratioo; var numb=Math.round(wi/ratio); var _pxheight=numb+\"px\"; document.querySelector(dom).style.height=_pxheight; return numb; &#125; else&#123; var he=window.innerHeight*ratioo; var numb=Math.round(he*ratio); var _pxwidth=numb+\"px\"; document.querySelector(dom).style.width=_pxwidth; return numb; &#125; &#125; if(!$.plug)$.plug=&#123;&#125;; $.plug.ratio=ratio; &#125;)($) 一开始确定好容器大小，初始化一些白色的小型div,再通过CSS3动画让他们不停旋转，即是星星的感觉。再根据前景和背景的运动速度不同，造成视差滚动。对于动画，大多使用transform:translate3d，且以百分比做动画，以百分比做动画意味着是以自身元素为参照，不是父级元素，因而为了避免有些小型元素移动100%的距离只相当于移动了它自身大小的问题，将所有的元素都套在一个fullpage的div中: 1234567.fullpage&#123; width: 100%; height: 100%; position: absolute; left: 0; top:0&#125; 对这个嵌套元素进行移动，下面是各背景与前景，使他们以不同速度移动，可以通过设置不同的data-number值实现。 spritesheet对游戏制作的同学不会肯定不会陌生这样的代码一大堆，我贴个自己实现的，简单再说一下对于这个5793*158的spritesheet，如果在手机上显示高度为100px，则宽度为5793/1.58=3666px，则每次spritesheet移动的距离为3666px/36(动画一共有36帧）=102px，对应下面的JS代码中的interval参数，同时为了停止有个缓冲，加了个停止帧stopframe参数。123456789101112131415161718192021222324252627282930313233343536373839404142434445(function($)&#123; function animate(totaltime,dom,parts,interval,stopframe)&#123; var temp=0; var stop_flag=false; var timer=null; var num=temp*(interval); $(dom).css(&#123;\"background-position-x\":num+\"px\"&#125;); temp++; if(stop_flag&amp;&amp;temp===stopframe)&#123; clearInterval(timer),timer=null stop_flag=false; &#125; if(temp===parts)temp=0; return &#123; animating:function()&#123;return timer!==null?true:false&#125;, stop:function(va)&#123; stop_flag=true; //clearInterval(timer),timer=null &#125;, resume:function()&#123; if(timer!==null)return var str=$(dom).css(\"background-position-x\"); var matched=str.match(/-?[0-9]+/); var num=parseInt(matched[0]); temp=num/interval; timer=setInterval(function()&#123; var num=temp*(interval); $(dom).css(&#123;\"background-position-x\":num+\"px\"&#125;); temp++; if(stop_flag&amp;&amp;temp===stopframe)&#123; clearInterval(timer),timer=null stop_flag=false; &#125; if(temp===parts)temp=0 &#125;,totaltime/parts); &#125; &#125; //$(dom) &#125; if(!$.plug)$.plug=&#123;&#125;; $.plug.animate=animate; &#125;)($) progressbarprogressbar的实现使用了2个半圆的形式 利用border-radius：50%做一个圆，再利用clip: rect(0,auto,auto,50px)裁切为半圆。 之后再从垂直正中开始裁切clip: rect(0,auto,auto,50px);左半圆类似:将2个区域合并：加一个背景色相同的mask覆盖在中间，这样的好处是圆环宽度可以方便调整： 之后就可以通过代码设置其百分比： 12345678910111213141516171819202122 (function($)&#123; function circleprogress(dom,value)&#123; $(dom).each(function(index, el) &#123; var num = value * 3.6; num=Math.round(num); if (num&lt;=180) &#123; $(this).find('.right').css('-webkit-transform', \"rotate(\" + num + \"deg) translateZ(0px)\"); $(this).find('.right').css('transform', \"rotate(\" + num + \"deg) translateZ(0px)\"); $(this).find('.left').css('-webkit-transform', \"rotate(\"+0+ \"deg) translateZ(0px)\"); $(this).find('.left').css('transform', \"rotate(\"+0+ \"deg) translateZ(0px)\"); &#125; else &#123; $(this).find('.right').css('-webkit-transform', \"rotate(180deg) translateZ(0px)\"); $(this).find('.left').css('-webkit-transform', \"rotate(\" + (num - 180) + \"deg) translateZ(0px)\"); $(this).find('.right').css('transform', \"rotate(180deg) translateZ(0px)\"); $(this).find('.left').css('transform', \"rotate(\" + (num - 180) + \"deg) translateZ(0px)\"); &#125;; &#125;);&#125; if(!$.plug)$.plug=&#123;&#125;;$.plug.circleprogress=circleprogress; &#125;)($) 在滑动的过程中，配置好滑动的区间即可： 12345 if(data.curTop&gt;=20000 &amp;&amp; data.curTop&lt;25000)&#123; var num=Math.round((data.curTop-20000)/55); $('.circle-1').find('span.value').text(num); $.plug.circleprogress('.circle-1',num);&#125; 可能会遇到的问题 对于配置稍低的手机，比如我的4S，在场景越来越多，图片越来越多的情况下，不管是在微信中打开还是原生浏览器中打开，都会把微信和浏览器弄崩溃。。期间尝试了各种优化，把所有关于layout和paint的动画部分都替换，情况稍微好一些，但是还是有崩溃的现象。最后发现网页加载时要对所有的场景进行渲染，即便这些场景一开始并不需要出现。所以根据动画情况，将需要出现的场景动态显示，且在css中加入下面的语句,让所有场景及信息一开始都不渲染。123 .scene1,.scene2,.scene3,.scene4,.scene5,.scene6,.infomation&#123;display: none; &#125; 最后根据skrollr的值来选择显示的场景。 通过这样的做，我的4s终于再也不崩溃了，即便在有些低配手机还是有点卡。 相关工具 图片压缩 图像处理：不管是jpg还是 gif都能去除背景，强烈推荐，特别是gif功能，相当好用 字体 webfont/icon 图片处理：国内工具 再贴几个图像处理工具，都是在线的，相当不错 http://animizer.net/en/gif-apng-converter 很强大，有自动根据 gif生成spritesheet的功能，不过有时候生成的效果不大好 http://www190.lunapic.com/editor/?action=transparent http://ezgif.com/ 这些图像处理网站后台可能用的的是imagemagick（瞎猜的） 作为一个程序员如何找图片及配色 图片:都是免费无水印，但是还是自己用就好了 设计导航 wallhaven: 高分辨率大图 dribbble：不用多说 很多素材都来自这，也有很多gif freepik gif: gif集合 vectorhq Pinterest 站酷 freevectors icon freevec 配色:本人喜欢flat扁平化的风格，所以都是相关的颜色 flat ui colors coolors flatuicolorpick material design flatcolors 先在上面的网站找些喜欢的颜色 然后再去下面的网站生成相关的互补色等colorhexa：颜色分析，输入一个颜 色，分析其各属性paletton：相当 好用的选色工具，还可以看效果 访问地址 用手机看直接点这里访问（也可以打开调试器看看效果）","tags":[{"name":"前端","slug":"前端","permalink":"http://07lyt.com/tags/前端/"}]},{"title":"编译原理","date":"2015-07-02T13:20:52.000Z","path":"2015/07/02/编译原理/","text":"最近复习并学习了编译原理先是词法分析代码都是看了龙书后徒手撸的，不是很成熟，但是能实现一些基本的能力定义一些运算符，以及一些保留字，方面后续使用123456789101112131415161718192021222324252627282930313233343536import Token from './token.js';import TAG from './tag.js';export default class Word extends Token &#123; constructor(value, tag) &#123; super(tag); this.value = value; &#125; static and = new Word('&amp;&amp;', TAG.AND); static or = new Word('||', TAG.OR); static less = new Word('&lt;', TAG.LE); static greater = new Word('&gt;', TAG.GE); static greater_equal = new Word('&gt;=', TAG.GEE); static less_equal = new Word('&lt;=', TAG.LEE); static equal = new Word('==', TAG.EQUAL); static assign = new Word('=', TAG.ASSIGN); static not = new Word('!', TAG.NOT); static not_equal = new Word('!=', TAG.NOTE); static divide = new Word('/',TAG.DIVIDE) static divide_equal = new Word('/=',TAG.DIVIDEE) //保留字 static if = new Word('if', TAG.IF); static else = new Word('else', TAG.ELSE); static while = new Word('while', TAG.WHILE); static do = new Word('do', TAG.DO); static switch = new Word('switch', TAG.SWITCH); static true = new Word('true', TAG.TRUE); static false = new Word('false', TAG.FALSE); toString() &#123; return this.value; &#125;&#125;export const RESERVEDWORDS = [Word.if, Word.else, Word.while, Word.do, Word.switch, Word.true, Word.false].map(ele =&gt; &#123; return ele.toString();&#125;); 并且实现有类型的单词1234567891011121314151617import Word from './word.js';import Tag from './tag.js';export default class Type extends Word &#123; constructor(value, length) &#123; super(value, Tag.BASIC); this.value = value; this.length = length; &#125; static int = new Type('int', 1); static bool = new Type('bool', 1); static float = new Type('float', 8); static char = new Type('char', 1); toString() &#123; return this.value; &#125;&#125;export const TYPEWORDS = [Type.int, Type.bool, Type.float, Type.char].map(ele =&gt; ele.toString()); 词法分析，感觉实现不够优雅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159export default function lexier(tokenCollection, str) &#123; let start = 0; let end = str.length; function move() &#123; start++; &#125; function getCurrentChar() &#123; return str[start]; &#125; function getLookAheadChar() &#123; return str[start + 1]; &#125; while (start != end) &#123; let character = getCurrentChar(); if (character == '' || character == '\\n' || character == '\\r' || character == ' ' || character == ';') &#123; move(); continue; &#125; if (isLetter(character)) &#123; let character_letter = character; let isLetterFlag = true; let word = ''; while (isLetterFlag) &#123; word += character_letter; move(); character_letter = getCurrentChar(); isLetterFlag = isLetter(character_letter); &#125; //处理保留字 如if else if (RESERVEDWORDS.indexOf(word) &gt; -1) &#123; tokenCollection.push(Word[word]); &#125; else if (TYPEWORDS.indexOf(word) &gt; -1) &#123; //处理类型 如int float tokenCollection.push(Type[word]); &#125; else &#123; //标识符 如 goods tokenCollection.push(new Word(word, Tag.ID)); &#125; continue; &#125; //处理数字 if (isNumbericFn(character)) &#123; let character_letter = character; let isNumberic = true; let word = ''; //不带小数点 let isReal = false; while (isNumberic) &#123; word += character_letter; move(); character_letter = getCurrentChar(); isNumberic = isNumbericFn(character_letter); if (!isNumberic &amp;&amp; character_letter == '.') &#123; //带小数点 isReal = true; //继续进行下去 isNumberic = true; &#125; &#125; if (isReal) &#123; tokenCollection.push(new Real(parseFloat(word))); &#125; else &#123; tokenCollection.push(new Real(parseInt(word))); &#125; continue; &#125; //如何判断 -3 和 8-5 是在语法分析的时候判断么 //TODO + - += -= ++ * *= switch (character) &#123; case '/': //有三种情况 / ----&gt; /= // /* if (getLookAheadChar() == '/') &#123; let subStr = str.substring(start, str.length); //匹配到第一个换行符 //算出第一个换行符的index,更新start游标，然后把这一段作为一个token输入 let commentLength = subStr.match(/[\\r\\n]/).index; let newStart = commentLength + start; // tokenCollection.push(new Comment(subStr.substring(0, commentLength))); start = newStart; &#125; else if (getLookAheadChar() == '*') &#123; //匹配到第一个*/ let subStr = str.substring(start, str.length); //算出第一个换行符的index,更新start游标，然后把这一段作为一个token输入 let commentLength = subStr.match(/\\*\\//).index + 2; // */ 2个大小 let newStart = commentLength + start; tokenCollection.push(new Comment(subStr.substring(0, commentLength))); start = newStart; &#125; else if (getLookAheadChar() == '=') &#123; // 处理 /= move(); tokenCollection.push(Word.divide_equal); move(); &#125; else &#123; tokenCollection.push(Word.divide); move(); &#125; break; case '&gt;': if (getLookAheadChar() == '=') &#123; move(); tokenCollection.push(Word.greater_equal); &#125; else &#123; tokenCollection.push(Word.greater); &#125; move(); break; case '&lt;': if (getLookAheadChar() == '=') &#123; move(); tokenCollection.push(Word.less_equal); &#125; else &#123; tokenCollection.push(Word.less); &#125; move(); break; case '=': if (getLookAheadChar() == '=') &#123; move(); tokenCollection.push(Word.equal); &#125; else &#123; tokenCollection.push(Word.assign); &#125; move(); break; case '!': if (getLookAheadChar() == '=') &#123; move(); tokenCollection.push(Word.not_equal); &#125; else &#123; tokenCollection.push(Word.not); &#125; move(); break; case '&amp;': if (getLookAheadChar() == '&amp;') &#123; move(); tokenCollection.push(Word.and); &#125; else &#123; tokenCollection.push(new Token(character)); &#125; move(); break; case '|': if (getLookAheadChar() == '|') &#123; move(); tokenCollection.push(Word.or); &#125; else &#123; tokenCollection.push(new Token(character)); &#125; move(); break; default: tokenCollection.push(new Token(character)); move(); break; &#125; &#125;&#125; 之后是语法分析,用的LL(1)型语法，相比龙书的实现，我把各个非终结符都写到了一个函数中，可读性没龙书强，但是代码较短,只写了表达式的部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//标识符构造函数function Id(token, value) &#123; this.token = token; this.value = value;&#125;//双目操作符构造函数function binaryOpe(token, leftExpr, rightExpr) &#123; this.token = token; this.leftExpr = leftExpr; this.rightExpr = rightExpr;&#125;//单目操作符构造函数function uniOp(token, expr) &#123; this.token = token; this.expr = expr;&#125;//自左向右读取的位置function getCurrentToken() &#123; return tokens[start];&#125;//移动function move() &#123; start++;&#125;//匹配function walk(match) &#123; let token = tokens[start]; if (match == token.toString()) &#123; start++; &#125; else &#123; throw `walk erro at $&#123;match&#125;`; &#125;&#125;//双目优先级 这个数组是有优先级的，前面的优先级高，优先递归前面的const LEVEL = [ Tag.OR, Tag.AND, Tag.EQUAL, Tag.GE, Tag.GEE, Tag.LE, Tag.LEE, Tag.ADD, '+', Tag.SUB, Tag.MUTIPLE, Tag.DIVIDE, Tag.MINUS, '-', Tag.NOT, Tag.REAL, Tag.ID, '(',];//单目优先级 const NOTCALC = ['-', Tag.NOT];//终结符优先级 const FACTORS = [Tag.REAL, Tag.ID, '('];let tokens = [];let start = 0;//测试表达式let code = `lyt+2323&amp;&amp;(33223-22||(ff)||fe&lt;---3332-3&amp;&amp;few==21&amp;&amp;feww==3223||ffffff==3232||!f&amp;&amp;f&gt;=21);`;//let code = `fe&lt;---3332-3&amp;&amp;few==21&amp;&amp;feww==3223||ffffff==3232||!f&amp;&amp;f&gt;=21;`;//获得词法数组Lexi(tokens, code);//表达式分析let exprtree = expression(LEVEL[0], 0);function expression(expect, i, isOperatedMinus) &#123; let currentToken = getCurrentToken(); let right, left; if (FACTORS.indexOf(expect) &gt; -1 &amp;&amp; FACTORS.indexOf(currentToken.tag) &gt; -1) &#123; if (currentToken.tag == '(') &#123; move(); let expr = expression(LEVEL[0], 0, false); walk(')'); return expr; &#125; let currentTokeniN = getCurrentToken(); move(); return new Id(currentTokeniN, currentToken.tag); &#125; if (!isOperatedMinus &amp;&amp; NOTCALC.indexOf(expect) &gt; -1 &amp;&amp; NOTCALC.indexOf(currentToken.tag) &gt; -1) &#123; let currentTokeniN = getCurrentToken(); move(); if (currentTokeniN.tag == '-' &amp;&amp; getCurrentToken().tag != '-') &#123; return new uniOp(currentTokeniN, expression(LEVEL[i + 1], i + 1, true)); &#125; return new uniOp(currentTokeniN, expression(expect, i, isOperatedMinus)); &#125; left = expression(LEVEL[i + 1], i + 1, isOperatedMinus); if (isOperatedMinus) return left; while ( (getCurrentToken() &amp;&amp; getCurrentToken().tag == expect) || (getCurrentToken() &amp;&amp; getCurrentToken().tag == '-') ) &#123; let currentTokeniN = getCurrentToken(); move(); //构建左边 left = new binaryOpe(currentTokeniN, left, expression(LEVEL[i + 1], i + 1, isOperatedMinus)); &#125; return left;&#125; 得到的表达式树如下 之后是求first集和follow集：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185import _ from 'lodash';const wenfa = `E-&gt;TK K-&gt;+TK K-&gt;$ T-&gt;FM M-&gt;*FM M-&gt;$ F-&gt;i F-&gt;(E) `;let GfisrtCollection = &#123;&#125;;let GfollowCollection = &#123;&#125;;let wenfaData = [];let wenfaCollection = wenfa.split('\\n').filter(ele =&gt; ele.trim()).map(ele =&gt; ele.trim());wenfaCollection.forEach(ele =&gt; &#123; let pair = ele.split('-&gt;'); wenfaData.push(pair);&#125;);first(wenfaData, 'E');first(wenfaData, 'T');first(wenfaData, 'K');first(wenfaData, 'M');first(wenfaData, 'F');follow(wenfaData, 'E');follow(wenfaData, 'T');follow(wenfaData, 'K');follow(wenfaData, 'M');follow(wenfaData, 'F');debugger;function ensureFollowKeyArray(collection, key) &#123; !collection[key] &amp;&amp; (collection[key] = ['#']);&#125;function isInCollection(collection, character) &#123; return collection.indexOf(character) &gt; -1;&#125;function isNonTerminal(character) &#123; return /[A-Z]/.test(character);&#125;function isEndCharacter(character) &#123; return character == '$';&#125;function isEndCharacterInCollection(collection) &#123; return collection.indexOf('$') &gt; -1;&#125;//export function first(wenfaData, expected) &#123; if (!isNonTerminal(expected)) &#123; return [expected]; &#125; if (GfisrtCollection[expected]) return GfisrtCollection[expected]; for (let i = 0; i &lt; wenfaData.length; i++) &#123; let production = wenfaData[i]; let nonTerminal = production[0]; let rightExpr = production[1]; //匹配到 if (nonTerminal == expected) &#123; firstCalc(rightExpr, nonTerminal, wenfaData); &#125; &#125; return GfisrtCollection[expected];&#125;/*求FIRST集的步骤如下：若X-&gt;a..，则将终结符ａ加入FIRST(X)中;若X-&gt;e ,则将终结符e加入FIRST(X)中(e表示空集)；若 X-&gt;BCD…E,则将First（B）所有元素（除了空集）加入 First（X），然后检测First（B），若First（B）中不存在空集, 即e,则停止，若存在则向B的后面查看，将First（C）中所有元素（除了空集）加入First（X），然后再检测First（C）中是否有e…直 到最后，若E之前的所有非终结符的First集中都含有e,则检测到E时，将First（E）也加入First（X），若First（E）中含有e,则将 e加入First（X）。前两条都挺容易理解的，第三条解释一下：一段文法，如果前面的非终结符号不能推出空集，那么后面的非终结符号所产生的终结符号就永远不可能成为文法的首符，于是就需要特殊考虑空集的情况。*///必须要消除左递归的export function firstCalc(rightExpr, leftNonTerminal, wenfaData) &#123; if (!isNonTerminal(leftNonTerminal)) &#123; return [leftNonTerminal]; &#125; for (let i = 0; i &lt; rightExpr.length; i++) &#123; let character = rightExpr[i]; if (isNonTerminal(character)) &#123; //如果是非终结符，要递归 let fisrtCollection = first(wenfaData, character); if (isEndCharacterInCollection(fisrtCollection)) &#123; //有空集 !GfisrtCollection[leftNonTerminal] &amp;&amp; (GfisrtCollection[leftNonTerminal] = []); if (i != rightExpr.length - 1) &#123; //去掉终结符 GfisrtCollection[leftNonTerminal] = GfisrtCollection[leftNonTerminal].concat( _.without(fisrtCollection, '$') ); &#125; else &#123; //最后一个 加上终结符 GfisrtCollection[leftNonTerminal] = GfisrtCollection[leftNonTerminal].concat(fisrtCollection); &#125; //去重 GfisrtCollection[leftNonTerminal] = _.uniq(GfisrtCollection[leftNonTerminal]); //继续递归 continue; &#125; else &#123; //没有空集 !GfisrtCollection[leftNonTerminal] &amp;&amp; (GfisrtCollection[leftNonTerminal] = []); //合并 GfisrtCollection[leftNonTerminal] = GfisrtCollection[leftNonTerminal].concat(fisrtCollection); //去重 GfisrtCollection[leftNonTerminal] = _.uniq(GfisrtCollection[leftNonTerminal]); break; &#125; &#125; else &#123; //终结符 !GfisrtCollection[leftNonTerminal] &amp;&amp; (GfisrtCollection[leftNonTerminal] = []); if (!isInCollection(GfisrtCollection[leftNonTerminal], character)) &#123; GfisrtCollection[leftNonTerminal].push(character); &#125; break; &#125; &#125; return GfisrtCollection[leftNonTerminal];&#125;/* 求FOLLOW集的算法思想 对于文法G中每个非终结符A构造FOLLOW(A)的办法是,连续使用下面的规则,直到每个FOLLOW不在增大为止.(1) 对于文法的开始符号S,置#于FOLLOW(S)中;(2) 若A-&gt;aBb是一个产生式,则把FIRST(b)\\&#123;ε&#125;加至FOLLOW(B)中;(3) 若A-&gt;aB是一个产生式,或A-&gt;aBb是一个产生式而b=&gt;ε(即ε∈FIRST(b))则把FOLLOW(A)加至FOLLOW(B)中*/export function follow(wenfaData, expected) &#123; if (!isNonTerminal(expected)) &#123; return [expected]; &#125; if (GfollowCollection[expected]) return GfollowCollection[expected]; for (let i = 0; i &lt; wenfaData.length; i++) &#123; let production = wenfaData[i]; let nonTerminal = production[0]; let rightExpr = production[1]; for (let i = 0; i &lt; rightExpr.length; i++) &#123; if (rightExpr[i] == expected) &#123; let afterCharacter = rightExpr[i + 1]; if (afterCharacter) &#123; //判断终结符还是非终结符 if (isNonTerminal(afterCharacter)) &#123; //非终结符 ensureFollowKeyArray(GfollowCollection, expected); //first 集 let firstCollection = GfisrtCollection[afterCharacter]; GfollowCollection[expected] = GfollowCollection[expected].concat( _.without(firstCollection, '$') ); GfollowCollection[expected] = _.uniq(GfollowCollection[expected]); if (isEndCharacterInCollection(firstCollection) &amp;&amp; nonTerminal != expected) &#123; GfollowCollection[expected] = GfollowCollection[expected].concat( follow(wenfaData, nonTerminal) //GfollowCollection[nonTerminal] ); GfollowCollection[expected] = _.uniq(GfollowCollection[expected]); &#125; else &#123; //如果没终结符 do nothing // &#125; &#125; else &#123; //终结符 ensureFollowKeyArray(GfollowCollection, expected); if (!isInCollection(GfollowCollection[expected], afterCharacter)) &#123; GfollowCollection[expected].push(afterCharacter); &#125; &#125; &#125; else &#123; //找到的是最后一个 if (nonTerminal != expected) &#123; ensureFollowKeyArray(GfollowCollection, expected); GfollowCollection[expected] = GfollowCollection[expected].concat( follow(wenfaData, nonTerminal) ); GfollowCollection[expected] = _.uniq(GfollowCollection[expected]); &#125; &#125; &#125; &#125; &#125; return GfollowCollection[expected];&#125; 执行完1234567891011121314first(wenfaData, 'E');first(wenfaData, 'T');first(wenfaData, 'K');first(wenfaData, 'M');first(wenfaData, 'F');follow(wenfaData, 'E');follow(wenfaData, 'T');follow(wenfaData, 'K');follow(wenfaData, 'M');follow(wenfaData, 'F');/*GfisrtCollectionGfollowCollection*/ first集合follow集保存在全局的GfisrtCollection和GfollowCollection中 之后是构造预测分析表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//初始化表function initTable(wenfaData) &#123; let nonTerminalArray = []; let terminalArray = []; for (let i = 0; i &lt; wenfaData.length; i++) &#123; let production = wenfaData[i]; let nonTerminal = production[0]; let rightExpr = production[1]; for (let i = 0; i &lt; nonTerminal.length; i++) &#123; if (isNonTerminal(nonTerminal[i])) &#123; nonTerminalArray.push(nonTerminal[i]); &#125; else &#123; terminalArray.push(nonTerminal[i]); &#125; &#125; for (let i = 0; i &lt; rightExpr.length; i++) &#123; if (isNonTerminal(rightExpr[i])) &#123; nonTerminalArray.push(rightExpr[i]); &#125; else &#123; terminalArray.push(rightExpr[i]); &#125; &#125; &#125; nonTerminalArray = _.uniq(nonTerminalArray); terminalArray.push('#'); terminalArray = _.uniq(terminalArray); let ans = &#123;&#125;; for (let i = 0; i &lt; nonTerminalArray.length; i++) &#123; ans[nonTerminalArray[i]] = &#123;&#125;; for (let j = 0; j &lt; terminalArray.length; j++) &#123; //为null表示error ans[nonTerminalArray[i]][terminalArray[j]] = null; &#125; &#125; return ans;&#125; /*构造预测分析表，为null表示出错，为数字表示对应的wenfaData数组产生式中的位置*/export function generateTable(wenfaData, firstCollection, followCollection) &#123; let table = initTable(wenfaData); for (let i = 0; i &lt; wenfaData.length; i++) &#123; let production = wenfaData[i]; let nonTerminal = production[0]; let rightExpr = production[1]; let rightFirst = rightExpr[0]; if (!isNonTerminal(rightFirst)) &#123; //终结符 if (isEndCharacter(rightExpr)) &#123; //结束符 //求FOLLOW集 let followCollection = GfollowCollection[nonTerminal]; for (let j = 0; j &lt; followCollection.length; j++) &#123; let followCharacter = followCollection[j]; //利用产生式的位置i来表示对应的产生式 table[nonTerminal][followCharacter] = i; &#125; &#125; else &#123; //非结束符 直接填入 table[nonTerminal][rightFirst] = i; &#125; &#125; else &#123; //非终结符 let firstCollection = GfisrtCollection[rightFirst]; for (let j = 0; j &lt; firstCollection.length; j++) &#123; let firstCharacter = firstCollection[j]; //利用产生式的位置i来表示对应的产生式 table[nonTerminal][firstCharacter] = i; &#125; &#125; &#125; return table;&#125;","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://07lyt.com/tags/计算机基础/"}]}]